//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Untitled
//  @ File Name : boxes.h
//  @ Date : 10.07.2006
//  @ Author : Raphael Mnster
//
//

#include "boxes.h"
#include "distops.h"
#include "bspline.h"

////////////////////////////////////////////
//
//  CAABB:
//	basic bounding box class
//
//	
//
////////////////////////////////////////////

CAABB::CAABB(const vector<COBB*> &vBoxes)
{

	Real yT =  -1.7E+308;
	Real yB =   1.7E+308;
	Real xL =   1.7E+308;
	Real xR =  -1.7E+308;

	vector<COBB*>::const_iterator bIter;

	for(bIter = vBoxes.begin(); bIter != vBoxes.end(); bIter++)
	{
		COBB *box = *bIter;
		if(box->m_Vertices[0].x < xL)
			xL = box->m_Vertices[0].x;

		if(box->m_Vertices[2].x > xR)
			xR = box->m_Vertices[2].x;

		if(box->m_Vertices[0].y < yB)
			yB = box->m_Vertices[0].y;

		if(box->m_Vertices[2].y > yT)
			yT = box->m_Vertices[2].y;

	}

	m_Vertices[0].x = xL;
	m_Vertices[0].y = yB;
	m_Vertices[1].x = xR;
	m_Vertices[1].y = yT;

	

}//end constructor


CAABB::CAABB(const VECTOR2 &vA, const VECTOR2 &vB)
{
	m_Vertices[0] = vA;
	m_Vertices[1] = vB;
}//end constructor

bool CAABB::getLongestAxis()
{
	if((m_Vertices[1].x - m_Vertices[0].x) > (m_Vertices[1].y - m_Vertices[0].y))
		return xAxis;
	else
		return yAxis;
}//end getLongestAxis



void CAABB::calculateBounds(const vector<COBB*> &vBoxes)
{

	Real yT =  -1.7E+308;
	Real yB =   1.7E+308;
	Real xL =   1.7E+308;
	Real xR =  -1.7E+308;

	vector<COBB*>::const_iterator bIter;

	for(bIter = vBoxes.begin(); bIter != vBoxes.end(); bIter++)
	{
		COBB *box = *bIter;

		CBasicCurve *curve = box->m_pCurve;

		if(box->m_Vertices[0].x < xL)
			xL = box->m_Vertices[0].x;

		if(box->m_Vertices[2].x > xR)
			xR = box->m_Vertices[2].x;

		if(box->m_Vertices[0].y < yB)
			yB = box->m_Vertices[0].y;

		if(box->m_Vertices[2].y > yT)
			yT = box->m_Vertices[2].y;

	}

	m_Vertices[0].x = xL;
	m_Vertices[0].y = yB;
	m_Vertices[1].x = xR;
	m_Vertices[1].y = yT;

}//end calculateBounds

void CAABB::calculateBounds(CAABB *b1, CAABB *b2)
{
	m_Vertices[0].x = (b1->m_Vertices[0].x < b2->m_Vertices[0].x) ? b1->m_Vertices[0].x : b2->m_Vertices[0].x;

	m_Vertices[1].x = (b1->m_Vertices[1].x > b2->m_Vertices[1].x) ? b1->m_Vertices[1].x : b2->m_Vertices[1].x;

	m_Vertices[0].y = (b1->m_Vertices[0].y < b2->m_Vertices[0].y) ? b1->m_Vertices[0].y : b2->m_Vertices[0].y;

	m_Vertices[1].y = (b1->m_Vertices[1].y > b2->m_Vertices[1].y) ? b1->m_Vertices[1].y : b2->m_Vertices[1].y;

}//end calculateBounds

bool CAABB::inside(const VECTOR2& p)
{
	return (((p.x >= m_Vertices[0].x) && (p.x <= m_Vertices[1].x)) && ((p.y >= m_Vertices[0].y) && (p.y <= m_Vertices[1].y)));
}//end inside


/* class COBB */

//standard constructor
//bla
COBB::COBB()
{
}

/////////////////////////////////////////////////////////
//                  Constructor                        //
// Input: Two points that define a box								   //
//        values.                                      //
/////////////////////////////////////////////////////////

COBB::COBB(VECTOR2 vA, VECTOR2 vB, CBSpline *pCurve)
{

	/* bottom left vertex */
	m_Vertices[0].x = vA.x;
	m_Vertices[0].y = vA.y;
	/* bottom right vertex */
	m_Vertices[1].x = vB.x;
	m_Vertices[1].y = vA.y;
	
	/* top right vertex */
	m_Vertices[2].x = vB.x; 
	m_Vertices[2].y = vB.y;
	
	/* top left vertex */
	m_Vertices[3].x = vA.x;
	m_Vertices[3].y = vB.y;
	
	if(pCurve)
		m_pCurve = pCurve;
	else
		pCurve = NULL;

}//end constructor



COBB::COBB(COBB* pBox, CApproxCurve *pCurve)
{
	memcpy(m_Vertices, pBox->m_Vertices, 4*sizeof(VECTOR2));
	m_paCurve = pCurve;
}//end constructor

COBB::COBB(CPArray &cP, vector<int>& hP, CBSpline *pCurve)
{

	m_pCurve = pCurve;

	Real yB =  1.7E+308;
	Real yT = -1.7E+308;
	Real xL =  1.7E+308;
	Real xR = -1.7E+308;

	int num = (int)hP.size();

	for(int i = 0; i < num;i++)
	{
		if(yB > cP[hP[i]].y)
		{
			yB = cP[hP[i]].y;
		}
		if(yT < cP[hP[i]].y)
		{
			yT = cP[hP[i]].y;
		}
		if(xL > cP[hP[i]].x)
		{
			xL = cP[hP[i]].x;
		}
		if(xR < cP[hP[i]].x)
		{
			xR = cP[hP[i]].x;
		}
	}
	
	m_Vertices[0].x = xL;
	m_Vertices[0].y = yB;
	m_Vertices[1].x = xR;
	m_Vertices[1].y = yB;
	m_Vertices[2].x = xR; 
	m_Vertices[2].y = yT;
	m_Vertices[3].x = xL;
	m_Vertices[3].y = yT;

}//end constructor

COBB::COBB(const vector<VECTOR2> &cP, const vector<int> &hP, CBSpline *pCurve)
{

	m_pCurve = pCurve;

	Real yB =  1.7E+308;
	Real yT = -1.7E+308;
	Real xL =  1.7E+308;
	Real xR = -1.7E+308;

	int num = (int)hP.size();

	for(int i = 0; i < num;i++)
	{
		if(yB > cP[hP[i]].y)
			yB = cP[hP[i]].y;
		if(yT < cP[hP[i]].y)
			yT = cP[hP[i]].y;
		if(xL > cP[hP[i]].x)
			xL = cP[hP[i]].x;
		if(xR < cP[hP[i]].x)
			xR = cP[hP[i]].x;
		
	}
	

	m_Vertices[0].x = xL;
	m_Vertices[0].y = yB;
	m_Vertices[1].x = xR;
	m_Vertices[1].y = yB;
	m_Vertices[2].x = xR; 
	m_Vertices[2].y = yT;
	m_Vertices[3].x = xL;
	m_Vertices[3].y = yT;

}//end constructor



ostream& operator<<(ostream& out, COBB *b1) 
{
	for(int i = 0; i < 4; i++)
	{
		out << b1->m_Vertices[i];
	}

	return out;
}

////////////////////////////
//  Simple test:           
//  if p is inside the box
//	Input : Point to be tested
//  Output: true if inside else false
//
////////////////////////////
bool COBB::inside(const VECTOR2& p)
{
	
	
	for(int i = 0; i < 4; i++)
	{
		VECTOR2 vA = VECTOR2::createVector(m_Vertices[i], m_Vertices[(i+1)%4]);
		
		VECTOR2 vB = VECTOR2::CreateNormal(vA);

		vB.Normalize();

		VECTOR2 vC = VECTOR2::createVector(m_Vertices[i], p);

		vC.Normalize();

		Real dDot  = vC * vB;

		if(!((dDot > 0.0) && (dDot < 1.0)))
		{
			
			return false;
		}
	}

	return true;

	//return (((p.x >= m_Vertices[0].x) && (p.x <= m_Vertices[1].x)) && ((p.y >= m_Vertices[0].y) && (p.y <= m_Vertices[3].y)));

}//end inside

//////////////////////////////////////////
// Test if two boxes overlap            
// Input : extreme coordinates of the box
// Output: true if overlap else false
//////////////////////////////////////////
bool COBB::intersection(Real r, Real l, Real t, Real b)
{

	bool xOverlap = false;
	bool yOverlap = false;
	
	// check for xOverlap
	if(r > m_Vertices[1].x)
	{
		if(l < m_Vertices[1].x)
			xOverlap = true;
		else
			return false;
	}
	else
	{
		if(m_Vertices[0].x < r)
			xOverlap = true;
		else
			return false;
	}
	// check for yOverlap
	if(t > m_Vertices[2].y)
	{
		if(b < m_Vertices[2].y)
			yOverlap = true;
		else
			return false;
	}
	else
	{
		if(m_Vertices[1].y < t)
			yOverlap = true;
		else
			return false;
	}
	
	return xOverlap && yOverlap;

}

bool COBB::Overlap(COBB *pBox)
{

	bool bXOverlap = false;
	bool bYOverlap = false;

	if( (m_Vertices[0].x <= pBox->m_Vertices[0].x) && (pBox->m_Vertices[0].x <= m_Vertices[1].x) )
		bXOverlap = true;

	else if( (pBox->m_Vertices[0].x <= m_Vertices[0].x) && (pBox->m_Vertices[1].x >= m_Vertices[0].x) )
		bXOverlap = true;

	if( (m_Vertices[0].y <= pBox->m_Vertices[0].y) && (pBox->m_Vertices[0].y <= m_Vertices[3].y) )
		bYOverlap = true;

	else if( (pBox->m_Vertices[0].y <= m_Vertices[0].y) && (pBox->m_Vertices[3].y >= m_Vertices[0].y) )
		bYOverlap = true;

	return ( bXOverlap && bYOverlap );


}//end overlap

void COBB::getDimension()
{
	Real length = m_Vertices[2].x - m_Vertices[3].x;
	Real height = m_Vertices[3].y - m_Vertices[0].y;
	VECTOR2 vCenter = m_Vertices[2] + m_Vertices[0];
	vCenter = vCenter * 0.5;
	//printf("Length = %f, Height = %f center = (%f,%f)\n", length, height, vCenter.x, vCenter.y);
}//end getDimension

/* end class COBB */


/* class CSBB */

//standard constructor
//bla
CSBB::CSBB()
{
}

/////////////////////////////////////////////////////////
//                  Constructor                        //
// Input: Two points on the curve and their parameter  //
//        values.                                      //
/////////////////////////////////////////////////////////



CSBB::CSBB(VECTOR2 vA, VECTOR2 vB, Real fA, Real fB, CBSpline *pCurve) : m_fP1(fA), m_fP2(fB)
{

	m_pCurve = pCurve;
	
	if((vA.y >= vB.y) && (vA.x >= vB.x))
	{
		m_CurvePoints[0] = 2;
		m_CurvePoints[1] = 0;
		m_Vertices[0]    = vB;
		m_Vertices[1].x  = vA.x;
		m_Vertices[1].y  = vB.y;
		m_Vertices[2]    = vA;
		m_Vertices[3].x  = vB.x;
		m_Vertices[3].y  = vA.y;
	}
	else if((vB.y >= vA.y) && (vB.x >= vA.x))
	{
		m_CurvePoints[0] = 2;
		m_CurvePoints[1] = 0;
		m_Vertices[0]    = vA;
		m_Vertices[1].x  = vB.x;
		m_Vertices[1].y  = vA.y;
		m_Vertices[2]    = vB;
		m_Vertices[3].x  = vA.x;
		m_Vertices[3].y  = vB.y;
	}

	else if((vA.y >= vB.y) && (vB.x >= vA.x))
	{
		m_CurvePoints[0] = 3;
		m_CurvePoints[1] = 1;
		m_Vertices[0].x  = vA.x;
		m_Vertices[0].y  = vB.y;
		m_Vertices[1]    = vB;
		m_Vertices[2].x  = vB.x; 
		m_Vertices[2].y  = vA.y;
		m_Vertices[3]    = vA;
	}
	else
	{
		m_CurvePoints[0] = 3;
		m_CurvePoints[1] = 1;
		m_Vertices[0].x  = vB.x;
		m_Vertices[0].y  = vA.y;
		m_Vertices[1]    = vA;
		m_Vertices[2].x  = vA.x; 
		m_Vertices[2].y  = vB.y;
		m_Vertices[3]    = vB;
		
	}

}//end constructor

CSBB::CSBB(CSBB *pBox)
{

	m_pCurve = pBox->m_pCurve;

	for(int i = 0; i < 4; i++)
	{
		m_Vertices[i] = pBox->m_Vertices[i];
	}//end for

	for(int j = 0; j < 2; j++)
	{
		m_CurvePoints[j] = pBox->m_CurvePoints[j];
	}//end for

	m_fP1 = pBox->m_fP1;
	m_fP2 = pBox->m_fP2;
}//end constructor



//////////////////////////////////////////
// Test if two boxes overlap            
// Input : extreme coordinates of the box
// Output: true if overlap else false
//////////////////////////////////////////



ostream& operator<<(ostream& out, CSBB *b1)
{

	out <<"Begin box: "<<endl;
	for(int i = 0; i < 4; i++)
	{
		out << b1->m_Vertices[i];
	}//end for

	out <<b1->m_fP1<<endl;

	out <<b1->m_fP2<<endl;

	out<<"End box..."<<endl;

	return out;

}//end operator


//////////////////////////////////////////
//
//		class CSBBNode
//
//	class in a hierarchy of boxes
//  
//
//////////////////////////////////////////

CSBBNode::CSBBNode(CSBB *pBox)
{

	m_Box   = new CSBB(pBox);

	extern int _ID;
	m_Box->m_ID = _ID;
	_ID++;

	m_Children[0] = NULL;

	m_Children[1] = NULL;
	

}//end constructor

CSBBNode::CSBBNode()
{

	m_Box	= NULL;

	m_Children[0] = NULL;

	m_Children[1] = NULL;

}//end constructor


CSBBNode::~CSBBNode()
{

	if(m_Box)
	{
		delete m_Box;	
		m_Box = NULL;
	}

}//end deconstructor

void CSBBNode::subdivideNode(const VECTOR2 &vPoint,const VECTOR2 &vP1, const VECTOR2 &vP2,  Real dValue)
{
	
	CSBB *box = new CSBB(vP1, vPoint, m_Box->m_fP1, dValue, m_Box->m_pCurve);
	m_Children[0] = new CSBBNode(box);
	delete box;

	box = new CSBB(vPoint, vP2, dValue, m_Box->m_fP2, m_Box->m_pCurve);
	m_Children[1] = new CSBBNode(box);
	delete box;
}//end subdivideNode

Real CSBBNode::getLowerBoundDebug(const VECTOR2 &vQuery, VECTOR2 &vFar)
{
	cout<<"Debug Mode: "<<endl;
	
	VECTOR2 vCenter = (m_Box->m_Vertices[0] + m_Box->m_Vertices[1] + m_Box->m_Vertices[2] + m_Box->m_Vertices[3]) * 0.25;

	if( (vQuery.x >= vCenter.x) && (vQuery.y >= vCenter.y) )
	{
		VECTOR2 c = VECTOR2::createVector(vQuery, m_Box->m_Vertices[0]);
		vFar = m_Box->m_Vertices[0];
		return c.mag();
	}
	else if( (vQuery.x >= vCenter.x) && (vQuery.y < vCenter.y) )
	{
		VECTOR2 c = VECTOR2::createVector(vQuery, m_Box->m_Vertices[3]);
		vFar = m_Box->m_Vertices[3];
		return c.mag();
	}
	else if( (vQuery.x < vCenter.x) && (vQuery.y >= vCenter.y) )
	{
		VECTOR2 c = VECTOR2::createVector(vQuery, m_Box->m_Vertices[1]);
		vFar = m_Box->m_Vertices[1];
		return c.mag();
	}
	else
	{
		VECTOR2 c = VECTOR2::createVector(vQuery, m_Box->m_Vertices[2]);
		vFar = m_Box->m_Vertices[2];
		return c.mag();		
	}
	
}//end LowerBoundDebug

//Deprecated
Real CSBBNode::getUpperBound(const VECTOR2 &vQuery)
{
	return 1.0;
}//end getUpperBound

/////////////////////////////////////////////////
//
//	Class CSBBTree controls a Hierarchy of
//	segment bounding boxes.
//
//
/////////////////////////////////////////////////

/* constructor */
CSBBTree::CSBBTree()
{
	m_Root = NULL;
}//end constructor

CSBBTree::CSBBTree(CSBBNode *tNode) 
{
	m_Root = tNode;
}//end constructor


void CSBBTree::deleteSubTree(CSBBNode *pNode)
{
	if(pNode != NULL)
	{
		deleteSubTree(pNode->m_Children[0]);
		pNode->m_Children[0] = NULL;
		deleteSubTree(pNode->m_Children[1]);
		pNode->m_Children[1] = NULL;
		delete pNode;
		pNode = NULL;
	}//end if

}//end deleteSubree

void CSBBTree::subdivideNode(CSBBNode *pNode, const VECTOR2 &vPoint,const VECTOR2 &vP1, const VECTOR2 &vP2,  Real dValue)
{
	CSBB *box = new CSBB(vP1, vPoint, pNode->m_Box->m_fP1, dValue, pNode->m_Box->m_pCurve);
	pNode->m_Children[0] = new CSBBNode(box);
	delete box;

	box = new CSBB(vPoint, vP2, dValue, pNode->m_Box->m_fP2, pNode->m_Box->m_pCurve);
	pNode->m_Children[1] = new CSBBNode(box);
	delete box;
}//end subdivideNode

void CSBBTree::translateTree(CSBBNode *pNode, const VECTOR2 &vTrans)
{

	if(pNode != NULL)
	{
		translateTree(pNode->m_Children[0], vTrans);
		pNode->m_Box->translateBox(vTrans);
		translateTree(pNode->m_Children[1], vTrans);
	}//end if

}//end inOrder

////////////////////////////////////////
//
//	CBCNode:
//			 - a node in a hierarchy
//			   of bounding circles
//
////////////////////////////////////////

CBCNode::CBCNode(CSBBNode *pNode)
{
	/* set pointer to NULL */
	m_Children[0] = NULL;
	m_Children[1] = NULL;

	m_vCenter = pNode->m_Box->getCenter();

	int i;

	m_dRad = -1.7E+308;

	/* determine bounding circle radius */
	for(i = 0; i < 4; i++)
	{
		VECTOR2 vVertex = pNode->m_Box->m_Vertices[i];

		vVertex  = VECTOR2::createVector(m_vCenter, vVertex);

		Real d = vVertex.mag();

		if(m_dRad < d)
			m_dRad = d;

	}//end for	

}//end constructor

CBCNode::CBCNode(tCNode &tNode)
{
	m_Data = tNode.m_Data;
	m_dRad = tNode.m_dRad;
	m_ID   = tNode.m_ID;
	m_vCenter = tNode.m_vCenter;
	m_vUpper  = tNode.m_vUpper;
	m_Children[0] = NULL;
	m_Children[1] = NULL;
}//end constructor

CBCNode::~CBCNode()
{
	if(m_Children[0])
	{
		delete m_Children[0];
		m_Children[0] = NULL;
	}//end if

	if(m_Children[1])
	{
		delete m_Children[1];
		m_Children[1] = NULL;
	}//end if

}//end deconstructor

void CBCNode::GenerateLowerBound(VECTOR2 *vPoints, int nSize)
{

	Real minDist = 1.7E+308;

	for(int i = 0; i < nSize; i++)
	{
		VECTOR2 vV1 = VECTOR2::createVector(m_vCenter, vPoints[i]);
		Real dist   = vV1.mag();
		if(minDist > dist)
		{
			minDist = dist;
			m_vUpper = vPoints[i];
		}//end 

	}//end for
}//end GenerateLowerBound();

void CBCNode::DeleteSubtree(CBCNode *pNode)
{
	if(pNode != NULL)
	{
		DeleteSubtree(pNode->m_Children[0]);
		pNode->m_Children[0] = NULL;
		DeleteSubtree(pNode->m_Children[1]);
		pNode->m_Children[1] = NULL;
		delete pNode;
		pNode = NULL;
	}//end if

}//end deleteSubree










