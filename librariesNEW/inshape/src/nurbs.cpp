//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Untitled
//  @ File Name : CNurbs.cpp
//  @ Date : 22.06.2006
//  @ Author : Raphael Münster
//
//


#include <nurbs.h>
#include <exception.h>
#include <matrix2x2.h>
#include <matrix3x3.h>
#include <graham.h>
#include <sbbtree.h>
#include <obb2.h>
#include <fstream>
#include <queue>
#ifdef _USE_QT
#include <qdatetime.h>
#endif

/////////////////////////////////////////////////////////////////
//
//			             Constructor
//	Input: - degree of the curve
//		   - number of Points	
//		   - pointer to an array of doubles (knot vector)	
//		   - pointer to an array of the weights
//		   - pointer to an array of control points
//		   - the number of points that are wrapped at the 
//			 end of the curve
//
/////////////////////////////////////////////////////////////////
CNurbs::CNurbs(int deg, int numP, Real *kV, Real *w, VECTOR2 *cP, int nWrapped): CBSpline(deg, numP, kV, cP, nWrapped)
{
	
	m_vHomCoords.Resize(numP);

	for(int i = 0; i < numP; i++)
	{
		VECTOR2 t(cP[i].x * w[i], cP[i].y * w[i]);
		VECTOR3 tmp(t.x,t.y,w[i]);
		m_vHomCoords[i] = tmp;
	}

}//end constructor

CNurbs::~CNurbs()
{

}


void CNurbs::setWeight(Real val, int pos)
{
	if(pos < getNumPoints() && val > 0.0f)
	{
		m_vHomCoords[pos].x /= m_vHomCoords[pos].z;
		m_vHomCoords[pos].y /= m_vHomCoords[pos].z;
		m_vHomCoords[pos].z = val;
		m_vHomCoords[pos].x *= m_vHomCoords[pos].z;
		m_vHomCoords[pos].y *= m_vHomCoords[pos].z;

	}

}

VECTOR2 CNurbs::deBoor(Real u_v,bool draw)
{
	using namespace std;
	int k = findKnotSpan(u_v);
	if(k < 0)
		exit(0);
	
	int p = m_ideg;
	
	vector<VECTOR3>	i_deBoorPoints;
	vector<VECTOR3>	o_deBoorPoints;

	
	for(int j=k-p;j<=k;j++)
	{
		if(j < 0)
		{
               i_deBoorPoints.push_back(m_vHomCoords[(j+m_inumPoints)%(m_inumPoints)]);
				
		}
		else
		{
			i_deBoorPoints.push_back(m_vHomCoords[j]);
				
		}
	}
	
	
	///////////////////////////////////////MAIN ALGORITHM///////////////////////////////////////////////////////////
	for(int r=1;r<=p;r++)
	{

		int index = 1;
		o_deBoorPoints.clear();
		int i=k-p+r-1;
		//for(int i=k-p+r; i!=k ; i++)
		do{
			i++;
			if(i<0)
			{
				i	= i + m_inumPoints;
				u_v = u_v - m_KnotVector[0] + m_KnotVector[m_inumPoints];
				//printf("kleiner 0 addiere auf, ergebnis i=%d , u_v = %f und r=%d\n",i,u_v,r);
			}
			else
			{
				if(i >= m_inumPoints)
				{
					i	= i - m_inumPoints;
					u_v = u_v - m_KnotVector[m_inumPoints] + m_KnotVector[0]; 
					//printf("gr�sergleich 7 addiere auf, ergebnis i=%d , u_v = %f und r=%d\n",i,u_v,r);
				}
			}
			//compute blending value
			double air = (u_v - m_KnotVector[i])/(m_KnotVector[i+p-r+1] - m_KnotVector[i]);
			
			//inverse of blending value
			double Iair = 1.0 - air;
			VECTOR3 temp;
			temp.x = Iair*i_deBoorPoints[index-1].x + air * i_deBoorPoints[index].x;
			temp.y = Iair*i_deBoorPoints[index-1].y + air * i_deBoorPoints[index].y;
			temp.z = Iair*i_deBoorPoints[index-1].z + air * i_deBoorPoints[index].z;
						
			o_deBoorPoints.push_back(temp);
			index++;
		}while(i!=k);
		//clear,swap and repeat
		i_deBoorPoints.clear();
		i_deBoorPoints.assign(o_deBoorPoints.begin(), o_deBoorPoints.end());
		
	}
	VECTOR3 bla = o_deBoorPoints.back();
	VECTOR2 res(bla.x/bla.z, bla.y/bla.z);
	return res;
}

/////////////////////////////////////////////
//
//	         CoxDeBoor algorithm
//	evaluates the curve at parameter value u
//
//
/////////////////////////////////////////////


VECTOR2 CNurbs::CoxDeBoor(Real u)
{
	int k = findKnotSpan(u);
	if(k < 0)
	{
		printf("WARNING INVALID KNOT SPAN FOUND!\n");
		return VECTOR2(0,0);
	}
	
	int p = this->m_ideg;
	Real saved;
	Real* left  = new Real[p+1];
	Real* right = new Real[p+1];
	Real* N     = new Real[p+1];

	N[0] = 1.0;

	for(int j = 1; j <= p; j++)
	{
		left[j]  = u - m_KnotVector[k+1-j];
		right[j] = m_KnotVector[k+j] - u;
		saved = 0.0;
		for(int r = 0; r < j; r++)
		{
			double temp = N[r]/(right[r+1] + left[j-r]);
			N[r]	   = saved + right[r+1] * temp;
			saved	   = left[j-r] * temp;
		}
		
		N[j] = saved;
	}



/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		


	VECTOR3 res(0,0,0);


	for(int i = 0; i <= p; i++)
	{
		res.x += m_vHomCoords[k-p+i].x * N[i];
		res.y += m_vHomCoords[k-p+i].y * N[i];
		res.z += m_vHomCoords[k-p+i].z * N[i];
	}


	delete[] left;  
	delete[] right; 
	delete[] N;

	return VECTOR2(res.x/res.z, res.y/res.z);
	
}

VECTOR3* CNurbs::curveDerivs3(Real u, int n)
{
	int p = m_ideg;
	int i;
	int k = findKnotSpan(u);
	if(k < 0)
	{
		KSEXCEPTION("Invalid knot span", u);
	}//end if

	if( n > p)
	{
		printf("n zu gross\n");
		exit(0);
	}//end if

	

	VECTOR3* CK = new VECTOR3[n+1];
	
	Real** nders = this->derivativeBasis(u,n);

	for(i = 0; i<=n ; i++)
	{
		CK[i] = VECTOR3();
		for(int j = 0; j <= p; j++)
		{
			CK[i].x = CK[i].x + nders[i][j] * m_vHomCoords[k-p+j].x;
			CK[i].y = CK[i].y + nders[i][j] * m_vHomCoords[k-p+j].y;
			CK[i].z = CK[i].z + nders[i][j] * m_vHomCoords[k-p+j].z;
		}//end for j
	}//end for i


	for(i = 0; i < p + 1; i++)
		delete[] nders[i];

	delete[] nders;
	return CK;

}//end curveDerivs3

///////////////////////////////////////////////////////
//
//	calculates the derivatives of a NURBS curve C
//	
//	Input: - parameter value u at that the derivative C'(u) 
//			 is evaluated
//		   - n: all derivatives up the n-th are 	
//				computed
//
//  Output: CK an array of n points, CK[0] is C(u),
//			CK[1] is the tangent vector at C(u), CK[2]
//			is the tangent vector at C'(u) and so on
//
//////////////////////////////////////////////////////
VECTOR2* CNurbs::curveDerivs(Real u, int n)
{

	
	VECTOR3* Aders = curveDerivs3(u, n);
	VECTOR2* CK    = new VECTOR2[n+1];
	
	
		
	int i,k;


	for(k = 0; k <= n; k++)
	{
		VECTOR2 v(Aders[k].x, Aders[k].y); 
		for(i = 1; i <= k; i++)
		{
			Real bc = (Real)BinCoeff(k,i);

			v.x = v.x - bc * Aders[i].z * CK[k-i].x;
			v.y = v.y - bc * Aders[i].z * CK[k-i].y;
		}
		CK[k].x = v.x/Aders[0].z;
		CK[k].y = v.y/Aders[0].z;
	}//end for

	delete[] Aders;
	return CK;
}//end curveDerivs

void CNurbs::insertKnot(Real u, int t)
{

	int p = m_ideg;

	int mp = m_inumPoints + m_ideg + 1;

	int nq = m_inumPoints + t;

	int k = findKnotSpan(u);

	
	if(getMultiplicity(u) >= p)
		return;
	int s = 0;
	//new number of knots
	m_inumKnots+=t;

	//allocate memory for new knot vector and control points
	Real* UQ = new Real[m_inumKnots];
	VECTOR3* QW = new VECTOR3[nq];
	VECTOR3* RW = new VECTOR3[p+1];
	

	//Load new knot vector
	int i,j,l;
	for(i = 0; i <= k ; i++)
		UQ[i] = m_KnotVector[i];
	for(i = 1; i <= t; i++)
		UQ[k+i] = u;
	for(i = k + 1; i < mp; i++)
		UQ[i+t] = m_KnotVector[i];

	//Save unaltered control points
	for(i = 0; i <=k-p; i++)
		QW[i] = m_vHomCoords[i];
	for(i = k-s; i< m_inumPoints; i++)
		QW[i+t] = m_vHomCoords[i];
	for(i = 0; i <= p-s; i++)
		RW[i] = m_vHomCoords[k-p+i];

	//main algorithm : inserts knot value u t times
	for(j = 1; j <= t; j++)
	{
		l = k-p+j;
		for(i = 0; i <= p-j-s; i++)
		{
			Real alpha = (u - m_KnotVector[l+i])/(m_KnotVector[i+k+1] - m_KnotVector[l+i]);
			RW[i].x		 = alpha * RW[i+1].x + (1.0 - alpha) * RW[i].x;
			RW[i].y		 = alpha * RW[i+1].y + (1.0 - alpha) * RW[i].y;
			RW[i].z		 = alpha * RW[i+1].z + (1.0 - alpha) * RW[i].z;
		}
		QW[l] = RW[0];
		QW[k+t-j-s] = RW[p-j-s];
	}

	//load remaining control points
	for(i = l+1; i <k-s; i++)
	{
		QW[i] = RW[i-l];
	}

	

	delete[] RW;

	m_vHomCoords.Resize(QW,nq);
	m_KnotVector.Resize(UQ,m_inumKnots);
	m_inumPoints +=t;

	m_ControlPoints.Resize(m_inumPoints);
	for(int i=0; i<m_inumPoints;i++)
	{
		m_ControlPoints[i].x = m_vHomCoords[i].x/m_vHomCoords[i].z; 
		m_ControlPoints[i].y = m_vHomCoords[i].y/m_vHomCoords[i].z; 
	}
	
}//end insert knot


/////////////////////////////////////////////
//
//	  uniformly scales a NURBS curve
//
//	Input: scaling factor dScale
//
//
/////////////////////////////////////////////

void CNurbs::scale(Real dScale)
{

	VECTOR2 vOldCog = getCog();

	for(int i = 0; i < m_inumPoints; i++)
	{
		m_vHomCoords[i].x = m_vHomCoords[i].x * dScale;
		m_vHomCoords[i].y = m_vHomCoords[i].y * dScale;
	}
	updateControlPoints();
	
	updateCog();
	if(m_bBox)
	{
		delete m_bBox;
		m_bBox = NULL;
	}
	
	genBoxes();

	VECTOR2 vNewCog = getCog();

	translateCurve( (vOldCog - vNewCog) );
	

}

////////////////////////////////////////////
//
//	translates a curve along a vector
//
//	Input: the translation vector vTrans
//
//
////////////////////////////////////////////
void CNurbs::translateCurve(VECTOR2 vTrans)
{
	int i;
	for(i = 0; i < m_inumPoints; i++)
	{
		m_ControlPoints[i] = m_ControlPoints[i] + vTrans;
		VECTOR2 t(m_ControlPoints[i].x * m_vHomCoords[i].z , m_ControlPoints[i].y * m_vHomCoords[i].z);
		VECTOR3 tmp(t.x, t.y ,m_vHomCoords[i].z);
		m_vHomCoords[i] = tmp;
	}//end for

	/* get number of boxes */
	int m = (int)m_Boxes.size();

	/* translate segment boxes */
	for(i = 0; i < m; i++)
	{
		m_Boxes[i]->m_Vertices[3] = m_Boxes[i]->m_Vertices[3] + vTrans;
		m_Boxes[i]->m_Vertices[2] = m_Boxes[i]->m_Vertices[2] + vTrans;
		m_Boxes[i]->m_Vertices[0] = m_Boxes[i]->m_Vertices[0] + vTrans;
		m_Boxes[i]->m_Vertices[1] = m_Boxes[i]->m_Vertices[1] + vTrans;
	}//end for


	/* translate curve bounding box */
	m_bBox->m_Vertices[0] = m_bBox->m_Vertices[0] + vTrans;
	m_bBox->m_Vertices[1] = m_bBox->m_Vertices[1] + vTrans;
	m_bBox->m_Vertices[2] = m_bBox->m_Vertices[2] + vTrans;
	m_bBox->m_Vertices[3] = m_bBox->m_Vertices[3] + vTrans;


	/* translate bounding box hierarchy */
	for(int i = 0; i < m_iBoxes; i++)
	{
		m_Hierarchy[i]->translateTree(m_Hierarchy[i]->getRoot(), vTrans);
	}//end for
	
	
	updateCog();
	
}



void CNurbs::rotateBack(Real dAngle)
{

	VECTOR2 oldCog = m_vCog;
	VECTOR2 vTrans = m_vCog * -1.0;
 	translateCurve(vTrans);
	int i;
	MATRIX2X2 rotMat((Real)cos(dAngle), (Real)-sin(dAngle), (Real)sin(dAngle), (Real)cos(dAngle) );
	Real dEntries[9] = {cos(dAngle),-sin(dAngle),0,sin(dAngle), cos(dAngle),0,0,0,1};
	MATRIX3X3 hRotMat(dEntries);
 	for(i = 0; i < m_inumPoints; i++)
 	{
 		m_vHomCoords[i] = hRotMat * m_vHomCoords[i];
 	}
	
	updateControlPoints();

	int m = (int)m_Boxes.size();
	/* rotate segment boxes */
	for(i = 0; i < m; i++)
	{
		m_Boxes[i]->m_Vertices[3] = rotMat * m_Boxes[i]->m_Vertices[3];
		m_Boxes[i]->m_Vertices[2] = rotMat * m_Boxes[i]->m_Vertices[2];
		m_Boxes[i]->m_Vertices[0] = rotMat * m_Boxes[i]->m_Vertices[0];
		m_Boxes[i]->m_Vertices[1] = rotMat * m_Boxes[i]->m_Vertices[1];
	}
	/* rotate curve bounding box */

	m_bBox->m_Vertices[0] = rotMat * m_bBox->m_Vertices[0];
	m_bBox->m_Vertices[1] = rotMat * m_bBox->m_Vertices[1];
	m_bBox->m_Vertices[2] = rotMat * m_bBox->m_Vertices[2];
	m_bBox->m_Vertices[3] = rotMat * m_bBox->m_Vertices[3];

	updateControlPoints();
	translateCurve(oldCog);

}


void CNurbs::rotate(Real dAngle)
{

	VECTOR2 oldCog = m_vCog;
	VECTOR2 vTrans = m_vCog * -1.0;
 	translateCurve(vTrans);
	int i;
	
	MATRIX2X2 rotMat2((Real)cos(dAngle), (Real)-sin(dAngle), (Real)sin(dAngle), (Real)cos(dAngle) );
		
	Real dEntries2[9] = {cos(dAngle),-sin(dAngle),0,sin(dAngle), cos(dAngle),0,0,0,1};
	MATRIX3X3 hRotMat2(dEntries2);
	for(i = 0; i < m_inumPoints; i++)
	{
		m_vHomCoords[i] = hRotMat2 * m_vHomCoords[i];
	}

	int m = (int)m_Boxes.size();

	/* rotate segment boxes */
	for(i = 0; i < m; i++)
	{
		m_Boxes[i]->m_Vertices[3] = rotMat2 * m_Boxes[i]->m_Vertices[3];
		m_Boxes[i]->m_Vertices[2] = rotMat2 * m_Boxes[i]->m_Vertices[2];
		m_Boxes[i]->m_Vertices[0] = rotMat2 * m_Boxes[i]->m_Vertices[0];
		m_Boxes[i]->m_Vertices[1] = rotMat2 * m_Boxes[i]->m_Vertices[1];
	}

	/* rotate curve bounding box */

	m_bBox->m_Vertices[0] = rotMat2 * m_bBox->m_Vertices[0];
	m_bBox->m_Vertices[1] = rotMat2 * m_bBox->m_Vertices[1];
	m_bBox->m_Vertices[2] = rotMat2 * m_bBox->m_Vertices[2];
	m_bBox->m_Vertices[3] = rotMat2 * m_bBox->m_Vertices[3];
		
	
	updateControlPoints();
	translateCurve(oldCog);

}

void CNurbs::rotateCurve(Real dAngle)
{

	VECTOR2 oldCog = m_vCog;
	VECTOR2 vTrans = m_vCog * -1.0;
 	translateCurve(vTrans);
	int i;
	MATRIX2X2 rotMat((Real)cos(-m_dAngle), (Real)-sin(-m_dAngle), (Real)sin(-m_dAngle), (Real)cos(-m_dAngle) );
	Real dEntries[9] = {cos(-m_dAngle),-sin(-m_dAngle),0,sin(-m_dAngle), cos(-m_dAngle),0,0,0,1};
	MATRIX3X3 hRotMat(dEntries);
 	for(i = 0; i < m_inumPoints; i++)
 	{
 		m_vHomCoords[i] = hRotMat * m_vHomCoords[i];
 	}
	
	updateControlPoints();

	int m = (int)m_Boxes.size();
	/* rotate segment boxes */
	for(i = 0; i < m; i++)
	{
		m_Boxes[i]->m_Vertices[3] = rotMat * m_Boxes[i]->m_Vertices[3];
		m_Boxes[i]->m_Vertices[2] = rotMat * m_Boxes[i]->m_Vertices[2];
		m_Boxes[i]->m_Vertices[0] = rotMat * m_Boxes[i]->m_Vertices[0];
		m_Boxes[i]->m_Vertices[1] = rotMat * m_Boxes[i]->m_Vertices[1];
	}
	/* rotate curve bounding box */

	m_bBox->m_Vertices[0] = rotMat * m_bBox->m_Vertices[0];
	m_bBox->m_Vertices[1] = rotMat * m_bBox->m_Vertices[1];
	m_bBox->m_Vertices[2] = rotMat * m_bBox->m_Vertices[2];
	m_bBox->m_Vertices[3] = rotMat * m_bBox->m_Vertices[3];

	m_dAngle += dAngle;	
	
	MATRIX2X2 rotMat2((Real)cos(m_dAngle), (Real)-sin(m_dAngle), (Real)sin(m_dAngle), (Real)cos(m_dAngle) );
		////myVec = rotMat * myVec;
	Real dEntries2[9] = {cos(m_dAngle),-sin(m_dAngle),0,sin(m_dAngle), cos(m_dAngle),0,0,0,1};
	MATRIX3X3 hRotMat2(dEntries2);
	for(i = 0; i < m_inumPoints; i++)
	{
		m_vHomCoords[i] = hRotMat2 * m_vHomCoords[i];
	}

	/* rotate segment boxes */
	for(i = 0; i < m; i++)
	{
		m_Boxes[i]->m_Vertices[3] = rotMat2 * m_Boxes[i]->m_Vertices[3];
		m_Boxes[i]->m_Vertices[2] = rotMat2 * m_Boxes[i]->m_Vertices[2];
		m_Boxes[i]->m_Vertices[0] = rotMat2 * m_Boxes[i]->m_Vertices[0];
		m_Boxes[i]->m_Vertices[1] = rotMat2 * m_Boxes[i]->m_Vertices[1];
	}

	/* rotate curve bounding box */

	m_bBox->m_Vertices[0] = rotMat2 * m_bBox->m_Vertices[0];
	m_bBox->m_Vertices[1] = rotMat2 * m_bBox->m_Vertices[1];
	m_bBox->m_Vertices[2] = rotMat2 * m_bBox->m_Vertices[2];
	m_bBox->m_Vertices[3] = rotMat2 * m_bBox->m_Vertices[3];
	
	updateControlPoints();
	translateCurve(oldCog);

}

void CNurbs::updateControlPoints()
{
	for(int i = 0; i < m_inumPoints; i++)
	{
		m_ControlPoints[i].x = m_vHomCoords[i].x/m_vHomCoords[i].z; 
		m_ControlPoints[i].y = m_vHomCoords[i].y/m_vHomCoords[i].z; 
	}
}

/////////////////////////////////////////////////////
//
// prints knot vector and control points to a file
//
/////////////////////////////////////////////////////
void CNurbs::toFile(const char *fileName)
{
	/* Creates an ofstream object named myFile */
	ofstream myFile(fileName,ios::out);
    myFile.precision(16);

    if (! myFile) // test file 
    {
        cout << "Error opening output file" << endl;
        return;
    }

	int i;
	/* write control points */
	int num = getNumPoints();
	myFile <<num<<endl;
	for(i = 0; i < num ; i++)
	{
		myFile << m_ControlPoints[i].x<<endl;
		myFile << m_ControlPoints[i].y<<endl;
	}//end for i

	/* write weights */
	myFile<<num<<endl;
	for(i = 0; i < num ; i++)
	{
		myFile << m_vHomCoords[i].z<<endl;
	}//end for i
	
	/* write knots */
	num = getNumKnots();
	myFile <<num<<endl;
	for(i = 0; i < num; i++)
	{
		myFile <<m_KnotVector[i] <<endl;
	}
    myFile.close();
}


CONXNurbs::CONXNurbs(const char *sFileName)
{

	ONX_Model model;

   // open file containing opennurbs archive
    FILE* archive_fp = ON::OpenFile( sFileName, "rb");
    if ( !archive_fp ) 
    {
     
     cerr<<"Could not open archive "<<sFileName<<endl;
	 exit(0);
    }//end if

	const ON_NurbsCurve* curve = 0;


	ON_BinaryFile archive(ON::read3dm, archive_fp);

    bool rc = model.Read(archive);

    // close the file
    ON::CloseFile( archive_fp );

	if(rc)
		cout<<"Archive successfully read."<<endl;
	else
		cout<<"Error during reading"<<endl;

	if(model.IsValid())
		cout<<"Model is valid"<<endl;
	else
		cout<<"Model is not valid"<<endl;


	const ONX_Model_Object mo = model.m_object_table[0];

	curve = ON_NurbsCurve::Cast(mo.m_object);
	if ( curve ) 
	{
		cout<<"Found a nurbs curve"<<endl;
	}//end if

	int iOrder = curve->m_order;

	cout<<" order of curve "<<iOrder<<endl;

	cout<<"Number of control points: "<<curve->CVCount()<<endl;

	const ON_NurbsCurve& rCurve = *curve;

	m_Curve = ON_NurbsCurve(rCurve);

	m_ideg = m_Curve.m_order-2;

	m_inumPoints = m_Curve.CVCount();

	int size = m_Curve.m_order + m_Curve.m_cv_count-2;

	m_KnotVector.Resize(size);

	for(int i = 0; i < size; i++)
		m_KnotVector[i] = m_Curve.Knot(i);


	model.Destroy();

	m_bBox = NULL;

	m_ControlPoints = NULL;

}//end constructor

CONXNurbs::CONXNurbs(const ON_NurbsCurve& curve)
{

	int iOrder = curve.m_order;

	cout<<" order of curve "<<iOrder<<endl;

	cout<<"Number of control points: "<<curve.CVCount()<<endl;

	const ON_NurbsCurve& rCurve = curve;

	m_Curve = ON_NurbsCurve(rCurve);

	m_ideg = m_Curve.m_order-2;

	m_inumPoints = m_Curve.CVCount();

	int size = m_Curve.m_order + m_Curve.m_cv_count-2;

	m_KnotVector.Resize(size);

	for(int i = 0; i < size; i++)
		m_KnotVector[i] = m_Curve.Knot(i);

	
	m_bBox = NULL;

	m_ControlPoints = NULL;


}//end constructor

VECTOR2 CONXNurbs::CoxDeBoor(Real u)
{

	ON_3dPoint pVec;
	m_Curve.EvPoint(u, pVec);

	return VECTOR2(pVec.x, pVec.y);

}//end CoxDeBoor



void CONXNurbs::genBoxes(int nIter)
{
#ifdef _USE_QT
	QTime timer;
	timer.start();
#endif	
	if(nIter == 0)
	{
		CreateSimpleBVH();
#ifdef _USE_QT
		cout<<"Preprocessing time: "<<timer.elapsed()<<endl;
#endif
		return;
	}	
	
	if(!m_Boxes.empty())
		m_Boxes.clear();
   
	/* these std::vectors store the curve points where the monotonic segments end and begin and the parameter values */
	std::vector<Real>vRoots;
	std::vector<VECTOR2>vPoints;

	/* brute force algorithm to find the monotonic segments */
	findMonotoneSegments(vPoints, vRoots,2000);

	/* here a bounding box for the curve is generated */
	graham aGraham;
	aGraham.getPoints(vPoints, 1000);
	m_Hull = aGraham.compConvexHull();

	if(!m_bBox)
		m_bBox = new COBB(vPoints, m_Hull, this);

	/* create bounding boxes for the monotonic segments */
	int s = (int) vPoints.size();
	m_Hierarchy = new CSBBTree*[s];
	m_iBoxes    = s;
	
	
	for(int i = 0; i < s; i++)
	{
		CSBB *pCSBB = new CSBB(vPoints[i], vPoints[(i+1)%s], vRoots[i], vRoots[(i+1)%s], this);
		pCSBB->m_ID = i;
        m_Boxes.push_back(pCSBB);
		m_Hierarchy[i] = new CSBBTree(new CSBBNode(pCSBB));
	}//end for
	
	createHierarchy(1);
#ifdef _USE_QT	
	cout<<"Preprocessing time: "<<timer.elapsed()<<endl;
#endif

}//end genBoxes

VECTOR2 CONXNurbs::curveDerivs(Real u)
{

	ON_3dVector vVec;

	vVec = m_Curve.DerivativeAt(u);

	return VECTOR2(vVec.x, vVec.y);


}//end curveDerivs

VECTOR2 CONXNurbs::Ev2Deriv(Real u)
{

	ON_3dPoint a;
	ON_3dVector b;
	ON_3dVector c;

	m_Curve.Ev2Der(u,a,b,c);

	return VECTOR2(c.x, c.y);

}//end Ev2Deriv



void CONXNurbs::findMonotoneSegments(std::vector<VECTOR2>& vPoints, std::vector<Real>& vRoots, int nIters)
{
	
	
	//float dP =(float)( (curve.m_knot[curve.CVCount()] - curve.m_knot[curve.m_order-2]) / LOD);
	//float P = curve.m_knot[curve.m_order-2];

	Real T  = m_Curve.m_knot[m_ideg];
	bool signX;
	bool signY;
	//CRootFinder rFA;

	Real dT = (m_Curve.m_knot[m_inumPoints] - m_Curve.m_knot[m_ideg]) / 2000;
	VECTOR2 deriv = curveDerivs(T);
	if(deriv.y > 0)
		signX = true;
	else
		signX = false;

	if(deriv.x > 0)
		signY = true;
	else
		signY = false;

	if(deriv.x == 0.0)
	{
		vRoots.push_back(m_Curve.m_knot[m_ideg]);
		vPoints.push_back(CoxDeBoor(m_Curve.m_knot[m_ideg]));
	}//end if

	
	if(deriv.y == 0.0)
	{
		vRoots.push_back(m_Curve.m_knot[m_ideg]);
		vPoints.push_back(CoxDeBoor(m_Curve.m_knot[m_ideg]));
	}//end if


	int count = 0;
	for(int i = 0; i < nIters; i++)
	{
			
		deriv = curveDerivs(T);
		if((signX == false) && (deriv.y > 0))
		{
			signX		= true;
			Real p = T-dT/2;
			vRoots.push_back(p);
			vPoints.push_back(CoxDeBoor(p));
			count++;
		}//end if
		if((signX == true) &&(deriv.y < 0))
		{
			signX		= false;
			Real p = T-dT/2;
			vRoots.push_back(p);
			vPoints.push_back(CoxDeBoor(p));
			count++;
		}//end if

		if((signY == false) && (deriv.x > 0))
		{
			signY		= true;
			Real p = T-dT/2;
			vRoots.push_back(p);
			vPoints.push_back(CoxDeBoor(p));
			count++;
		}//end if
		if((signY == true) &&(deriv.x < 0))
		{
			signY		= false;
			Real p = T-dT/2;
			vRoots.push_back(p);
			vPoints.push_back(CoxDeBoor(p));
			count++;
		}//end if

		T+=dT;
	
	}//end for

}//end findMonotoneSegments


void CONXNurbs::createHierarchy(int i)
{

	/* a queue to store the nodes in the hierarchy */	
	queue<CSBBNode*> qNodes;

	/* insert the parent nodes into the queue */
	for(int i = 0; i < m_iBoxes; i++)
	{
		CSBBNode *boxNode = m_Hierarchy[i]->getRoot();
		qNodes.push(boxNode);
	}//end for
	
	/* the curve segments will be subdivided at this parameter value */
	Real fPmid = 0.0;

	/* leaf count at target depth */
	int nTargetNodeCount = NodeCount(TARGETDEPTH, m_iBoxes);

	/* current node count */
	int nNodeCount = 0;

	/* while depth limit is not yet reached */
	while(!qNodes.empty() && nNodeCount < nTargetNodeCount)
	{
		/* get the front node */
		CSBBNode *bNode = qNodes.front();

		/* release it from the queue */
		qNodes.pop();

		/* get the nodes bounding box */
		CSBB* box = bNode->m_Box;

		/* calculation of the parameter value the segment is split at */
		/* the segments are subdivided in the middle, but special casing  */
		/* is needed when the curve is wrapped around */
		if(box->m_fP2 > box->m_fP1)
		{

			fPmid  = (box->m_fP2 + box->m_fP1) / 2;
				
		}//end if
		/* special case */
		else
		{
			Real length = m_Curve.m_knot[m_inumPoints] - box->m_fP1 + box->m_fP2 - m_Curve.m_knot[m_ideg];

			if((length/2 + box->m_fP1) >= m_Curve.m_knot[getNumPoints()])
			{
				fPmid = length/2 + box->m_fP1 - m_Curve.m_knot[getNumPoints()] + m_Curve.m_knot[getDeg()];
			}//end if
			else
			{
				fPmid = box->m_fP1 + length/2;
			}//end else

		}//end else
			VECTOR2 vMid = CoxDeBoor(fPmid);
			VECTOR2 vA   = CoxDeBoor(box->m_fP1);
			VECTOR2 vB   = CoxDeBoor(box->m_fP2);

			///* first new box */
			bNode->subdivideNode(vMid,vA, vB, fPmid);
			qNodes.push(bNode->m_Children[0]);
			qNodes.push(bNode->m_Children[1]);
			
			nNodeCount++;
						
	}//end while

}//end createHierarchy

//============================================
//
//	  uniformly scales a NURBS curve
//
//	Input: scaling factor dScale
//
//============================================

void CONXNurbs::scale(Real dScale)
{

	VECTOR2 vOldCog = getCog();

	for(int i = 0; i < m_inumPoints; i++)
	{
		//m_vHomCoords[i].x = m_vHomCoords[i].x * dScale;
		//m_vHomCoords[i].y = m_vHomCoords[i].y * dScale;
	}
		
//	updateCog();
	if(m_bBox)
	{
		delete m_bBox;
		m_bBox = NULL;
	}
	
	//genBoxes(2000);

	VECTOR2 vNewCog = getCog();

	translateCurve( (vOldCog - vNewCog) );
	

}//end scale

/*!
    \fn CONXNurbs::CreateSimpleBVH()
 */
void CONXNurbs::CreateSimpleBVH()
{
	if(!m_Boxes.empty())
		m_Boxes.clear();
   
	/* these std::vectors store the curve points where the monotonic segments end and begin and the parameter values */
	std::vector<Real>vRoots;
	std::vector<VECTOR2>vPoints;

	/* brute force algorithm to find the monotonic segments */
	findMonotoneSegments(vPoints, vRoots,2000);

	/* here a bounding box for the curve is generated */
	graham aGraham;
	aGraham.getPoints(vPoints, 1000);
	m_Hull = aGraham.compConvexHull();

	if(!m_bBox)
		m_bBox = new COBB(vPoints, m_Hull, this);

	vPoints.clear();
	vRoots.clear();

	vPoints.push_back(CoxDeBoor(m_Curve.m_knot[m_ideg]));
	vRoots.push_back(m_Curve.m_knot[m_ideg]);
	vPoints.push_back(CoxDeBoor( (m_Curve.m_knot[m_inumPoints]-m_Curve.m_knot[m_ideg])/2.0 ));
	vRoots.push_back( (m_Curve.m_knot[m_inumPoints]-m_Curve.m_knot[m_ideg])/2.0 );
	vRoots.push_back( m_Curve.m_knot[m_inumPoints] );

	std::vector<VECTOR2>vSamples;

	/* create bounding boxes for the monotonic segments */
	int s = (int) vPoints.size();
	m_Hierarchy = new CSBBTree*[s];
	m_iBoxes    = s;
	
	for(int i = 0; i < s; i++)
	{
		GenSamples(vSamples, 150, vRoots[i], vRoots[i+1]);	
		CSBB *pCSBB = new CSBB(vSamples, vRoots[i], vRoots[i+1], this);
		pCSBB->m_ID = i;
		m_Boxes.push_back(pCSBB);
		m_Hierarchy[i] = new CSBBTree(new CSBBNode(pCSBB));
	}//end for

	BuiltBvh();
}


/*!
    \fn CONXNurbs::GenSamples(std::vector<VECTOR2> vPoints, int nS, Real start, Real end)
 */
void CONXNurbs::GenSamples(std::vector<VECTOR2> &vPoints, int nS, Real start, Real end)
{
	Real length = end - start;
	Real num    = nS;
	Real DT     = length/num;
	
  	Real t = start;
	
	for(int i = 0; i <=nS; i++)
	{
		vPoints.push_back(CoxDeBoor(t));
		t+=DT;
	}//end for
	
}//GenSamples


/*!
    \fn CNurbs::GenSamples(std::vector<VECTOR2> &samples, int nS, Real start, Real end)
 */
void CNurbs::GenSamples(std::vector<VECTOR2> &samples, int nS, Real start, Real end)
{
    /// @todo implement me
}


/*!
    \fn CONXNurbs::BuiltBvh()
 */
void CONXNurbs::BuiltBvh()
{
	/* a queue to store the nodes in the hierarchy */	
	queue<CSBBNode*> qNodes;

	/* insert the parent nodes into the queue */
	for(int i = 0; i < m_iBoxes; i++)
	{
		CSBBNode *boxNode = m_Hierarchy[i]->getRoot();
		qNodes.push(boxNode);
	}//end for
	
	/* the curve segments will be subdivided at this parameter value */
	Real fPmid = 0.0;

	/* leaf count at target depth */
	int nTargetNodeCount = NodeCount(TARGETDEPTH, m_iBoxes);

	/* current node count */
	int nNodeCount = 0;

	/* while depth limit is not yet reached */
	while(!qNodes.empty() && nNodeCount < nTargetNodeCount)
	{
		/* get the front node */
		CSBBNode *bNode = qNodes.front();

		/* release it from the queue */
		qNodes.pop();

		/* get the nodes bounding box */
		CSBB* box = bNode->m_Box;

		/* calculation of the parameter value the segment is split at */
		/* the segments are subdivided in the middle, but special casing  */
		/* is needed when the curve is wrapped around */
		if(box->m_fP2 > box->m_fP1)
		{

			fPmid  = (box->m_fP2 + box->m_fP1) / 2;
				
		}//end if
		/* special case */
		else
		{
			Real length = m_Curve.m_knot[m_inumPoints] - box->m_fP1 + box->m_fP2 - m_Curve.m_knot[m_ideg];

			if((length/2 + box->m_fP1) >= m_Curve.m_knot[getNumPoints()])
			{
				fPmid = length/2 + box->m_fP1 - m_Curve.m_knot[getNumPoints()] + m_Curve.m_knot[getDeg()];
			}//end if
			else
			{
				fPmid = box->m_fP1 + length/2;
			}//end else

		}//end else
		VECTOR2 vMid = CoxDeBoor(fPmid);
		VECTOR2 vA   = CoxDeBoor(box->m_fP1);
		VECTOR2 vB   = CoxDeBoor(box->m_fP2);

		///* first new box */
		bNode->SubdivideNode(fPmid);
		qNodes.push(bNode->m_Children[0]);
		qNodes.push(bNode->m_Children[1]);
			
		nNodeCount++;
						
	}//end while

}
