//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Untitled
//  @ File Name : CRootFinder.cpp
//  @ Date : 26.07.2006
//  @ Author : Raphael Mnster
//
//

#include <rootfinder.h>
#include <exception.h>
#include <nurbs.h>

int conv = 0;
//////////////////////////////////////////////////////////////////////
//
//	This function is an implementation of the bisection root finding method
//	Input:
//		- pCurve : the B-Spline or NURBS curve
//		- pvPoint: the point for the curve/point minimum distance computation
//		- xl	 : lower bound of the search interval
//		- xr	 : upper bound of the search interval
//		- e	 : convergence factor
//
//  Output:
//		- double: parameter value of the solution
//		
//		
//
//////////////////////////////////////////////////////////////////////

double CRootFinder::bisect(CBSpline* pCurve, const VECTOR2& pvPoint, double xl , double xr, double e)
{
// 	 printf(" Searching span [%f,%f]", xl, xr);
// 	 printf("\n    X0 = %f", xl);
// 	 printf("\n    X1 = %f", xr);
// 	 printf("\n Convergence criterion: %e\n", e);

	 /* stores the value of the derivative */
	 VECTOR2* deriv;
	
	 /* these variables store the values of the minimum distance equation at the
	 lower bound of the search interval and in the middle of the search interval */
	 double y0,yy;

	 /* counts number of iterations */
	 int m=0;

	 /* varible for solution */
	 x = 0;

	 /* start bisection */
	 do
	 {
		/* calculate derivative */
		 try {
		deriv = pCurve->curveDerivs(xl, 1);
		 }catch(cException &exception)
		 {
			 exception.writeMessage();
			 return -1.0;
		 }
		/* evaluate minimum distance equation at lower bound */
		y0= (pCurve->CoxDeBoor(xl) - pvPoint) * deriv[1];

		/* get value in the middle */
		x=(double)(xl+xr)/2;

		/* free memory */
		delete[] deriv;

		/* calculate value of derivative */
		deriv = pCurve->curveDerivs(x, 1);

		/* evaluate minimum distance equation in the middle of the interval */
		yy= (pCurve->CoxDeBoor(x) - pvPoint) * deriv[1];

		/* free memory */
		delete[] deriv;

		/* increase number of iterations */
		m++;

		/* converged or roundoff to zero */
		if (yy*y0==0) return x;
		/* different signs, hence the new xr is x */
		if (yy*y0<0) xr=x;
		/* same signs, hence the new xl is x */
		if (yy*y0>0) xl=x;

	 /* if not yet converged */
	 }while(fabs(xr-xl)>e);

	 //printf("\n\n The calculated zero is X = %f\n",x);
	 //deriv = pCurve->curveDerivs(x, 2);
	 //printf("\n The associated Y value is Y = %f\n",VECTOR2::dot((pCurve->CoxDeBoor(x) - pvPoint), deriv[1]));
	 //printf("\n The number of steps was: %d\n\n",m);
	 //delete[] deriv;
	 
	 return x;
}

double CRootFinder::bisectIntersec(CBSpline* pCurve, double y, double e, double xl, double xr, VECTOR2 &vPoint)
{

	double y0,yy;
	int m=0;
	do
	{
	 y0=pCurve->CoxDeBoor(xl).y - y;
	 x=(double)(xl+xr)/2;
	 vPoint = pCurve->CoxDeBoor(x);
	 yy= vPoint.y - y;
	
	 m++;
	 if (yy*y0==0) return x;
	 if (yy*y0<0) xr=x;
	 if (yy*y0>0) xl=x;
	}while(fabs(xr-xl)>e);
	
	 double res = x;
	 return res;
}//end bisectIntersec


double CRootFinder::bisectWrap(CBSpline* pCurve, const VECTOR2& pvPoint, double xl , double xr, double e)
{
// 	 printf(" Searching span [%f,%f]", xl, xr);
// 	 printf("\n    X0 = %f", xl);
// 	 printf("\n    X1 = %f", xr);
// 	 printf("\n Convergence criterion: %e\n", e);
	 VECTOR2* deriv;
	 bool wrap = true;
	 double length;
	 double y0,yy;
	 int m=0;
	 e100:
	 deriv = pCurve->curveDerivs(xl, 1);
	 y0= (pCurve->CoxDeBoor(xl) - pvPoint) * deriv[1];
	 delete[] deriv;
	 if(xl > xr)
	 {
		length = pCurve->GetKnot(pCurve->getNumPoints()) - xl + xr -  pCurve->GetKnot(pCurve->getDeg());
		if((length/2 + xl) >= pCurve->GetKnot(pCurve->getNumPoints()))
		{
			 
			x = length/2 + xl - pCurve->GetKnot(pCurve->getNumPoints()) + pCurve->GetKnot(pCurve->getDeg());
		}
		else
		{
			x=(double)(xl+length/2);
		}
	 }
	 else
		 x =(double)( xl + xr ) /2;
	 deriv = pCurve->curveDerivs(x, 1);
	 yy= (pCurve->CoxDeBoor(x) - pvPoint) * deriv[1];
	 delete[] deriv;
	 m++;
	 if (yy*y0==0) return x;
	 if (yy*y0<0) xr=x;
	 if (yy*y0>0) xl=x;
	 if (fabs(xr-xl)>e) goto e100;

// 	 printf("\n\n The calculated zero is X = %f\n",x);
// 	 deriv = pCurve->curveDerivs(x, 2);
// 	 printf("\n The associated Y value is Y = %f\n",VECTOR2::dot(pCurve->CoxDeBoor(x) - pvPoint, deriv[1]));
// 	 printf("\n The number of steps was: %d\n\n",m);
//	 delete[] deriv;	
	 double res = x;
	 return res;
}

double CRootFinder::bisectX(CBSpline* pCurve, double xl , double xr, double e)
{
	 x = 0.0;
// 	 printf("\n    X0 = %f", xl);
// 	 printf("\n    X1 = %f", xr);
// 	 printf("\n Convergence criterion: %e\n", e);
	 VECTOR2* deriv;
	
	 double y0,yy;
	 int m=0;
	 e100:
	 deriv = pCurve->curveDerivs(xl, 2);
	 y0=(double)deriv[1].y;
	 delete[] deriv;
	 x=(double)(xl+xr)/2;
	 deriv = pCurve->curveDerivs(x, 2);
	 yy=(double)deriv[1].y;
	 delete[] deriv;
	 m++;
	 if (yy*y0==0) return x;
	 if (yy*y0<0) xr=x;
	 if (yy*y0>0) xl=x;
	 if (fabs(xr-xl)>e) goto e100;

// 	 printf("\n\n The calculated zero is X = %f\n",x);
// 	 deriv = pCurve->curveDerivs(x, 2);
// 	 printf("\n The associated Y value is Y = %f\n",deriv[1].y);
// 	 printf("\n The number of steps was: %d\n\n",m);
// 	 delete[] deriv;

	 double res = x;
	 return res;
}

double CRootFinder::bisectY(CBSpline* pCurve, double xl , double xr, double e)
{
	 x = 0.0;
// 	 printf("\n    X0 = %f", xl);
// 	 printf("\n    X1 = %f", xr);
// 	 printf("\n Convergence criterion: %e\n", e);
	 VECTOR2* deriv;
	
	 double y0,yy;
	 int m=0;
	 e100:
	 deriv = pCurve->curveDerivs(xl, 2);
	 y0=(double)deriv[1].x;
	 x=(double)(xl+xr)/2;
	 delete[] deriv;
	 deriv = pCurve->curveDerivs(x, 2);
	 yy=(double)deriv[1].x;
	 delete[] deriv;
	 m++;
	 if (yy*y0==0) return x;
	 if (yy*y0<0) xr=x;
	 if (yy*y0>0) xl=x;
	 if (fabs(xr-xl)>e) goto e100;

// 	 printf("\n\n The calculated zero is X = %f\n",x);
// 	 deriv = pCurve->curveDerivs(x, 2);
// 	 printf("\n The associated Y value is Y = %f\n",deriv[1].x);
// 	 printf("\n The number of steps was: %d\n\n",m);
// 	 delete[] deriv;
	 return x;
}

///////////////////////////////////////////////////////////////////////////////////////////////
//
//	this function evaluates the equation for the distance between a point and a 
//  parametric curve and its derivative of the newton iteration.
//	the minimum distance equation is: (C(u)-P) * C'(u) = 0, where P is the point, C(u) the
//  value of the curve at parameter u and '*' is the dot product.
//
//	Input:
//		-pCurve : the curve
//		-pvPoint: point for minimum distance computation
//		-dX	    : parameter value at that the equation is evaluated
//		-y1	    : this variable will store the value of the derivative of the minimum distance
//				  equation
// Output:
//		- returns the value of the minimum distance equation at dX
//		- y1 stores the value of the derivative of the minimum distance equation at dX
//
//////////////////////////////////////////////////////////////////////////////////////////////

double CRootFinder::evalF(CBSpline* pCurve, const VECTOR2& pvPoint, double dX, double* y1)
{
	  /* calculate all derivative up to the 2nd at parameter dX */
 	 VECTOR2* deriv = pCurve->curveDerivs(dX, 2);

	  /* assign value of derivative of the minimum distance equation */
	  *y1 = ( (deriv[1] * deriv[1]) + ((pCurve->CoxDeBoor(dX) - pvPoint) * deriv[2]) );
	  //printf("u = %f, y = %f iter = %d\n",dX,deriv[2].y, n0);

	  /* calculate value of minimum distance equation */
	  double du = (pCurve->CoxDeBoor(dX) - pvPoint) * deriv[1]; 
	  //printf("u = %f, y = %f iter = %d\n",dX, du, n0);

	  /* free memory */
	  delete[] deriv;

	  /* return result */
	  return du;

}

//////////////////////////////////////////////////////////////////////
//
//	This function is an implementation of Newton's root finding method
//	Input:
//		- pCurve : the B-Spline or NURBS curve
//		- pvPoint: the point for the curve/point minimum distance computation
//		- dX0	 : start value for the newton iteration/also stores the result
//		- de	 : convergence factor
//		- maxIter: maximum number of iterations
//  Output:
//		- bool: converged or not converged
//		- dX0 : holds the value of the solution if converged
//				or junk if not converged
//
//////////////////////////////////////////////////////////////////////

bool CRootFinder::Newton(CBSpline* pCurve, const VECTOR2& pvPoint, double& dX0, double xl, double xr, double de, int imaxIterations)
{
	/* use newton iteration: Xi=(Xi-1)-(f(Xi-1)/f'(Xi-1)) */
	/* used to store the derivative f'(Xi-1) */
	double y1;
	/* counts number of iterations */
	n0=0;
	/* value of the function f(Xi-1) */
	double yy;
	
	do
	{
	try
	{
		/* try to get the values for f(Xi-1) and f'(Xi-1) */
	 	//yy=evalF(pCurve, pvPoint, dX0,&y1);
	  /* calculate all derivative up to the 2nd at parameter dX */
 	 VECTOR2* deriv = pCurve->curveDerivs(dX0, 2);

	  /* assign value of derivative of the minimum distance equation */
	  VECTOR2 tempPoint = pCurve->CoxDeBoor(dX0);
	  VECTOR2 vVecAB = tempPoint - pvPoint;
	  y1 =  (deriv[1] * deriv[1])  +  (vVecAB * deriv[2]);
	  //printf("u = %f, y = %f iter = %d\n",dX,deriv[2].y, n0);

	  /* calculate value of minimum distance equation */
	  yy = vVecAB * deriv[1]; 
	  //printf("u = %f, y = %f iter = %d\n",dX, du, n0);

	  /* free memory */
	  delete[] deriv;
	}
	catch(cException &exception)
	{
		exception.writeMessage();
		return false;
	}
	/* Update estimate */
	dX0=dX0-(yy/y1);
	
	/* if dX0 not valid */
	if((dX0 < xl) || (dX0 > xr))
	{
		return false;
	}
	
	/* increase number of iterations */
	n0++;
	/* if maxIterations is reached */
	if (n0>=imaxIterations)
	{
		//printf("Newton not converged after %d iterations, starting bisection\n\n",n0);
		return false;
	}

	/* if not yet converged */
	}while(fabs(yy/y1)>de);

	//printf("...Newton converged...\n");
	//printf("\n Convergence factor: %e",de);
	//printf("\n Maximum number of iterations: %d",imaxIterations);
	//printf("\n The calculated zero is X = %f\n",dX0);
	//VECTOR2* deriv = pCurve->curveDerivs(dX0, 1);
	//printf(" The associated Y value is Y = %.8f\n",VECTOR2::dot((pCurve->CoxDeBoor(dX0) - pvPoint), deriv[1]));
	//delete[] deriv;
	//printf(" The number of steps was: %d\n",n0);
	//printf("\n\n");
	/* converged: return true */
	return true;
}

bool CRootFinder::ONX_Newton(CONXNurbs* pCurve, const VECTOR2& pvPoint, double& dX0, double de, int imaxIterations)
{
	/* use newton iteration: Xi=(Xi-1)-(f(Xi-1)/f'(Xi-1)) */
	/* used to store the derivative f'(Xi-1) */
	double y1;
	/* counts number of iterations */
	n0=0;
	/* value of the function f(Xi-1) */
	double yy;
	
	do
	{
	try
	{
		/* try to get the values for f(Xi-1) and f'(Xi-1) */
	 	//yy=evalF(pCurve, pvPoint, dX0,&y1);
	  /* calculate all derivative up to the 2nd at parameter dX */
 	 VECTOR2 deriv2 = pCurve->Ev2Deriv(dX0);

	 VECTOR2 deriv1 = pCurve->curveDerivs(dX0);

	  /* assign value of derivative of the minimum distance equation */
	  VECTOR2 tempPoint = pCurve->CoxDeBoor(dX0);
	  VECTOR2 vVecAB = tempPoint - pvPoint;
	  y1 = (deriv1 * deriv1) + (vVecAB * deriv2);
	  //printf("u = %f, y = %f iter = %d\n",dX,deriv[2].y, n0);

	  /* calculate value of minimum distance equation */
	  yy = vVecAB * deriv1; 
	  //printf("u = %f, y = %f iter = %d\n",dX, du, n0);

	  /* free memory */

	}
	catch(cException &exception)
	{
		exception.writeMessage();
		return false;
	}
	/* Update estimate */
	dX0=dX0-(yy/y1);
	
	///* if dX0 not valid */
	//if((dX0 < xl) || (dX0 > xr))
	//{
	//	return false;
	//}
	
	/* increase number of iterations */
	n0++;
	/* if maxIterations is reached */
	if (n0>=imaxIterations)
	{
		//printf("Newton not converged after %d iterations, starting bisection\n\n",n0);
		return false;
	}

	/* if not yet converged */
	}while(fabs(yy/y1)>de);

	return true;
}

bool CRootFinder::ONX_bisect(CONXNurbs* pCurve, const VECTOR2& pvPoint, double xl , double xr, double e, double &u)
{

	 /* stores the value of the derivative */
	 VECTOR2 deriv;
	
	 /* these variables store the values of the minimum distance equation at the
	 lower bound of the search interval and in the middle of the search interval */
	 double y0,yy;

	 /* counts number of iterations */
	 int m=0;

	 /* varible for solution */
	 x = 0;

	 /* start bisection */
	 do
	 {
		/* calculate derivative */
		 try {
		deriv = pCurve->curveDerivs(xl);
		 }catch(cException &exception)
		 {
			 exception.writeMessage();
			 return false;
		 }
		/* evaluate minimum distance equation at lower bound */
		y0= (pCurve->CoxDeBoor(xl) - pvPoint) * deriv;

		/* get value in the middle */
		x=(double)(xl+xr)/2;
		
		/* calculate value of derivative */
		deriv = pCurve->curveDerivs(x);

		/* evaluate minimum distance equation in the middle of the interval */
		yy= (pCurve->CoxDeBoor(x) - pvPoint) * deriv;

		/* increase number of iterations */
		m++;

		/* converged or roundoff to zero */
		if (yy*y0==0) break;
		/* different signs, hence the new xr is x */
		if (yy*y0<0) xr=x;
		/* same signs, hence the new xl is x */
		if (yy*y0>0) xl=x;

		if(m > 11)return false;

	 /* if not yet converged */
	 }while(fabs(xr-xl)>e);
	 
	 u = x;
	 return true;
}


double CRootFinder::NewtonBisect(CBSpline* pCurve, const VECTOR2& pvPoint, double e, double xl, double xr)
{
	//printf("---------------------------------\n");
	/* stores parameter value of closest point */
	double dMin;
	/* stores starting value of newton iteration */
	double x0;
	/* explanation of special case: 
	*  We search the parameter interval [xl,xr], in case of a closed curve it is possible that xl > xr.
	*  A special search function has to be called to ensure that the search wraps around smoothly
	*/
	if(xl < xr)
	{
		/* start search in the middle of [xl,xr] */
		x0 =  (xl + xr)/2;
		if(Newton(pCurve, pvPoint, x0, xl, xr,1e-5, 7))
		{
			//printf("Loesung durch Newton\n\n");
			return x0;
		}
		/* newton did not converge, use bisection method */
		else
			{
			//printf("%d\n",conv);
			//conv++;
 			//printf("Starte Bisection\n\n");
			dMin = bisect(pCurve, pvPoint, xl , xr , 1e-5);
			}
	}
	/* special case uses bisectWrap search */
	else
	{
 		//printf("Loesung durch Bisection\n");
		dMin = (double)bisectWrap(pCurve, pvPoint, xl , xr , 1e-3);
	}
	/* return solution parameter value */
	
	return dMin;

}


double CRootFinder::IntersectWrap(CBSpline* pCurve, double y, double e, double xl, double xr)
{
// 	printf(" Searching span [%f,%f]", xl, xr);
// 	printf("\n    X0 = %f", xl);
// 	printf("\n    X1 = %f", xr);
// 	printf("\n Convergence criterion: %e\n", e);
	
	
	double length;
	double y0,yy;
	int m=0;
	 e100:
	 y0=pCurve->CoxDeBoor(xl).y - y;
	
	 if(xl > xr)
	 {
		 length = pCurve->GetKnot(pCurve->getNumPoints()) - xl + xr -  pCurve->GetKnot(pCurve->getDeg());
		 if((length/2 + xl) >= pCurve->GetKnot(pCurve->getNumPoints()))
		 {
			 
			 x = length/2 + xl - pCurve->GetKnot(pCurve->getNumPoints()) + pCurve->GetKnot(pCurve->getDeg());
		 }
		 else
		 {
			 x=(double)(xl+length/2);
		 }
	 }
	 else
		 x =(double)( xl + xr ) /2;
	
	 yy=pCurve->CoxDeBoor(x).y - y;
	
	 m++;
	 if (yy*y0==0) return x;
	 if (yy*y0<0) xr=x;
	 if (yy*y0>0) xl=x;
	 if (fabs(xr-xl)>e) goto e100;

// 	 printf("\n\n The calculated zero is X = %f\n",x);
// 	 printf("\n The associated Y value is Y = %f\n",pCurve->CoxDeBoor(x).y - y);
// 	 printf("\n The number of steps was: %d\n\n",m);
	 double res = x;
	 return res;
}

double CRootFinder::NewtonIntersec(CBSpline* pCurve, double y, double de, double xl, double xr, int numIter)
{

	double dX0;
	/* start value */
	dX0 = (xr + xl)/2.0;
		
	/* counts number of iterations */
	n0=0;
	/* value of the function f(Xi-1) */
	double yy; 
	
	/* value of derivative */
	double y1;
	do
	{
	try
	{
		/* try to get the values for f'(Xi-1) */
		yy = pCurve->CoxDeBoor(dX0).y - y;
		VECTOR2* deriv = pCurve->curveDerivs(dX0, 1);
		y1 = deriv[1].y;
		delete[] deriv;
	}
	catch(cException &exception)
	{
		exception.writeMessage();
		return -1.0;
	}
	/* Update estimate */
	dX0=dX0-(yy/y1);
	
	/* if dX0 not valid */
	if((dX0 < xl) || (dX0 > xr))
	{
		return -1.0;
	}
	
	/* increase number of iterations */
	n0++;
	/* if maxIterations is reached */
	if (n0>=numIter)
	{
		//printf("Newton not converged after %d iterations, starting bisection\n\n",n0);
		return -1.0;
	}

	/* if not yet converged */
	}while(fabs(yy/y1)>de);

	
	return dX0;

}