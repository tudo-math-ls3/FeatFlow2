diff -Naur SRC.orig/cagmg_mumps.f90 SRC/cagmg_mumps.f90
--- SRC.orig/cagmg_mumps.f90	2012-09-19 16:04:44.138886274 +0200
+++ SRC/cagmg_mumps.f90	2012-09-19 16:05:01.361129510 +0200
@@ -46199,6 +46199,107 @@
       INTEGER NTOTPV, NTOTPVTOT, NMAXNPIV
       INTEGER(8) :: POSFAC, LRLU, IPTRLU, LRLUS
       INTEGER IWPOS, LEAF, NBROOT, NROOT
+      INTERFACE CAGMG_MUMPS_251__
+      SUBROUTINE CAGMG_MUMPS_251(N,IW,LIW,A,LA,                              &
+     &             NSTK_STEPS, NBPROCFILS,IFLAG,ND,FILS,STEP,           &
+     &             FRERE, DAD, CAND,                                    &
+     &             ISTEP_TO_INIV2, TAB_POS_IN_PERE,                     &
+     &             MAXFRT, NTOTPV, NMAXNPIV, PTRIST, PTRAST,            &
+     &             PIMASTER, PAMASTER, PTRARW,PTRAIW,                   &
+     &             ITLOC, IERROR,IPOOL, LPOOL,                          &
+     &             RINFO, POSFAC ,IWPOS, LRLU, IPTRLU,                  &
+     &             LRLUS, LEAF, NBROOT, NBRTOT,                         &
+     &             UU, ICNTL, PTLUST_S, PTRFAC, NSTEPS, INFO,           &
+     &             KEEP,KEEP8,                                          &
+     &             PROCNODE_STEPS,SLAVEF,MYID, COMM_NODES,              &
+     &             MYID_NODES,                                          &
+     &             BUFR,LBUFR,LBUFR_BYTES,INTARR,DBLARR,root,           &
+     &             PERM, NELT, FRTPTR, FRTELT, LPTRAR,                  &
+     &             COMM_LOAD, ASS_IRECV, SEUIL, SEUIL_LDLT_NIV2,        &
+     &             MEM_DISTRIB, NE,                                     &
+     &     DKEEP,PIVNUL_LIST,LPN_LIST)
+      USE CAGMG_MUMPS_LOAD
+      USE CAGMG_MUMPS_OOC
+      IMPLICIT NONE
+!
+      TYPE CAGMG_MUMPS_ROOT_STRUC
+        SEQUENCE
+        INTEGER MBLOCK, NBLOCK, NPROW, NPCOL
+        INTEGER MYROW, MYCOL
+        INTEGER ROOT_SIZE, TOT_ROOT_SIZE
+        INTEGER :: CNTXT_BLACS, truc
+        INTEGER, DIMENSION(:), POINTER :: RG2L_ROW
+        INTEGER, DIMENSION(:), POINTER :: RG2L_COL
+        INTEGER , DIMENSION(:), POINTER :: IPIV
+        INTEGER, DIMENSION( 9 ) :: DESCRIPTOR, DESCB
+        LOGICAL yes, gridinit_done
+        INTEGER LPIV, brol
+!       Used to access Schur easily from root structure
+        COMPLEX, DIMENSION(:), POINTER :: SCHUR_POINTER
+        INTEGER SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD, machin
+!
+!      Data for nullspace/QR
+!
+        COMPLEX, DIMENSION(:), POINTER :: QR_TAU
+        REAL     QR_RCOND, bazar
+!
+!      Givens rotations
+!
+        INTEGER MAXG, GIND
+        COMPLEX, DIMENSION(:),POINTER::GROW, GCOS, GSIN
+!
+!      RRRLU data
+!
+        INTEGER ELG_MAX,NULL_MAX
+        INTEGER ELIND,EUIND,NLUPDATE,NUUPDATE
+        INTEGER,DIMENSION(:),POINTER::PERM_ROW,PERM_COL
+        INTEGER,DIMENSION(:),POINTER::ELROW, EUROW, PTREL, PTREU
+        COMPLEX, DIMENSION(:), POINTER :: ELELG, EUELG, DL
+!
+      END TYPE CAGMG_MUMPS_ROOT_STRUC
+      TYPE (CAGMG_MUMPS_ROOT_STRUC) :: root
+      INTEGER N,IFLAG,NTOTPV,MAXFRT,LIW, LPTRAR, NMAXNPIV,              &
+     &        IERROR, NSTEPS, INFO(40)
+      INTEGER(8) :: LA
+      COMPLEX, TARGET :: A(LA)
+      INTEGER SLAVEF, COMM_NODES, MYID, MYID_NODES
+      INTEGER, DIMENSION(0: SLAVEF - 1) :: MEM_DISTRIB
+      INTEGER KEEP(500), ICNTL(40)
+      INTEGER*8 KEEP8(150)
+      INTEGER LPOOL
+      INTEGER PROCNODE_STEPS(KEEP(28))
+      INTEGER ITLOC(N)
+      INTEGER IW(LIW), NSTK_STEPS(KEEP(28)), NBPROCFILS(KEEP(28))
+      INTEGER PTRARW(LPTRAR), PTRAIW(LPTRAR), ND(KEEP(28))
+      INTEGER FILS(N),PTRIST(KEEP(28))
+      INTEGER STEP(N), FRERE(KEEP(28)), DAD(KEEP(28))
+      INTEGER PIMASTER(KEEP(28))
+      INTEGER PTLUST_S(KEEP(28)), PERM(N)
+      INTEGER CAND(SLAVEF+1,max(1,KEEP(56)))
+      INTEGER   ISTEP_TO_INIV2(KEEP(71)),                               &
+     &          TAB_POS_IN_PERE(SLAVEF+2,max(1,KEEP(56)))
+      INTEGER IPOOL(LPOOL)
+      INTEGER NE(KEEP(28))
+      REAL RINFO(20)
+      INTEGER(8) :: PAMASTER(KEEP(28)), PTRAST(KEEP(28))
+      INTEGER(8) :: PTRFAC(KEEP(28))
+      INTEGER(8) :: POSFAC, LRLU, LRLUS, IPTRLU
+      INTEGER IWPOS, LEAF, NBROOT
+      INTEGER COMM_LOAD, ASS_IRECV
+      REAL UU, SEUIL, SEUIL_LDLT_NIV2
+      INTEGER NELT
+      INTEGER FRTPTR( N+1 ), FRTELT( NELT )
+      INTEGER LBUFR, LBUFR_BYTES
+      INTEGER BUFR( LBUFR )
+      INTEGER        INTARR( max(1,KEEP(14)) )
+      COMPLEX DBLARR( max(1,KEEP(13)) )
+      LOGICAL IS_ISOLATED_NODE
+      INTEGER LPN_LIST
+      INTEGER PIVNUL_LIST(LPN_LIST)
+      REAL DKEEP(30)
+      INTEGER NBFIN, NBRTOT, NBROOT_TRAITEES
+      END SUBROUTINE CAGMG_MUMPS_251
+      END INTERFACE CAGMG_MUMPS_251__
       KEEP(41)=0
       KEEP(42)=0
       NSTEPS   = 0
@@ -63560,6 +63661,190 @@
      &     NFSIZPTR,                                                    &
      &     FILSPTR,                                                     &
      &     FREREPTR
+      INTERFACE CAGMG_MUMPS_746__
+      SUBROUTINE CAGMG_MUMPS_746( ID, PTRAR )
+      USE CAGMG_MUMPS_STRUC_DEF
+      IMPLICIT NONE
+!
+      INTEGER AGMG_MPF_2DOUBLE_PRECISION
+      INTEGER AGMG_MPF_2INTEGER
+      INTEGER AGMG_MPF_2REAL
+      INTEGER AGMG_MPF_ANY_SOURCE
+      INTEGER AGMG_MPF_ANY_TAG
+      INTEGER AGMG_MPF_BYTE
+      INTEGER AGMG_MPF_CHARACTER
+      INTEGER AGMG_MPF_COMM_NULL
+      INTEGER AGMG_MPF_COMM_WORLD
+      INTEGER AGMG_MPF_COMPLEX
+      INTEGER AGMG_MPF_DOUBLE_COMPLEX
+      INTEGER AGMG_MPF_DOUBLE_PRECISION
+      INTEGER AGMG_MPF_INTEGER
+      INTEGER AGMG_MPF_LOGICAL
+      INTEGER AGMG_MPF_MAX
+      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
+      INTEGER AGMG_MPF_MAXLOC
+      INTEGER AGMG_MPF_MIN
+      INTEGER AGMG_MPF_MINLOC
+      INTEGER AGMG_MPF_PACKED
+      INTEGER AGMG_MPF_PROD
+      INTEGER AGMG_MPF_REAL
+      INTEGER AGMG_MPF_REPLACE
+      INTEGER AGMG_MPF_REQUEST_NULL
+      INTEGER AGMG_MPF_SOURCE
+      INTEGER AGMG_MPF_STATUS_SIZE
+      INTEGER AGMG_MPF_SUM
+      INTEGER AGMG_MPF_TAG
+      INTEGER AGMG_MPF_UNDEFINED
+      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
+      INTEGER AGMG_MPF_LOR
+      INTEGER AGMG_MPF_LAND
+      INTEGER AGMG_MPF_INTEGER8
+      INTEGER AGMG_MPF_REAL8
+      INTEGER AGMG_MPF_BSEND_OVERHEAD
+      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
+      PARAMETER (AGMG_MPF_2INTEGER=2)
+      PARAMETER (AGMG_MPF_2REAL=3)
+      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
+      PARAMETER (AGMG_MPF_ANY_TAG=5)
+      PARAMETER (AGMG_MPF_BYTE=6)
+      PARAMETER (AGMG_MPF_CHARACTER=7)
+      PARAMETER (AGMG_MPF_COMM_NULL=8)
+      PARAMETER (AGMG_MPF_COMM_WORLD=9)
+      PARAMETER (AGMG_MPF_COMPLEX=10)
+      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
+      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
+      PARAMETER (AGMG_MPF_INTEGER=13)
+      PARAMETER (AGMG_MPF_LOGICAL=14)
+      PARAMETER (AGMG_MPF_MAX=15)
+      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
+      PARAMETER (AGMG_MPF_MAXLOC=16)
+      PARAMETER (AGMG_MPF_MIN=17)
+      PARAMETER (AGMG_MPF_MINLOC=18)
+      PARAMETER (AGMG_MPF_PACKED=19)
+      PARAMETER (AGMG_MPF_PROD=20)
+      PARAMETER (AGMG_MPF_REAL=21)
+      PARAMETER (AGMG_MPF_REPLACE=22)
+      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
+      PARAMETER (AGMG_MPF_SOURCE=1)
+      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
+      PARAMETER (AGMG_MPF_SUM=26)
+      PARAMETER (AGMG_MPF_TAG=2)
+      PARAMETER (AGMG_MPF_UNDEFINED=28)
+      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
+      PARAMETER (AGMG_MPF_LOR=31)
+      PARAMETER (AGMG_MPF_LAND=32)
+      PARAMETER (AGMG_MPF_INTEGER8=33)
+      PARAMETER (AGMG_MPF_REAL8=34)
+      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
+      DOUBLE PRECISION AGMG_MPF_WTIME
+      EXTERNAL AGMG_MPF_WTIME
+      INTERFACE AGMG_COPY
+      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      INTEGER :: S(*),R(*)
+      END SUBROUTINE AGMG_COPY_INTEGER
+      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      INTEGER :: S,R(N)
+      END SUBROUTINE AGMG_COPY_INTEGER1
+      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      INTEGER :: S,R
+      END SUBROUTINE AGMG_COPY_INTEGER11
+      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      INTEGER(8) :: S
+      INTEGER:: R
+      END SUBROUTINE AGMG_COPY_INTEGER1_81
+      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      INTEGER :: S(N),R
+      END SUBROUTINE AGMG_COPY_INTEGER10
+      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N(*), DATATYPE, IERR
+      INTEGER :: S(N(1),1),R(N(1))
+      END SUBROUTINE AGMG_COPY_INTEGER21
+      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      REAL :: S(*),R(*)
+      END SUBROUTINE AGMG_COPY_REAL
+      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      REAL :: S,R(N)
+      END SUBROUTINE AGMG_COPY_REAL1
+      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      REAL :: S,R
+      END SUBROUTINE AGMG_COPY_REAL11
+      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      REAL :: S(N),R
+      END SUBROUTINE AGMG_COPY_REAL10
+      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      DOUBLE PRECISION :: S(*),R(*)
+      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
+      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      DOUBLE PRECISION :: S,R(N)
+      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
+      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      DOUBLE PRECISION :: S,R
+      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
+      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      DOUBLE PRECISION :: S(N),R
+      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
+      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      COMPLEX :: S(*),R(*)
+      END SUBROUTINE AGMG_COPY_COMPLEX
+      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      COMPLEX :: S,R(N)
+      END SUBROUTINE AGMG_COPY_COMPLEX1
+      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      COMPLEX :: S,R
+      END SUBROUTINE AGMG_COPY_COMPLEX11
+      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      DOUBLE COMPLEX :: S(*),R(*)
+      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
+      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      DOUBLE COMPLEX :: S,R(N)
+      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
+      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      DOUBLE COMPLEX :: S,R
+      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
+      END INTERFACE
+      TYPE(CAGMG_MUMPS_STRUC), INTENT(IN), TARGET :: ID
+      INTEGER, TARGET          :: PTRAR(ID%N,2)
+      END SUBROUTINE CAGMG_MUMPS_746
+      END INTERFACE CAGMG_MUMPS_746__
       IS_REORDERTREE_CALLED=.FALSE.
       KEEP   => id%KEEP
       KEEP8  => id%KEEP8
@@ -66578,6 +66863,121 @@
          PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
      &             S_ROOTBAND_INIT=0)
       DOUBLE PRECISION    OPASSW, OPELIW
+      INTERFACE CAGMG_MUMPS_140_141__
+      SUBROUTINE CAGMG_MUMPS_140( N, INODE, IW, LIW, A, LA,                  &
+     &                           IOLDPS, POSELT, IFLAG,                 &
+     &                           UU, NNEG, NPVW,                        &
+     &                           KEEP,KEEP8,                            &
+     &                           MYID, SEUIL, AVOID_DELAYED, ETATASS,   &
+     &     DKEEP,PIVNUL_LIST,LPN_LIST, IWPOS )
+      USE CAGMG_MUMPS_OOC
+      IMPLICIT NONE
+      INTEGER(8) :: LA, POSELT
+      INTEGER N, INODE, LIW, IFLAG, NNEG, NPVW
+      INTEGER MYID, SLAVEF, IOLDPS
+      INTEGER KEEP( 500 )
+      INTEGER*8 KEEP8(150)
+      REAL UU, SEUIL
+      COMPLEX A( LA )
+      INTEGER, TARGET :: IW( LIW )
+      LOGICAL AVOID_DELAYED
+      INTEGER ETATASS, IWPOS
+      INTEGER LPN_LIST
+      INTEGER PIVNUL_LIST(LPN_LIST)
+      REAL DKEEP(30)
+      END SUBROUTINE CAGMG_MUMPS_140
+      SUBROUTINE CAGMG_MUMPS_141( COMM_LOAD, ASS_IRECV,                      &
+     &           N, INODE, FPERE, IW, LIW, A, LA,                       &
+     &           UU, NOFFW,                                             &
+     &           NPVW,                                                  &
+     &             COMM, MYID, BUFR, LBUFR,LBUFR_BYTES,NBFIN,LEAF,      &
+     &             IFLAG, IERROR, IPOOL,LPOOL,                          &
+     &             SLAVEF, POSFAC, IWPOS, IWPOSCB, IPTRLU, LRLU,        &
+     &             LRLUS, COMP,                                         &
+     &             PTRIST, PTRAST, PTLUST_S, PTRFAC, STEP,              &
+     &             PIMASTER, PAMASTER,                                  &
+     &             NSTK_S,NBPROCFILS,PROCNODE_STEPS, root,              &
+     &             OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,         &
+     &             INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND, FRERE,        &
+     &             LPTRAR, NELT, FRTPTR, FRTELT, SEUIL,                 &
+     &             ISTEP_TO_INIV2, TAB_POS_IN_PERE, AVOID_DELAYED,      &
+     &            DKEEP,PIVNUL_LIST,LPN_LIST )
+      USE CAGMG_MUMPS_OOC
+      IMPLICIT NONE
+!
+      TYPE CAGMG_MUMPS_ROOT_STRUC
+        SEQUENCE
+        INTEGER MBLOCK, NBLOCK, NPROW, NPCOL
+        INTEGER MYROW, MYCOL
+        INTEGER ROOT_SIZE, TOT_ROOT_SIZE
+        INTEGER :: CNTXT_BLACS, truc
+        INTEGER, DIMENSION(:), POINTER :: RG2L_ROW
+        INTEGER, DIMENSION(:), POINTER :: RG2L_COL
+        INTEGER , DIMENSION(:), POINTER :: IPIV
+        INTEGER, DIMENSION( 9 ) :: DESCRIPTOR, DESCB
+        LOGICAL yes, gridinit_done
+        INTEGER LPIV, brol
+!       Used to access Schur easily from root structure
+        COMPLEX, DIMENSION(:), POINTER :: SCHUR_POINTER
+        INTEGER SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD, machin
+!
+!      Data for nullspace/QR
+!
+        COMPLEX, DIMENSION(:), POINTER :: QR_TAU
+        REAL     QR_RCOND, bazar
+!
+!      Givens rotations
+!
+        INTEGER MAXG, GIND
+        COMPLEX, DIMENSION(:),POINTER::GROW, GCOS, GSIN
+!
+!      RRRLU data
+!
+        INTEGER ELG_MAX,NULL_MAX
+        INTEGER ELIND,EUIND,NLUPDATE,NUUPDATE
+        INTEGER,DIMENSION(:),POINTER::PERM_ROW,PERM_COL
+        INTEGER,DIMENSION(:),POINTER::ELROW, EUROW, PTREL, PTREU
+        COMPLEX, DIMENSION(:), POINTER :: ELELG, EUELG, DL
+!
+      END TYPE CAGMG_MUMPS_ROOT_STRUC
+      INTEGER COMM_LOAD, ASS_IRECV
+      INTEGER N, INODE, FPERE, LIW, NOFFW, NPVW
+      INTEGER(8) :: LA
+      COMPLEX A( LA )
+      REAL UU, SEUIL
+      TYPE (CAGMG_MUMPS_ROOT_STRUC) :: root
+      INTEGER COMM, MYID, LBUFR, LBUFR_BYTES
+      INTEGER LPTRAR, NELT
+      INTEGER(8) :: POSFAC, IPTRLU, LRLU, LRLUS
+      INTEGER NBFIN, IFLAG, IERROR, LEAF, LPOOL, SLAVEF,                &
+     &        IWPOS, IWPOSCB, COMP
+      INTEGER NB_BLOC_FAC
+      INTEGER ICNTL(40), KEEP(500)
+      INTEGER*8 KEEP8(150)
+      INTEGER, TARGET :: IW( LIW )
+      INTEGER FRTPTR( N+1 ), FRTELT( NELT )
+      INTEGER BUFR( LBUFR ), IPOOL(LPOOL), ITLOC(N)
+      INTEGER PTRARW(LPTRAR), PTRAIW(LPTRAR), ND( KEEP(28) )
+      INTEGER FRERE(KEEP(28)), FILS(N)
+      INTEGER INTARR(max(1,KEEP(14)))
+      INTEGER(8) :: PTRAST(KEEP(28))
+      INTEGER(8) :: PTRFAC(KEEP(28))
+      INTEGER(8) :: PAMASTER(KEEP(28))
+      INTEGER PTRIST(KEEP(28)),                                         &
+     & PTLUST_S(KEEP(28)),                                              &
+     & PIMASTER(KEEP(28)),                                              &
+     &        NSTK_S(KEEP(28)), NBPROCFILS(KEEP(28)),                   &
+     &        PROCNODE_STEPS(KEEP(28)), STEP(N)
+      INTEGER ISTEP_TO_INIV2(KEEP(71)),                                 &
+     &        TAB_POS_IN_PERE(SLAVEF+2,max(1,KEEP(56)))
+      DOUBLE PRECISION OPASSW, OPELIW
+      COMPLEX  DBLARR(max(1,KEEP(13)))
+      LOGICAL AVOID_DELAYED
+      INTEGER LPN_LIST
+      INTEGER PIVNUL_LIST(LPN_LIST)
+      REAL DKEEP(30)
+      END SUBROUTINE CAGMG_MUMPS_141
+      END INTERFACE CAGMG_MUMPS_140_141__
        ASS_IRECV = AGMG_MPF_REQUEST_NULL
        ITLOC(1:N) =0
        PTRIST  (1:KEEP(28))=0
diff -Naur SRC.orig/dagmg_mumps.f90 SRC/dagmg_mumps.f90
--- SRC.orig/dagmg_mumps.f90	2012-09-19 16:04:43.925758460 +0200
+++ SRC/dagmg_mumps.f90	2012-09-19 16:05:02.159474372 +0200
@@ -46195,6 +46195,107 @@
       INTEGER NTOTPV, NTOTPVTOT, NMAXNPIV
       INTEGER(8) :: POSFAC, LRLU, IPTRLU, LRLUS
       INTEGER IWPOS, LEAF, NBROOT, NROOT
+      INTERFACE DAGMG_MUMPS_251__
+      SUBROUTINE DAGMG_MUMPS_251(N,IW,LIW,A,LA,                              &
+     &             NSTK_STEPS, NBPROCFILS,IFLAG,ND,FILS,STEP,           &
+     &             FRERE, DAD, CAND,                                    &
+     &             ISTEP_TO_INIV2, TAB_POS_IN_PERE,                     &
+     &             MAXFRT, NTOTPV, NMAXNPIV, PTRIST, PTRAST,            &
+     &             PIMASTER, PAMASTER, PTRARW,PTRAIW,                   &
+     &             ITLOC, IERROR,IPOOL, LPOOL,                          &
+     &             RINFO, POSFAC ,IWPOS, LRLU, IPTRLU,                  &
+     &             LRLUS, LEAF, NBROOT, NBRTOT,                         &
+     &             UU, ICNTL, PTLUST_S, PTRFAC, NSTEPS, INFO,           &
+     &             KEEP,KEEP8,                                          &
+     &             PROCNODE_STEPS,SLAVEF,MYID, COMM_NODES,              &
+     &             MYID_NODES,                                          &
+     &             BUFR,LBUFR,LBUFR_BYTES,INTARR,DBLARR,root,           &
+     &             PERM, NELT, FRTPTR, FRTELT, LPTRAR,                  &
+     &             COMM_LOAD, ASS_IRECV, SEUIL, SEUIL_LDLT_NIV2,        &
+     &             MEM_DISTRIB, NE,                                     &
+     &     DKEEP,PIVNUL_LIST,LPN_LIST)
+      USE DAGMG_MUMPS_LOAD
+      USE DAGMG_MUMPS_OOC
+      IMPLICIT NONE
+!
+      TYPE DAGMG_MUMPS_ROOT_STRUC
+        SEQUENCE
+        INTEGER MBLOCK, NBLOCK, NPROW, NPCOL
+        INTEGER MYROW, MYCOL
+        INTEGER ROOT_SIZE, TOT_ROOT_SIZE
+        INTEGER :: CNTXT_BLACS, truc
+        INTEGER, DIMENSION(:), POINTER :: RG2L_ROW
+        INTEGER, DIMENSION(:), POINTER :: RG2L_COL
+        INTEGER , DIMENSION(:), POINTER :: IPIV
+        INTEGER, DIMENSION( 9 ) :: DESCRIPTOR, DESCB
+        LOGICAL yes, gridinit_done
+        INTEGER LPIV, brol
+!       Used to access Schur easily from root structure
+        DOUBLE PRECISION, DIMENSION(:), POINTER :: SCHUR_POINTER
+        INTEGER SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD, machin
+!
+!      Data for nullspace/QR
+!
+        DOUBLE PRECISION, DIMENSION(:), POINTER :: QR_TAU
+        DOUBLE PRECISION     QR_RCOND
+!
+!      Givens rotations
+!
+        INTEGER MAXG, GIND
+        DOUBLE PRECISION, DIMENSION(:),POINTER::GROW, GCOS, GSIN
+!
+!      RRRLU data
+!
+        INTEGER ELG_MAX,NULL_MAX
+        INTEGER ELIND,EUIND,NLUPDATE,NUUPDATE
+        INTEGER,DIMENSION(:),POINTER::PERM_ROW,PERM_COL
+        INTEGER,DIMENSION(:),POINTER::ELROW, EUROW, PTREL, PTREU
+        DOUBLE PRECISION, DIMENSION(:), POINTER :: ELELG, EUELG, DL
+!
+      END TYPE DAGMG_MUMPS_ROOT_STRUC
+      TYPE (DAGMG_MUMPS_ROOT_STRUC) :: root
+      INTEGER N,IFLAG,NTOTPV,MAXFRT,LIW, LPTRAR, NMAXNPIV,              &
+     &        IERROR, NSTEPS, INFO(40)
+      INTEGER(8) :: LA
+      DOUBLE PRECISION, TARGET :: A(LA)
+      INTEGER SLAVEF, COMM_NODES, MYID, MYID_NODES
+      INTEGER, DIMENSION(0: SLAVEF - 1) :: MEM_DISTRIB
+      INTEGER KEEP(500), ICNTL(40)
+      INTEGER*8 KEEP8(150)
+      INTEGER LPOOL
+      INTEGER PROCNODE_STEPS(KEEP(28))
+      INTEGER ITLOC(N)
+      INTEGER IW(LIW), NSTK_STEPS(KEEP(28)), NBPROCFILS(KEEP(28))
+      INTEGER PTRARW(LPTRAR), PTRAIW(LPTRAR), ND(KEEP(28))
+      INTEGER FILS(N),PTRIST(KEEP(28))
+      INTEGER STEP(N), FRERE(KEEP(28)), DAD(KEEP(28))
+      INTEGER PIMASTER(KEEP(28))
+      INTEGER PTLUST_S(KEEP(28)), PERM(N)
+      INTEGER CAND(SLAVEF+1,max(1,KEEP(56)))
+      INTEGER   ISTEP_TO_INIV2(KEEP(71)),                               &
+     &          TAB_POS_IN_PERE(SLAVEF+2,max(1,KEEP(56)))
+      INTEGER IPOOL(LPOOL)
+      INTEGER NE(KEEP(28))
+      DOUBLE PRECISION RINFO(20)
+      INTEGER(8) :: PAMASTER(KEEP(28)), PTRAST(KEEP(28))
+      INTEGER(8) :: PTRFAC(KEEP(28))
+      INTEGER(8) :: POSFAC, LRLU, LRLUS, IPTRLU
+      INTEGER IWPOS, LEAF, NBROOT
+      INTEGER COMM_LOAD, ASS_IRECV
+      DOUBLE PRECISION UU, SEUIL, SEUIL_LDLT_NIV2
+      INTEGER NELT
+      INTEGER FRTPTR( N+1 ), FRTELT( NELT )
+      INTEGER LBUFR, LBUFR_BYTES
+      INTEGER BUFR( LBUFR )
+      INTEGER        INTARR( max(1,KEEP(14)) )
+      DOUBLE PRECISION DBLARR( max(1,KEEP(13)) )
+      LOGICAL IS_ISOLATED_NODE
+      INTEGER LPN_LIST
+      INTEGER PIVNUL_LIST(LPN_LIST)
+      DOUBLE PRECISION DKEEP(30)
+      INTEGER NBFIN, NBRTOT, NBROOT_TRAITEES
+      END SUBROUTINE DAGMG_MUMPS_251
+      END INTERFACE DAGMG_MUMPS_251__
       KEEP(41)=0
       KEEP(42)=0
       NSTEPS   = 0
@@ -63556,6 +63657,190 @@
      &     NFSIZPTR,                                                    &
      &     FILSPTR,                                                     &
      &     FREREPTR
+      INTERFACE DAGMG_MUMPS_746__
+      SUBROUTINE DAGMG_MUMPS_746( ID, PTRAR )
+      USE DAGMG_MUMPS_STRUC_DEF
+      IMPLICIT NONE
+!
+      INTEGER AGMG_MPF_2DOUBLE_PRECISION
+      INTEGER AGMG_MPF_2INTEGER
+      INTEGER AGMG_MPF_2REAL
+      INTEGER AGMG_MPF_ANY_SOURCE
+      INTEGER AGMG_MPF_ANY_TAG
+      INTEGER AGMG_MPF_BYTE
+      INTEGER AGMG_MPF_CHARACTER
+      INTEGER AGMG_MPF_COMM_NULL
+      INTEGER AGMG_MPF_COMM_WORLD
+      INTEGER AGMG_MPF_COMPLEX
+      INTEGER AGMG_MPF_DOUBLE_COMPLEX
+      INTEGER AGMG_MPF_DOUBLE_PRECISION
+      INTEGER AGMG_MPF_INTEGER
+      INTEGER AGMG_MPF_LOGICAL
+      INTEGER AGMG_MPF_MAX
+      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
+      INTEGER AGMG_MPF_MAXLOC
+      INTEGER AGMG_MPF_MIN
+      INTEGER AGMG_MPF_MINLOC
+      INTEGER AGMG_MPF_PACKED
+      INTEGER AGMG_MPF_PROD
+      INTEGER AGMG_MPF_REAL
+      INTEGER AGMG_MPF_REPLACE
+      INTEGER AGMG_MPF_REQUEST_NULL
+      INTEGER AGMG_MPF_SOURCE
+      INTEGER AGMG_MPF_STATUS_SIZE
+      INTEGER AGMG_MPF_SUM
+      INTEGER AGMG_MPF_TAG
+      INTEGER AGMG_MPF_UNDEFINED
+      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
+      INTEGER AGMG_MPF_LOR
+      INTEGER AGMG_MPF_LAND
+      INTEGER AGMG_MPF_INTEGER8
+      INTEGER AGMG_MPF_REAL8
+      INTEGER AGMG_MPF_BSEND_OVERHEAD
+      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
+      PARAMETER (AGMG_MPF_2INTEGER=2)
+      PARAMETER (AGMG_MPF_2REAL=3)
+      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
+      PARAMETER (AGMG_MPF_ANY_TAG=5)
+      PARAMETER (AGMG_MPF_BYTE=6)
+      PARAMETER (AGMG_MPF_CHARACTER=7)
+      PARAMETER (AGMG_MPF_COMM_NULL=8)
+      PARAMETER (AGMG_MPF_COMM_WORLD=9)
+      PARAMETER (AGMG_MPF_COMPLEX=10)
+      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
+      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
+      PARAMETER (AGMG_MPF_INTEGER=13)
+      PARAMETER (AGMG_MPF_LOGICAL=14)
+      PARAMETER (AGMG_MPF_MAX=15)
+      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
+      PARAMETER (AGMG_MPF_MAXLOC=16)
+      PARAMETER (AGMG_MPF_MIN=17)
+      PARAMETER (AGMG_MPF_MINLOC=18)
+      PARAMETER (AGMG_MPF_PACKED=19)
+      PARAMETER (AGMG_MPF_PROD=20)
+      PARAMETER (AGMG_MPF_REAL=21)
+      PARAMETER (AGMG_MPF_REPLACE=22)
+      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
+      PARAMETER (AGMG_MPF_SOURCE=1)
+      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
+      PARAMETER (AGMG_MPF_SUM=26)
+      PARAMETER (AGMG_MPF_TAG=2)
+      PARAMETER (AGMG_MPF_UNDEFINED=28)
+      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
+      PARAMETER (AGMG_MPF_LOR=31)
+      PARAMETER (AGMG_MPF_LAND=32)
+      PARAMETER (AGMG_MPF_INTEGER8=33)
+      PARAMETER (AGMG_MPF_REAL8=34)
+      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
+      DOUBLE PRECISION AGMG_MPF_WTIME
+      EXTERNAL AGMG_MPF_WTIME
+      INTERFACE AGMG_COPY
+      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      INTEGER :: S(*),R(*)
+      END SUBROUTINE AGMG_COPY_INTEGER
+      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      INTEGER :: S,R(N)
+      END SUBROUTINE AGMG_COPY_INTEGER1
+      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      INTEGER :: S,R
+      END SUBROUTINE AGMG_COPY_INTEGER11
+      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      INTEGER(8) :: S
+      INTEGER:: R
+      END SUBROUTINE AGMG_COPY_INTEGER1_81
+      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      INTEGER :: S(N),R
+      END SUBROUTINE AGMG_COPY_INTEGER10
+      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N(*), DATATYPE, IERR
+      INTEGER :: S(N(1),1),R(N(1))
+      END SUBROUTINE AGMG_COPY_INTEGER21
+      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      REAL :: S(*),R(*)
+      END SUBROUTINE AGMG_COPY_REAL
+      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      REAL :: S,R(N)
+      END SUBROUTINE AGMG_COPY_REAL1
+      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      REAL :: S,R
+      END SUBROUTINE AGMG_COPY_REAL11
+      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      REAL :: S(N),R
+      END SUBROUTINE AGMG_COPY_REAL10
+      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      DOUBLE PRECISION :: S(*),R(*)
+      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
+      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      DOUBLE PRECISION :: S,R(N)
+      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
+      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      DOUBLE PRECISION :: S,R
+      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
+      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      DOUBLE PRECISION :: S(N),R
+      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
+      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      COMPLEX :: S(*),R(*)
+      END SUBROUTINE AGMG_COPY_COMPLEX
+      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      COMPLEX :: S,R(N)
+      END SUBROUTINE AGMG_COPY_COMPLEX1
+      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      COMPLEX :: S,R
+      END SUBROUTINE AGMG_COPY_COMPLEX11
+      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      DOUBLE COMPLEX :: S(*),R(*)
+      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
+      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      DOUBLE COMPLEX :: S,R(N)
+      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
+      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      DOUBLE COMPLEX :: S,R
+      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
+      END INTERFACE
+      TYPE(DAGMG_MUMPS_STRUC), INTENT(IN), TARGET :: ID
+      INTEGER, TARGET          :: PTRAR(ID%N,2)
+      END SUBROUTINE DAGMG_MUMPS_746
+      END INTERFACE DAGMG_MUMPS_746__
       IS_REORDERTREE_CALLED=.FALSE.
       KEEP   => id%KEEP
       KEEP8  => id%KEEP8
@@ -66572,6 +66857,119 @@
          PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
      &             S_ROOTBAND_INIT=0)
       DOUBLE PRECISION    OPASSW, OPELIW
+      INTERFACE DAGMG_MUMPS_140_141__
+      SUBROUTINE DAGMG_MUMPS_140( N, INODE, IW, LIW, A, LA,                  &
+     &                           IOLDPS, POSELT, IFLAG,                 &
+     &                           UU, NNEG, NPVW,                        &
+     &                           KEEP,KEEP8,                            &
+     &                           MYID, SEUIL, AVOID_DELAYED, ETATASS,   &
+     &     DKEEP,PIVNUL_LIST,LPN_LIST, IWPOS )
+      USE DAGMG_MUMPS_OOC
+      IMPLICIT NONE
+      INTEGER(8) :: LA, POSELT
+      INTEGER N, INODE, LIW, IFLAG, NNEG, NPVW
+      INTEGER MYID, SLAVEF, IOLDPS
+      INTEGER KEEP( 500 )
+      INTEGER*8 KEEP8(150)
+      DOUBLE PRECISION UU, SEUIL
+      DOUBLE PRECISION A( LA )
+      INTEGER, TARGET :: IW( LIW )
+      LOGICAL AVOID_DELAYED
+      INTEGER ETATASS, IWPOS
+      INTEGER LPN_LIST
+      INTEGER PIVNUL_LIST(LPN_LIST)
+      DOUBLE PRECISION DKEEP(30)
+      END SUBROUTINE DAGMG_MUMPS_140
+      SUBROUTINE DAGMG_MUMPS_141( COMM_LOAD, ASS_IRECV,                      &
+     &           N, INODE, FPERE, IW, LIW, A, LA,                       &
+     &           UU, NOFFW,                                             &
+     &           NPVW,                                                  &
+     &             COMM, MYID, BUFR, LBUFR,LBUFR_BYTES,NBFIN,LEAF,      &
+     &             IFLAG, IERROR, IPOOL,LPOOL,                          &
+     &             SLAVEF, POSFAC, IWPOS, IWPOSCB, IPTRLU, LRLU,        &
+     &             LRLUS, COMP,                                         &
+     &             PTRIST, PTRAST, PTLUST_S, PTRFAC, STEP,              &
+     &             PIMASTER, PAMASTER,                                  &
+     &             NSTK_S,NBPROCFILS,PROCNODE_STEPS, root,              &
+     &             OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,         &
+     &             INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND, FRERE,        &
+     &             LPTRAR, NELT, FRTPTR, FRTELT, SEUIL,                 &
+     &             ISTEP_TO_INIV2, TAB_POS_IN_PERE, AVOID_DELAYED,      &
+     &            DKEEP,PIVNUL_LIST,LPN_LIST )
+!
+      TYPE DAGMG_MUMPS_ROOT_STRUC
+        SEQUENCE
+        INTEGER MBLOCK, NBLOCK, NPROW, NPCOL
+        INTEGER MYROW, MYCOL
+        INTEGER ROOT_SIZE, TOT_ROOT_SIZE
+        INTEGER :: CNTXT_BLACS, truc
+        INTEGER, DIMENSION(:), POINTER :: RG2L_ROW
+        INTEGER, DIMENSION(:), POINTER :: RG2L_COL
+        INTEGER , DIMENSION(:), POINTER :: IPIV
+        INTEGER, DIMENSION( 9 ) :: DESCRIPTOR, DESCB
+        LOGICAL yes, gridinit_done
+        INTEGER LPIV, brol
+!       Used to access Schur easily from root structure
+        DOUBLE PRECISION, DIMENSION(:), POINTER :: SCHUR_POINTER
+        INTEGER SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD, machin
+!
+!      Data for nullspace/QR
+!
+        DOUBLE PRECISION, DIMENSION(:), POINTER :: QR_TAU
+        DOUBLE PRECISION     QR_RCOND
+!
+!      Givens rotations
+!
+        INTEGER MAXG, GIND
+        DOUBLE PRECISION, DIMENSION(:),POINTER::GROW, GCOS, GSIN
+!
+!      RRRLU data
+!
+        INTEGER ELG_MAX,NULL_MAX
+        INTEGER ELIND,EUIND,NLUPDATE,NUUPDATE
+        INTEGER,DIMENSION(:),POINTER::PERM_ROW,PERM_COL
+        INTEGER,DIMENSION(:),POINTER::ELROW, EUROW, PTREL, PTREU
+        DOUBLE PRECISION, DIMENSION(:), POINTER :: ELELG, EUELG, DL
+!
+      END TYPE DAGMG_MUMPS_ROOT_STRUC
+      INTEGER COMM_LOAD, ASS_IRECV
+      INTEGER N, INODE, FPERE, LIW, NOFFW, NPVW
+      INTEGER(8) :: LA
+      DOUBLE PRECISION A( LA )
+      DOUBLE PRECISION UU, SEUIL
+      TYPE (DAGMG_MUMPS_ROOT_STRUC) :: root
+      INTEGER COMM, MYID, LBUFR, LBUFR_BYTES
+      INTEGER LPTRAR, NELT
+      INTEGER(8) :: POSFAC, IPTRLU, LRLU, LRLUS
+      INTEGER NBFIN, IFLAG, IERROR, LEAF, LPOOL, SLAVEF,                &
+     &        IWPOS, IWPOSCB, COMP
+      INTEGER NB_BLOC_FAC
+      INTEGER ICNTL(40), KEEP(500)
+      INTEGER*8 KEEP8(150)
+      INTEGER, TARGET :: IW( LIW )
+      INTEGER FRTPTR( N+1 ), FRTELT( NELT )
+      INTEGER BUFR( LBUFR ), IPOOL(LPOOL), ITLOC(N)
+      INTEGER PTRARW(LPTRAR), PTRAIW(LPTRAR), ND( KEEP(28) )
+      INTEGER FRERE(KEEP(28)), FILS(N)
+      INTEGER INTARR(max(1,KEEP(14)))
+      INTEGER(8) :: PTRAST(KEEP(28))
+      INTEGER(8) :: PTRFAC(KEEP(28))
+      INTEGER(8) :: PAMASTER(KEEP(28))
+      INTEGER PTRIST(KEEP(28)),                                         &
+     & PTLUST_S(KEEP(28)),                                              &
+     & PIMASTER(KEEP(28)),                                              &
+     &        NSTK_S(KEEP(28)), NBPROCFILS(KEEP(28)),                   &
+     &        PROCNODE_STEPS(KEEP(28)), STEP(N)
+      INTEGER ISTEP_TO_INIV2(KEEP(71)),                                 &
+     &        TAB_POS_IN_PERE(SLAVEF+2,max(1,KEEP(56)))
+      DOUBLE PRECISION OPASSW, OPELIW
+      DOUBLE PRECISION  DBLARR(max(1,KEEP(13)))
+      LOGICAL AVOID_DELAYED
+      INTEGER LPN_LIST
+      INTEGER PIVNUL_LIST(LPN_LIST)
+      DOUBLE PRECISION DKEEP(30)
+      END SUBROUTINE DAGMG_MUMPS_141
+      END INTERFACE DAGMG_MUMPS_140_141__
        ASS_IRECV = AGMG_MPF_REQUEST_NULL
        ITLOC(1:N) =0
        PTRIST  (1:KEEP(28))=0
diff -Naur SRC.orig/sagmg_mumps.f90 SRC/sagmg_mumps.f90
--- SRC.orig/sagmg_mumps.f90	2012-09-19 16:04:44.625652029 +0200
+++ SRC/sagmg_mumps.f90	2012-09-19 16:05:02.879613270 +0200
@@ -46195,6 +46195,107 @@
       INTEGER NTOTPV, NTOTPVTOT, NMAXNPIV
       INTEGER(8) :: POSFAC, LRLU, IPTRLU, LRLUS
       INTEGER IWPOS, LEAF, NBROOT, NROOT
+      INTERFACE SAGMG_MUMPS_251__
+      SUBROUTINE SAGMG_MUMPS_251(N,IW,LIW,A,LA,                              &
+     &             NSTK_STEPS, NBPROCFILS,IFLAG,ND,FILS,STEP,           &
+     &             FRERE, DAD, CAND,                                    &
+     &             ISTEP_TO_INIV2, TAB_POS_IN_PERE,                     &
+     &             MAXFRT, NTOTPV, NMAXNPIV, PTRIST, PTRAST,            &
+     &             PIMASTER, PAMASTER, PTRARW,PTRAIW,                   &
+     &             ITLOC, IERROR,IPOOL, LPOOL,                          &
+     &             RINFO, POSFAC ,IWPOS, LRLU, IPTRLU,                  &
+     &             LRLUS, LEAF, NBROOT, NBRTOT,                         &
+     &             UU, ICNTL, PTLUST_S, PTRFAC, NSTEPS, INFO,           &
+     &             KEEP,KEEP8,                                          &
+     &             PROCNODE_STEPS,SLAVEF,MYID, COMM_NODES,              &
+     &             MYID_NODES,                                          &
+     &             BUFR,LBUFR,LBUFR_BYTES,INTARR,DBLARR,root,           &
+     &             PERM, NELT, FRTPTR, FRTELT, LPTRAR,                  &
+     &             COMM_LOAD, ASS_IRECV, SEUIL, SEUIL_LDLT_NIV2,        &
+     &             MEM_DISTRIB, NE,                                     &
+     &     DKEEP,PIVNUL_LIST,LPN_LIST)
+      USE SAGMG_MUMPS_LOAD
+      USE SAGMG_MUMPS_OOC
+      IMPLICIT NONE
+!
+      TYPE SAGMG_MUMPS_ROOT_STRUC
+        SEQUENCE
+        INTEGER MBLOCK, NBLOCK, NPROW, NPCOL
+        INTEGER MYROW, MYCOL
+        INTEGER ROOT_SIZE, TOT_ROOT_SIZE
+        INTEGER :: CNTXT_BLACS, truc
+        INTEGER, DIMENSION(:), POINTER :: RG2L_ROW
+        INTEGER, DIMENSION(:), POINTER :: RG2L_COL
+        INTEGER , DIMENSION(:), POINTER :: IPIV
+        INTEGER, DIMENSION( 9 ) :: DESCRIPTOR, DESCB
+        LOGICAL yes, gridinit_done
+        INTEGER LPIV, brol
+!       Used to access Schur easily from root structure
+        REAL, DIMENSION(:), POINTER :: SCHUR_POINTER
+        INTEGER SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD, machin
+!
+!      Data for nullspace/QR
+!
+        REAL, DIMENSION(:), POINTER :: QR_TAU
+        REAL     QR_RCOND, bazar
+!
+!      Givens rotations
+!
+        INTEGER MAXG, GIND
+        REAL, DIMENSION(:),POINTER::GROW, GCOS, GSIN
+!
+!      RRRLU data
+!
+        INTEGER ELG_MAX,NULL_MAX
+        INTEGER ELIND,EUIND,NLUPDATE,NUUPDATE
+        INTEGER,DIMENSION(:),POINTER::PERM_ROW,PERM_COL
+        INTEGER,DIMENSION(:),POINTER::ELROW, EUROW, PTREL, PTREU
+        REAL, DIMENSION(:), POINTER :: ELELG, EUELG, DL
+!
+      END TYPE SAGMG_MUMPS_ROOT_STRUC
+      TYPE (SAGMG_MUMPS_ROOT_STRUC) :: root
+      INTEGER N,IFLAG,NTOTPV,MAXFRT,LIW, LPTRAR, NMAXNPIV,              &
+     &        IERROR, NSTEPS, INFO(40)
+      INTEGER(8) :: LA
+      REAL, TARGET :: A(LA)
+      INTEGER SLAVEF, COMM_NODES, MYID, MYID_NODES
+      INTEGER, DIMENSION(0: SLAVEF - 1) :: MEM_DISTRIB
+      INTEGER KEEP(500), ICNTL(40)
+      INTEGER*8 KEEP8(150)
+      INTEGER LPOOL
+      INTEGER PROCNODE_STEPS(KEEP(28))
+      INTEGER ITLOC(N)
+      INTEGER IW(LIW), NSTK_STEPS(KEEP(28)), NBPROCFILS(KEEP(28))
+      INTEGER PTRARW(LPTRAR), PTRAIW(LPTRAR), ND(KEEP(28))
+      INTEGER FILS(N),PTRIST(KEEP(28))
+      INTEGER STEP(N), FRERE(KEEP(28)), DAD(KEEP(28))
+      INTEGER PIMASTER(KEEP(28))
+      INTEGER PTLUST_S(KEEP(28)), PERM(N)
+      INTEGER CAND(SLAVEF+1,max(1,KEEP(56)))
+      INTEGER   ISTEP_TO_INIV2(KEEP(71)),                               &
+     &          TAB_POS_IN_PERE(SLAVEF+2,max(1,KEEP(56)))
+      INTEGER IPOOL(LPOOL)
+      INTEGER NE(KEEP(28))
+      REAL RINFO(20)
+      INTEGER(8) :: PAMASTER(KEEP(28)), PTRAST(KEEP(28))
+      INTEGER(8) :: PTRFAC(KEEP(28))
+      INTEGER(8) :: POSFAC, LRLU, LRLUS, IPTRLU
+      INTEGER IWPOS, LEAF, NBROOT
+      INTEGER COMM_LOAD, ASS_IRECV
+      REAL UU, SEUIL, SEUIL_LDLT_NIV2
+      INTEGER NELT
+      INTEGER FRTPTR( N+1 ), FRTELT( NELT )
+      INTEGER LBUFR, LBUFR_BYTES
+      INTEGER BUFR( LBUFR )
+      INTEGER        INTARR( max(1,KEEP(14)) )
+      REAL DBLARR( max(1,KEEP(13)) )
+      LOGICAL IS_ISOLATED_NODE
+      INTEGER LPN_LIST
+      INTEGER PIVNUL_LIST(LPN_LIST)
+      REAL DKEEP(30)
+      INTEGER NBFIN, NBRTOT, NBROOT_TRAITEES
+      END SUBROUTINE SAGMG_MUMPS_251
+      END INTERFACE SAGMG_MUMPS_251__
       KEEP(41)=0
       KEEP(42)=0
       NSTEPS   = 0
@@ -63556,6 +63657,190 @@
      &     NFSIZPTR,                                                    &
      &     FILSPTR,                                                     &
      &     FREREPTR
+      INTERFACE SAGMG_MUMPS_746__
+      SUBROUTINE SAGMG_MUMPS_746( ID, PTRAR )
+      USE SAGMG_MUMPS_STRUC_DEF
+      IMPLICIT NONE
+!
+      INTEGER AGMG_MPF_2DOUBLE_PRECISION
+      INTEGER AGMG_MPF_2INTEGER
+      INTEGER AGMG_MPF_2REAL
+      INTEGER AGMG_MPF_ANY_SOURCE
+      INTEGER AGMG_MPF_ANY_TAG
+      INTEGER AGMG_MPF_BYTE
+      INTEGER AGMG_MPF_CHARACTER
+      INTEGER AGMG_MPF_COMM_NULL
+      INTEGER AGMG_MPF_COMM_WORLD
+      INTEGER AGMG_MPF_COMPLEX
+      INTEGER AGMG_MPF_DOUBLE_COMPLEX
+      INTEGER AGMG_MPF_DOUBLE_PRECISION
+      INTEGER AGMG_MPF_INTEGER
+      INTEGER AGMG_MPF_LOGICAL
+      INTEGER AGMG_MPF_MAX
+      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
+      INTEGER AGMG_MPF_MAXLOC
+      INTEGER AGMG_MPF_MIN
+      INTEGER AGMG_MPF_MINLOC
+      INTEGER AGMG_MPF_PACKED
+      INTEGER AGMG_MPF_PROD
+      INTEGER AGMG_MPF_REAL
+      INTEGER AGMG_MPF_REPLACE
+      INTEGER AGMG_MPF_REQUEST_NULL
+      INTEGER AGMG_MPF_SOURCE
+      INTEGER AGMG_MPF_STATUS_SIZE
+      INTEGER AGMG_MPF_SUM
+      INTEGER AGMG_MPF_TAG
+      INTEGER AGMG_MPF_UNDEFINED
+      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
+      INTEGER AGMG_MPF_LOR
+      INTEGER AGMG_MPF_LAND
+      INTEGER AGMG_MPF_INTEGER8
+      INTEGER AGMG_MPF_REAL8
+      INTEGER AGMG_MPF_BSEND_OVERHEAD
+      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
+      PARAMETER (AGMG_MPF_2INTEGER=2)
+      PARAMETER (AGMG_MPF_2REAL=3)
+      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
+      PARAMETER (AGMG_MPF_ANY_TAG=5)
+      PARAMETER (AGMG_MPF_BYTE=6)
+      PARAMETER (AGMG_MPF_CHARACTER=7)
+      PARAMETER (AGMG_MPF_COMM_NULL=8)
+      PARAMETER (AGMG_MPF_COMM_WORLD=9)
+      PARAMETER (AGMG_MPF_COMPLEX=10)
+      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
+      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
+      PARAMETER (AGMG_MPF_INTEGER=13)
+      PARAMETER (AGMG_MPF_LOGICAL=14)
+      PARAMETER (AGMG_MPF_MAX=15)
+      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
+      PARAMETER (AGMG_MPF_MAXLOC=16)
+      PARAMETER (AGMG_MPF_MIN=17)
+      PARAMETER (AGMG_MPF_MINLOC=18)
+      PARAMETER (AGMG_MPF_PACKED=19)
+      PARAMETER (AGMG_MPF_PROD=20)
+      PARAMETER (AGMG_MPF_REAL=21)
+      PARAMETER (AGMG_MPF_REPLACE=22)
+      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
+      PARAMETER (AGMG_MPF_SOURCE=1)
+      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
+      PARAMETER (AGMG_MPF_SUM=26)
+      PARAMETER (AGMG_MPF_TAG=2)
+      PARAMETER (AGMG_MPF_UNDEFINED=28)
+      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
+      PARAMETER (AGMG_MPF_LOR=31)
+      PARAMETER (AGMG_MPF_LAND=32)
+      PARAMETER (AGMG_MPF_INTEGER8=33)
+      PARAMETER (AGMG_MPF_REAL8=34)
+      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
+      DOUBLE PRECISION AGMG_MPF_WTIME
+      EXTERNAL AGMG_MPF_WTIME
+      INTERFACE AGMG_COPY
+      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      INTEGER :: S(*),R(*)
+      END SUBROUTINE AGMG_COPY_INTEGER
+      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      INTEGER :: S,R(N)
+      END SUBROUTINE AGMG_COPY_INTEGER1
+      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      INTEGER :: S,R
+      END SUBROUTINE AGMG_COPY_INTEGER11
+      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      INTEGER(8) :: S
+      INTEGER:: R
+      END SUBROUTINE AGMG_COPY_INTEGER1_81
+      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      INTEGER :: S(N),R
+      END SUBROUTINE AGMG_COPY_INTEGER10
+      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N(*), DATATYPE, IERR
+      INTEGER :: S(N(1),1),R(N(1))
+      END SUBROUTINE AGMG_COPY_INTEGER21
+      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      REAL :: S(*),R(*)
+      END SUBROUTINE AGMG_COPY_REAL
+      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      REAL :: S,R(N)
+      END SUBROUTINE AGMG_COPY_REAL1
+      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      REAL :: S,R
+      END SUBROUTINE AGMG_COPY_REAL11
+      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      REAL :: S(N),R
+      END SUBROUTINE AGMG_COPY_REAL10
+      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      DOUBLE PRECISION :: S(*),R(*)
+      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
+      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      DOUBLE PRECISION :: S,R(N)
+      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
+      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      DOUBLE PRECISION :: S,R
+      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
+      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      DOUBLE PRECISION :: S(N),R
+      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
+      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      COMPLEX :: S(*),R(*)
+      END SUBROUTINE AGMG_COPY_COMPLEX
+      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      COMPLEX :: S,R(N)
+      END SUBROUTINE AGMG_COPY_COMPLEX1
+      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      COMPLEX :: S,R
+      END SUBROUTINE AGMG_COPY_COMPLEX11
+      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      DOUBLE COMPLEX :: S(*),R(*)
+      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
+      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      DOUBLE COMPLEX :: S,R(N)
+      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
+      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      DOUBLE COMPLEX :: S,R
+      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
+      END INTERFACE
+      TYPE(SAGMG_MUMPS_STRUC), INTENT(IN), TARGET :: ID
+      INTEGER, TARGET          :: PTRAR(ID%N,2)
+      END SUBROUTINE SAGMG_MUMPS_746
+      END INTERFACE SAGMG_MUMPS_746__
       IS_REORDERTREE_CALLED=.FALSE.
       KEEP   => id%KEEP
       KEEP8  => id%KEEP8
@@ -66572,6 +66857,121 @@
          PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
      &             S_ROOTBAND_INIT=0)
       DOUBLE PRECISION    OPASSW, OPELIW
+      INTERFACE SAGMG_MUMPS_140_141__
+      SUBROUTINE SAGMG_MUMPS_140( N, INODE, IW, LIW, A, LA,                  &
+     &                           IOLDPS, POSELT, IFLAG,                 &
+     &                           UU, NNEG, NPVW,                        &
+     &                           KEEP,KEEP8,                            &
+     &                           MYID, SEUIL, AVOID_DELAYED, ETATASS,   &
+     &     DKEEP,PIVNUL_LIST,LPN_LIST, IWPOS )
+      USE SAGMG_MUMPS_OOC
+      IMPLICIT NONE
+      INTEGER(8) :: LA, POSELT
+      INTEGER N, INODE, LIW, IFLAG, NNEG, NPVW
+      INTEGER MYID, SLAVEF, IOLDPS
+      INTEGER KEEP( 500 )
+      INTEGER*8 KEEP8(150)
+      REAL UU, SEUIL
+      REAL A( LA )
+      INTEGER, TARGET :: IW( LIW )
+      LOGICAL AVOID_DELAYED
+      INTEGER ETATASS, IWPOS
+      INTEGER LPN_LIST
+      INTEGER PIVNUL_LIST(LPN_LIST)
+      REAL DKEEP(30)
+      END SUBROUTINE SAGMG_MUMPS_140
+      SUBROUTINE SAGMG_MUMPS_141( COMM_LOAD, ASS_IRECV,                      &
+     &           N, INODE, FPERE, IW, LIW, A, LA,                       &
+     &           UU, NOFFW,                                             &
+     &           NPVW,                                                  &
+     &             COMM, MYID, BUFR, LBUFR,LBUFR_BYTES,NBFIN,LEAF,      &
+     &             IFLAG, IERROR, IPOOL,LPOOL,                          &
+     &             SLAVEF, POSFAC, IWPOS, IWPOSCB, IPTRLU, LRLU,        &
+     &             LRLUS, COMP,                                         &
+     &             PTRIST, PTRAST, PTLUST_S, PTRFAC, STEP,              &
+     &             PIMASTER, PAMASTER,                                  &
+     &             NSTK_S,NBPROCFILS,PROCNODE_STEPS, root,              &
+     &             OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,         &
+     &             INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND, FRERE,        &
+     &             LPTRAR, NELT, FRTPTR, FRTELT, SEUIL,                 &
+     &             ISTEP_TO_INIV2, TAB_POS_IN_PERE, AVOID_DELAYED,      &
+     &            DKEEP,PIVNUL_LIST,LPN_LIST )
+      USE SAGMG_MUMPS_OOC
+      IMPLICIT NONE
+!
+      TYPE SAGMG_MUMPS_ROOT_STRUC
+        SEQUENCE
+        INTEGER MBLOCK, NBLOCK, NPROW, NPCOL
+        INTEGER MYROW, MYCOL
+        INTEGER ROOT_SIZE, TOT_ROOT_SIZE
+        INTEGER :: CNTXT_BLACS, truc
+        INTEGER, DIMENSION(:), POINTER :: RG2L_ROW
+        INTEGER, DIMENSION(:), POINTER :: RG2L_COL
+        INTEGER , DIMENSION(:), POINTER :: IPIV
+        INTEGER, DIMENSION( 9 ) :: DESCRIPTOR, DESCB
+        LOGICAL yes, gridinit_done
+        INTEGER LPIV, brol
+!       Used to access Schur easily from root structure
+        REAL, DIMENSION(:), POINTER :: SCHUR_POINTER
+        INTEGER SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD, machin
+!
+!      Data for nullspace/QR
+!
+        REAL, DIMENSION(:), POINTER :: QR_TAU
+        REAL     QR_RCOND, bazar
+!
+!      Givens rotations
+!
+        INTEGER MAXG, GIND
+        REAL, DIMENSION(:),POINTER::GROW, GCOS, GSIN
+!
+!      RRRLU data
+!
+        INTEGER ELG_MAX,NULL_MAX
+        INTEGER ELIND,EUIND,NLUPDATE,NUUPDATE
+        INTEGER,DIMENSION(:),POINTER::PERM_ROW,PERM_COL
+        INTEGER,DIMENSION(:),POINTER::ELROW, EUROW, PTREL, PTREU
+        REAL, DIMENSION(:), POINTER :: ELELG, EUELG, DL
+!
+      END TYPE SAGMG_MUMPS_ROOT_STRUC
+      INTEGER COMM_LOAD, ASS_IRECV
+      INTEGER N, INODE, FPERE, LIW, NOFFW, NPVW
+      INTEGER(8) :: LA
+      REAL A( LA )
+      REAL UU, SEUIL
+      TYPE (SAGMG_MUMPS_ROOT_STRUC) :: root
+      INTEGER COMM, MYID, LBUFR, LBUFR_BYTES
+      INTEGER LPTRAR, NELT
+      INTEGER(8) :: POSFAC, IPTRLU, LRLU, LRLUS
+      INTEGER NBFIN, IFLAG, IERROR, LEAF, LPOOL, SLAVEF,                &
+     &        IWPOS, IWPOSCB, COMP
+      INTEGER NB_BLOC_FAC
+      INTEGER ICNTL(40), KEEP(500)
+      INTEGER*8 KEEP8(150)
+      INTEGER, TARGET :: IW( LIW )
+      INTEGER FRTPTR( N+1 ), FRTELT( NELT )
+      INTEGER BUFR( LBUFR ), IPOOL(LPOOL), ITLOC(N)
+      INTEGER PTRARW(LPTRAR), PTRAIW(LPTRAR), ND( KEEP(28) )
+      INTEGER FRERE(KEEP(28)), FILS(N)
+      INTEGER INTARR(max(1,KEEP(14)))
+      INTEGER(8) :: PTRAST(KEEP(28))
+      INTEGER(8) :: PTRFAC(KEEP(28))
+      INTEGER(8) :: PAMASTER(KEEP(28))
+      INTEGER PTRIST(KEEP(28)),                                         &
+     & PTLUST_S(KEEP(28)),                                              &
+     & PIMASTER(KEEP(28)),                                              &
+     &        NSTK_S(KEEP(28)), NBPROCFILS(KEEP(28)),                   &
+     &        PROCNODE_STEPS(KEEP(28)), STEP(N)
+      INTEGER ISTEP_TO_INIV2(KEEP(71)),                                 &
+     &        TAB_POS_IN_PERE(SLAVEF+2,max(1,KEEP(56)))
+      DOUBLE PRECISION OPASSW, OPELIW
+      REAL  DBLARR(max(1,KEEP(13)))
+      LOGICAL AVOID_DELAYED
+      INTEGER LPN_LIST
+      INTEGER PIVNUL_LIST(LPN_LIST)
+      REAL DKEEP(30)
+      END SUBROUTINE SAGMG_MUMPS_141
+      END INTERFACE SAGMG_MUMPS_140_141__
        ASS_IRECV = AGMG_MPF_REQUEST_NULL
        ITLOC(1:N) =0
        PTRIST  (1:KEEP(28))=0
diff -Naur SRC.orig/zagmg_mumps.f90 SRC/zagmg_mumps.f90
--- SRC.orig/zagmg_mumps.f90	2012-09-19 16:04:44.320954237 +0200
+++ SRC/zagmg_mumps.f90	2012-09-19 16:05:03.930068429 +0200
@@ -46199,6 +46199,107 @@
       INTEGER NTOTPV, NTOTPVTOT, NMAXNPIV
       INTEGER(8) :: POSFAC, LRLU, IPTRLU, LRLUS
       INTEGER IWPOS, LEAF, NBROOT, NROOT
+      INTERFACE ZAGMG_MUMPS_251__
+      SUBROUTINE ZAGMG_MUMPS_251(N,IW,LIW,A,LA,                              &
+     &             NSTK_STEPS, NBPROCFILS,IFLAG,ND,FILS,STEP,           &
+     &             FRERE, DAD, CAND,                                    &
+     &             ISTEP_TO_INIV2, TAB_POS_IN_PERE,                     &
+     &             MAXFRT, NTOTPV, NMAXNPIV, PTRIST, PTRAST,            &
+     &             PIMASTER, PAMASTER, PTRARW,PTRAIW,                   &
+     &             ITLOC, IERROR,IPOOL, LPOOL,                          &
+     &             RINFO, POSFAC ,IWPOS, LRLU, IPTRLU,                  &
+     &             LRLUS, LEAF, NBROOT, NBRTOT,                         &
+     &             UU, ICNTL, PTLUST_S, PTRFAC, NSTEPS, INFO,           &
+     &             KEEP,KEEP8,                                          &
+     &             PROCNODE_STEPS,SLAVEF,MYID, COMM_NODES,              &
+     &             MYID_NODES,                                          &
+     &             BUFR,LBUFR,LBUFR_BYTES,INTARR,DBLARR,root,           &
+     &             PERM, NELT, FRTPTR, FRTELT, LPTRAR,                  &
+     &             COMM_LOAD, ASS_IRECV, SEUIL, SEUIL_LDLT_NIV2,        &
+     &             MEM_DISTRIB, NE,                                     &
+     &     DKEEP,PIVNUL_LIST,LPN_LIST)
+      USE ZAGMG_MUMPS_LOAD
+      USE ZAGMG_MUMPS_OOC
+      IMPLICIT NONE
+!
+      TYPE ZAGMG_MUMPS_ROOT_STRUC
+        SEQUENCE
+        INTEGER MBLOCK, NBLOCK, NPROW, NPCOL
+        INTEGER MYROW, MYCOL
+        INTEGER ROOT_SIZE, TOT_ROOT_SIZE
+        INTEGER :: CNTXT_BLACS, truc
+        INTEGER, DIMENSION(:), POINTER :: RG2L_ROW
+        INTEGER, DIMENSION(:), POINTER :: RG2L_COL
+        INTEGER , DIMENSION(:), POINTER :: IPIV
+        INTEGER, DIMENSION( 9 ) :: DESCRIPTOR, DESCB
+        LOGICAL yes, gridinit_done
+        INTEGER LPIV, brol
+!       Used to access Schur easily from root structure
+        COMPLEX*16, DIMENSION(:), POINTER :: SCHUR_POINTER
+        INTEGER SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD, machin
+!
+!      Data for nullspace/QR
+!
+        COMPLEX*16, DIMENSION(:), POINTER :: QR_TAU
+        DOUBLE PRECISION     QR_RCOND
+!
+!      Givens rotations
+!
+        INTEGER MAXG, GIND
+        COMPLEX*16, DIMENSION(:),POINTER::GROW, GCOS, GSIN
+!
+!      RRRLU data
+!
+        INTEGER ELG_MAX,NULL_MAX
+        INTEGER ELIND,EUIND,NLUPDATE,NUUPDATE
+        INTEGER,DIMENSION(:),POINTER::PERM_ROW,PERM_COL
+        INTEGER,DIMENSION(:),POINTER::ELROW, EUROW, PTREL, PTREU
+        COMPLEX*16, DIMENSION(:), POINTER :: ELELG, EUELG, DL
+!
+      END TYPE ZAGMG_MUMPS_ROOT_STRUC
+      TYPE (ZAGMG_MUMPS_ROOT_STRUC) :: root
+      INTEGER N,IFLAG,NTOTPV,MAXFRT,LIW, LPTRAR, NMAXNPIV,              &
+     &        IERROR, NSTEPS, INFO(40)
+      INTEGER(8) :: LA
+      COMPLEX*16, TARGET :: A(LA)
+      INTEGER SLAVEF, COMM_NODES, MYID, MYID_NODES
+      INTEGER, DIMENSION(0: SLAVEF - 1) :: MEM_DISTRIB
+      INTEGER KEEP(500), ICNTL(40)
+      INTEGER*8 KEEP8(150)
+      INTEGER LPOOL
+      INTEGER PROCNODE_STEPS(KEEP(28))
+      INTEGER ITLOC(N)
+      INTEGER IW(LIW), NSTK_STEPS(KEEP(28)), NBPROCFILS(KEEP(28))
+      INTEGER PTRARW(LPTRAR), PTRAIW(LPTRAR), ND(KEEP(28))
+      INTEGER FILS(N),PTRIST(KEEP(28))
+      INTEGER STEP(N), FRERE(KEEP(28)), DAD(KEEP(28))
+      INTEGER PIMASTER(KEEP(28))
+      INTEGER PTLUST_S(KEEP(28)), PERM(N)
+      INTEGER CAND(SLAVEF+1,max(1,KEEP(56)))
+      INTEGER   ISTEP_TO_INIV2(KEEP(71)),                               &
+     &          TAB_POS_IN_PERE(SLAVEF+2,max(1,KEEP(56)))
+      INTEGER IPOOL(LPOOL)
+      INTEGER NE(KEEP(28))
+      DOUBLE PRECISION RINFO(20)
+      INTEGER(8) :: PAMASTER(KEEP(28)), PTRAST(KEEP(28))
+      INTEGER(8) :: PTRFAC(KEEP(28))
+      INTEGER(8) :: POSFAC, LRLU, LRLUS, IPTRLU
+      INTEGER IWPOS, LEAF, NBROOT
+      INTEGER COMM_LOAD, ASS_IRECV
+      DOUBLE PRECISION UU, SEUIL, SEUIL_LDLT_NIV2
+      INTEGER NELT
+      INTEGER FRTPTR( N+1 ), FRTELT( NELT )
+      INTEGER LBUFR, LBUFR_BYTES
+      INTEGER BUFR( LBUFR )
+      INTEGER        INTARR( max(1,KEEP(14)) )
+      COMPLEX*16 DBLARR( max(1,KEEP(13)) )
+      LOGICAL IS_ISOLATED_NODE
+      INTEGER LPN_LIST
+      INTEGER PIVNUL_LIST(LPN_LIST)
+      DOUBLE PRECISION DKEEP(30)
+      INTEGER NBFIN, NBRTOT, NBROOT_TRAITEES
+      END SUBROUTINE ZAGMG_MUMPS_251
+      END INTERFACE ZAGMG_MUMPS_251__
       KEEP(41)=0
       KEEP(42)=0
       NSTEPS   = 0
@@ -63560,6 +63661,190 @@
      &     NFSIZPTR,                                                    &
      &     FILSPTR,                                                     &
      &     FREREPTR
+      INTERFACE ZAGMG_MUMPS_746__
+      SUBROUTINE ZAGMG_MUMPS_746( ID, PTRAR )
+      USE ZAGMG_MUMPS_STRUC_DEF
+      IMPLICIT NONE
+!
+      INTEGER AGMG_MPF_2DOUBLE_PRECISION
+      INTEGER AGMG_MPF_2INTEGER
+      INTEGER AGMG_MPF_2REAL
+      INTEGER AGMG_MPF_ANY_SOURCE
+      INTEGER AGMG_MPF_ANY_TAG
+      INTEGER AGMG_MPF_BYTE
+      INTEGER AGMG_MPF_CHARACTER
+      INTEGER AGMG_MPF_COMM_NULL
+      INTEGER AGMG_MPF_COMM_WORLD
+      INTEGER AGMG_MPF_COMPLEX
+      INTEGER AGMG_MPF_DOUBLE_COMPLEX
+      INTEGER AGMG_MPF_DOUBLE_PRECISION
+      INTEGER AGMG_MPF_INTEGER
+      INTEGER AGMG_MPF_LOGICAL
+      INTEGER AGMG_MPF_MAX
+      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
+      INTEGER AGMG_MPF_MAXLOC
+      INTEGER AGMG_MPF_MIN
+      INTEGER AGMG_MPF_MINLOC
+      INTEGER AGMG_MPF_PACKED
+      INTEGER AGMG_MPF_PROD
+      INTEGER AGMG_MPF_REAL
+      INTEGER AGMG_MPF_REPLACE
+      INTEGER AGMG_MPF_REQUEST_NULL
+      INTEGER AGMG_MPF_SOURCE
+      INTEGER AGMG_MPF_STATUS_SIZE
+      INTEGER AGMG_MPF_SUM
+      INTEGER AGMG_MPF_TAG
+      INTEGER AGMG_MPF_UNDEFINED
+      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
+      INTEGER AGMG_MPF_LOR
+      INTEGER AGMG_MPF_LAND
+      INTEGER AGMG_MPF_INTEGER8
+      INTEGER AGMG_MPF_REAL8
+      INTEGER AGMG_MPF_BSEND_OVERHEAD
+      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
+      PARAMETER (AGMG_MPF_2INTEGER=2)
+      PARAMETER (AGMG_MPF_2REAL=3)
+      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
+      PARAMETER (AGMG_MPF_ANY_TAG=5)
+      PARAMETER (AGMG_MPF_BYTE=6)
+      PARAMETER (AGMG_MPF_CHARACTER=7)
+      PARAMETER (AGMG_MPF_COMM_NULL=8)
+      PARAMETER (AGMG_MPF_COMM_WORLD=9)
+      PARAMETER (AGMG_MPF_COMPLEX=10)
+      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
+      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
+      PARAMETER (AGMG_MPF_INTEGER=13)
+      PARAMETER (AGMG_MPF_LOGICAL=14)
+      PARAMETER (AGMG_MPF_MAX=15)
+      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
+      PARAMETER (AGMG_MPF_MAXLOC=16)
+      PARAMETER (AGMG_MPF_MIN=17)
+      PARAMETER (AGMG_MPF_MINLOC=18)
+      PARAMETER (AGMG_MPF_PACKED=19)
+      PARAMETER (AGMG_MPF_PROD=20)
+      PARAMETER (AGMG_MPF_REAL=21)
+      PARAMETER (AGMG_MPF_REPLACE=22)
+      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
+      PARAMETER (AGMG_MPF_SOURCE=1)
+      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
+      PARAMETER (AGMG_MPF_SUM=26)
+      PARAMETER (AGMG_MPF_TAG=2)
+      PARAMETER (AGMG_MPF_UNDEFINED=28)
+      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
+      PARAMETER (AGMG_MPF_LOR=31)
+      PARAMETER (AGMG_MPF_LAND=32)
+      PARAMETER (AGMG_MPF_INTEGER8=33)
+      PARAMETER (AGMG_MPF_REAL8=34)
+      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
+      DOUBLE PRECISION AGMG_MPF_WTIME
+      EXTERNAL AGMG_MPF_WTIME
+      INTERFACE AGMG_COPY
+      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      INTEGER :: S(*),R(*)
+      END SUBROUTINE AGMG_COPY_INTEGER
+      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      INTEGER :: S,R(N)
+      END SUBROUTINE AGMG_COPY_INTEGER1
+      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      INTEGER :: S,R
+      END SUBROUTINE AGMG_COPY_INTEGER11
+      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      INTEGER(8) :: S
+      INTEGER:: R
+      END SUBROUTINE AGMG_COPY_INTEGER1_81
+      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      INTEGER :: S(N),R
+      END SUBROUTINE AGMG_COPY_INTEGER10
+      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N(*), DATATYPE, IERR
+      INTEGER :: S(N(1),1),R(N(1))
+      END SUBROUTINE AGMG_COPY_INTEGER21
+      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      REAL :: S(*),R(*)
+      END SUBROUTINE AGMG_COPY_REAL
+      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      REAL :: S,R(N)
+      END SUBROUTINE AGMG_COPY_REAL1
+      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      REAL :: S,R
+      END SUBROUTINE AGMG_COPY_REAL11
+      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      REAL :: S(N),R
+      END SUBROUTINE AGMG_COPY_REAL10
+      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      DOUBLE PRECISION :: S(*),R(*)
+      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
+      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      DOUBLE PRECISION :: S,R(N)
+      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
+      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      DOUBLE PRECISION :: S,R
+      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
+      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      DOUBLE PRECISION :: S(N),R
+      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
+      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      COMPLEX :: S(*),R(*)
+      END SUBROUTINE AGMG_COPY_COMPLEX
+      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      COMPLEX :: S,R(N)
+      END SUBROUTINE AGMG_COPY_COMPLEX1
+      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      COMPLEX :: S,R
+      END SUBROUTINE AGMG_COPY_COMPLEX11
+      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      DOUBLE COMPLEX :: S(*),R(*)
+      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
+      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      DOUBLE COMPLEX :: S,R(N)
+      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
+      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
+      IMPLICIT NONE
+      INTEGER :: N, DATATYPE, IERR
+      DOUBLE COMPLEX :: S,R
+      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
+      END INTERFACE
+      TYPE(ZAGMG_MUMPS_STRUC), INTENT(IN), TARGET :: ID
+      INTEGER, TARGET          :: PTRAR(ID%N,2)
+      END SUBROUTINE ZAGMG_MUMPS_746
+      END INTERFACE ZAGMG_MUMPS_746__
       IS_REORDERTREE_CALLED=.FALSE.
       KEEP   => id%KEEP
       KEEP8  => id%KEEP8
@@ -66578,6 +66863,121 @@
          PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
      &             S_ROOTBAND_INIT=0)
       DOUBLE PRECISION    OPASSW, OPELIW
+      INTERFACE ZAGMG_MUMPS_140_141__
+      SUBROUTINE ZAGMG_MUMPS_140( N, INODE, IW, LIW, A, LA,                  &
+     &                           IOLDPS, POSELT, IFLAG,                 &
+     &                           UU, NNEG, NPVW,                        &
+     &                           KEEP,KEEP8,                            &
+     &                           MYID, SEUIL, AVOID_DELAYED, ETATASS,   &
+     &     DKEEP,PIVNUL_LIST,LPN_LIST, IWPOS )
+      USE ZAGMG_MUMPS_OOC
+      IMPLICIT NONE
+      INTEGER(8) :: LA, POSELT
+      INTEGER N, INODE, LIW, IFLAG, NNEG, NPVW
+      INTEGER MYID, SLAVEF, IOLDPS
+      INTEGER KEEP( 500 )
+      INTEGER*8 KEEP8(150)
+      DOUBLE PRECISION UU, SEUIL
+      COMPLEX*16 A( LA )
+      INTEGER, TARGET :: IW( LIW )
+      LOGICAL AVOID_DELAYED
+      INTEGER ETATASS, IWPOS
+      INTEGER LPN_LIST
+      INTEGER PIVNUL_LIST(LPN_LIST)
+      DOUBLE PRECISION DKEEP(30)
+      END SUBROUTINE ZAGMG_MUMPS_140
+      SUBROUTINE ZAGMG_MUMPS_141( COMM_LOAD, ASS_IRECV,                      &
+     &           N, INODE, FPERE, IW, LIW, A, LA,                       &
+     &           UU, NOFFW,                                             &
+     &           NPVW,                                                  &
+     &             COMM, MYID, BUFR, LBUFR,LBUFR_BYTES,NBFIN,LEAF,      &
+     &             IFLAG, IERROR, IPOOL,LPOOL,                          &
+     &             SLAVEF, POSFAC, IWPOS, IWPOSCB, IPTRLU, LRLU,        &
+     &             LRLUS, COMP,                                         &
+     &             PTRIST, PTRAST, PTLUST_S, PTRFAC, STEP,              &
+     &             PIMASTER, PAMASTER,                                  &
+     &             NSTK_S,NBPROCFILS,PROCNODE_STEPS, root,              &
+     &             OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,         &
+     &             INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND, FRERE,        &
+     &             LPTRAR, NELT, FRTPTR, FRTELT, SEUIL,                 &
+     &             ISTEP_TO_INIV2, TAB_POS_IN_PERE, AVOID_DELAYED,      &
+     &            DKEEP,PIVNUL_LIST,LPN_LIST )
+      USE ZAGMG_MUMPS_OOC
+      IMPLICIT NONE
+!
+      TYPE ZAGMG_MUMPS_ROOT_STRUC
+        SEQUENCE
+        INTEGER MBLOCK, NBLOCK, NPROW, NPCOL
+        INTEGER MYROW, MYCOL
+        INTEGER ROOT_SIZE, TOT_ROOT_SIZE
+        INTEGER :: CNTXT_BLACS, truc
+        INTEGER, DIMENSION(:), POINTER :: RG2L_ROW
+        INTEGER, DIMENSION(:), POINTER :: RG2L_COL
+        INTEGER , DIMENSION(:), POINTER :: IPIV
+        INTEGER, DIMENSION( 9 ) :: DESCRIPTOR, DESCB
+        LOGICAL yes, gridinit_done
+        INTEGER LPIV, brol
+!       Used to access Schur easily from root structure
+        COMPLEX*16, DIMENSION(:), POINTER :: SCHUR_POINTER
+        INTEGER SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD, machin
+!
+!      Data for nullspace/QR
+!
+        COMPLEX*16, DIMENSION(:), POINTER :: QR_TAU
+        DOUBLE PRECISION     QR_RCOND
+!
+!      Givens rotations
+!
+        INTEGER MAXG, GIND
+        COMPLEX*16, DIMENSION(:),POINTER::GROW, GCOS, GSIN
+!
+!      RRRLU data
+!
+        INTEGER ELG_MAX,NULL_MAX
+        INTEGER ELIND,EUIND,NLUPDATE,NUUPDATE
+        INTEGER,DIMENSION(:),POINTER::PERM_ROW,PERM_COL
+        INTEGER,DIMENSION(:),POINTER::ELROW, EUROW, PTREL, PTREU
+        COMPLEX*16, DIMENSION(:), POINTER :: ELELG, EUELG, DL
+!
+      END TYPE ZAGMG_MUMPS_ROOT_STRUC
+      INTEGER COMM_LOAD, ASS_IRECV
+      INTEGER N, INODE, FPERE, LIW, NOFFW, NPVW
+      INTEGER(8) :: LA
+      COMPLEX*16 A( LA )
+      DOUBLE PRECISION UU, SEUIL
+      TYPE (ZAGMG_MUMPS_ROOT_STRUC) :: root
+      INTEGER COMM, MYID, LBUFR, LBUFR_BYTES
+      INTEGER LPTRAR, NELT
+      INTEGER(8) :: POSFAC, IPTRLU, LRLU, LRLUS
+      INTEGER NBFIN, IFLAG, IERROR, LEAF, LPOOL, SLAVEF,                &
+     &        IWPOS, IWPOSCB, COMP
+      INTEGER NB_BLOC_FAC
+      INTEGER ICNTL(40), KEEP(500)
+      INTEGER*8 KEEP8(150)
+      INTEGER, TARGET :: IW( LIW )
+      INTEGER FRTPTR( N+1 ), FRTELT( NELT )
+      INTEGER BUFR( LBUFR ), IPOOL(LPOOL), ITLOC(N)
+      INTEGER PTRARW(LPTRAR), PTRAIW(LPTRAR), ND( KEEP(28) )
+      INTEGER FRERE(KEEP(28)), FILS(N)
+      INTEGER INTARR(max(1,KEEP(14)))
+      INTEGER(8) :: PTRAST(KEEP(28))
+      INTEGER(8) :: PTRFAC(KEEP(28))
+      INTEGER(8) :: PAMASTER(KEEP(28))
+      INTEGER PTRIST(KEEP(28)),                                         &
+     & PTLUST_S(KEEP(28)),                                              &
+     & PIMASTER(KEEP(28)),                                              &
+     &        NSTK_S(KEEP(28)), NBPROCFILS(KEEP(28)),                   &
+     &        PROCNODE_STEPS(KEEP(28)), STEP(N)
+      INTEGER ISTEP_TO_INIV2(KEEP(71)),                                 &
+     &        TAB_POS_IN_PERE(SLAVEF+2,max(1,KEEP(56)))
+      DOUBLE PRECISION OPASSW, OPELIW
+      COMPLEX*16  DBLARR(max(1,KEEP(13)))
+      LOGICAL AVOID_DELAYED
+      INTEGER LPN_LIST
+      INTEGER PIVNUL_LIST(LPN_LIST)
+      DOUBLE PRECISION DKEEP(30)
+      END SUBROUTINE ZAGMG_MUMPS_141
+      END INTERFACE ZAGMG_MUMPS_140_141__
        ASS_IRECV = AGMG_MPF_REQUEST_NULL
        ITLOC(1:N) =0
        PTRIST  (1:KEEP(28))=0
