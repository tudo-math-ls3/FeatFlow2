# -*- mode: makefile; -*-
#!/usr/bin/env make
########################################################################
#                                                                      #
#         FINITE ELEMENT ANALYSIS & SOLUTION TOOLS  F E A S T          #
#                                                                      #
# Authors: Ch.Becker,                                                  #
#          S.Buijssen, D.Goeddeke, M.Grajewski, H.Wobker,              #
#          S.Kilian, S.Turek                                           #
#                                                                      #
# Contact: Applied Mathematics, TU Dortmund                            #
#          Vogelpothsweg 87, 44227 Dortmund                            #
#          Germany                                                     #
#                                                                      #
# Web:     http://www.feast.tu-dortmund.de                             #
#          mailto:feast@math.tu-dortmund.de                            #
#                                                                      #
########################################################################
# Version: $Id: Makefile.FEAT2,v 1.51 2010/12/12 22:16:42 goeddeke4 Exp $


# default values (aka variables that need to be set for for standalone builds)
OBJDIR       = object
CC           = 
CFLAGSCOPROC = 
HAS_CUDA10   = 
HAS_CUDA11   =
HAS_CUDA12   =
HAS_CUDA13   = 
HAS_CUDA20   = 
HAS_CUDA21   = 
HAS_OPENGL   =
APPONLYFLAGS =
CFLAGSF90    =
OPT          = 


################################################################################


# Inherit flags that are prone to changes
CFLAGSCOPROC = $(CFLAGSCOPROC_FROM_FEAT2) $(APPONLYFLAGS)

#FEAST# # Only use parameter checking if Fortran code does the same
#FEAST# ifneq (,$(findstring -DENABLE_PARAMETER_CHECK,$(CFLAGSF90) $(APPONLYFLAGS)))
#FEAST# CFLAGSCOPROC := $(CFLAGSCOPROC) -DENABLE_PARAMETER_CHECK
#FEAST# endif
#FEAST# 
#FEAST# # Only try to use Fortran traceback routines if Fortran code has been 
#FEAST# # compiled to provide them
#FEAST# ifneq (,$(findstring -DENABLE_ERROR_TRACEBACK,$(CFLAGSF90) $(APPONLYFLAGS)))
#FEAST# CFLAGSCOPROC := $(CFLAGSCOPROC) -DENABLE_ERROR_TRACEBACK
#FEAST# endif


################################################################################

# Map different levels of optimisation to a single string
#
# variant 1 (fast, but not extendible)
#optimise = $(subst EXPENSIVE, YES, $(OPT))

# variant 2 (more overhead, but extendible).
ifeq ($(strip $(OPT)), EXPENSIVE)
optimise = YES
endif
ifeq ($(strip $(OPT)), YES)
optimise = YES
endif


################################################################################


# Add OpenGL support
ifeq ($(strip $(HAS_OPENGL)),YES)

# test if GLEW_INC_PATH is not empty
ifneq ($(strip $(GLEW_INC_PATH)),)
MYGLEWINCLUDE = -I$(GLEW_INC_PATH)
else
MYGLEWINCLUDE =
endif

CFLAGSCOPROC := -DHAS_OPENGL $(MYGLEWINCLUDE) $(CFLAGSCOPROC)
#CFLAGSCOPROC := -DHAS_FUSED_MAD $(CFLAGSCOPROC)

endif


################################################################################


# Add CUDA support
ifneq (,$(findstring YES,$(HAS_CUDA10)$(HAS_CUDA11)$(HAS_CUDA12)$(HAS_CUDA13)$(HAS_CUDA20)))

# test if CUDA_INC_PATH is not empty
ifneq ($(strip $(CUDA_INC_PATH)),)
MYCUDAINCLUDE = -I$(CUDA_INC_PATH)
else
MYCUDAINCLUDE =
endif

# switches for C code
CFLAGSCOPROC := $(CFLAGSCOPROC) -DHAS_CUDA $(MYCUDAINCLUDE)
# cuda compiler
CC_CUDA = nvcc
# cuda compiler settings part 1
ifeq ($(call optimise), YES)
CFLAGSCUDA = -DHAS_CUDA $(MYCUDAINCLUDE) -O3 --ptxas-options=-v
else
CFLAGSCUDA = -DHAS_CUDA $(MYCUDAINCLUDE) -g -DENABLE_PARAMETER_CHECK --ptxas-options=-v
endif

# cuda compiler settings part 2: create fatbin
#CFLAGSCUDA := $(CFLAGSCUDA) -code compute_10,compute_11,compute_13 -arch compute_10

# cuda compiler settings part 2: pass correct arch flag
ifeq ($(strip $(HAS_CUDA10)),YES)
CFLAGSCUDA := $(CFLAGSCUDA)  -arch sm_10 
endif
ifeq ($(strip $(HAS_CUDA11)),YES)
CFLAGSCUDA := $(CFLAGSCUDA)  -arch sm_11
endif
ifeq ($(strip $(HAS_CUDA12)),YES)
CFLAGSCUDA := $(CFLAGSCUDA)  -arch sm_12
endif
ifeq ($(strip $(HAS_CUDA13)),YES)
CFLAGSCUDA := $(CFLAGSCUDA)  -arch=compute_13 -code=compute_13 -m64  -DHAS_CUDADOUBLEPREC
CFLAGSCOPROC := $(CFLAGSCOPROC) -DHAS_CUDADOUBLEPREC
endif
ifeq ($(strip $(HAS_CUDA20)),YES)
CFLAGSCUDA := $(CFLAGSCUDA)  -arch=compute_20 -code=compute_20 -m64  -DHAS_CUDADOUBLEPREC
CFLAGSCOPROC := $(CFLAGSCOPROC) -DHAS_CUDADOUBLEPREC
endif
ifeq ($(strip $(HAS_CUDA21)),YES)
CFLAGSCUDA := $(CFLAGSCUDA)  -arch=compute_21 -code=compute_21 -m64  -DHAS_CUDADOUBLEPREC
CFLAGSCOPROC := $(CFLAGSCOPROC) -DHAS_CUDADOUBLEPREC
endif
endif


################################################################################


# create source file list
# add object file generator rule
SRC =
OBJ = $(SRC:%.c=$(OBJDIR)/%.o)

# complete list of source file (queried for purge* targets)
SRC_COMPLETE := $(SRC)

HSRC =


# add cuda source file list and implicit object file generator rule
SRC_COMPLETE += 
ifneq (,$(findstring YES,$(HAS_CUDA10)$(HAS_CUDA11)$(HAS_CUDA12)$(HAS_CUDA13)$(HAS_CUDA20)$(HAS_CUDA21)))
SRC_CUDA = 
C_CUDA = $(SRC_CUDA:%.cu=%.cu.c)
OBJ_CUDA = $(C_CUDA:%.cu.c=$(OBJDIR)/%.o)
else
SRC_CUDA = 
C_CUDA = 
OBJ_CUDA = 
endif


# add opengl source file list and implicit object file generator rule
#SRC_COMPLETE += PLACE YOUR OPENGL SOURCE FILES HERE
ifeq ($(strip $(HAS_OPENGL)),YES)
SRC_OPENGL = 
OBJ_OPENGL = $(SRC_OPENGL:%.c=$(OBJDIR)/%.o)
else
SRC_OPENGL = 
OBJ_OPENGL = 
endif



################################################################################


# build library when called from main feast's Make system
COPROCLIB = $(OBJDIR)/libcoproc.a
all:		libcoproc.a 

libcoproc.a:	$(COPROCLIB) 

#-------------------------------------------------------------------------------
# Create the library
#-------------------------------------------------------------------------------
# Note:
# Explicitly take precautions to reflect the considerations in Section 11.3 of 
# the GNU Make Manual, http://www.gnu.org/software/make/manual/make.html#Archive-Pitfalls:
# This Makefile is potentially called simultaneously from multiple make processes,
# e.g. when compiling the FEAT2 regression benchmark in parallel. Concurrent 
# attempts to create the archive should not happen. Try to avoid it with the
# usual FEAT2 lock file mechanism.
include ../create_library.mk
$(COPROCLIB):  LOCKFILE = ../LOCK.creating.libcoproc.a
$(COPROCLIB):  WAITTIME = 15
$(COPROCLIB):  RETRIES  = 24
$(COPROCLIB):	$(OBJ) $(OBJ_CUDA) $(OBJ_OPENGL)
	@$(CREATE_LIB)


# we need an empty rule for .cu files to avoid circular dependencies
$(OBJDIR)/%.o: | $(OBJDIR)
$(OBJDIR)/%.o: %.cu $(HSRC)
	$(CC_CUDA) $(CFLAGSCUDA) -c -o $@ $<
$(OBJDIR)/%.o: %.c $(HSRC)
	$(CC) $(CFLAGSCOPROC)  -o $@ -c $<

$(OBJDIR):
	@test -d $(OBJDIR) || (rm -f $(OBJDIR); mkdir -p $(OBJDIR))


# to avoid deletion of .cu.c files, activate this
#ifeq ($(strip $(HAS_CUDA)),YES)
#.SECONDARY
#endif


################################################################################


# delete every file separately to prevent errors of kind:
# execvp: rm: Arg list too long
define remove_file
 rm -f $(file)

endef

# add clean target
clean:
	-$(foreach file, $(SRC:%.c=$(OBJDIR)/%.o), $(remove_file))
	-$(foreach file, $(SRC_CUDA:%.cu=$(OBJDIR)/%.o), $(remove_file))
	-$(foreach file, $(SRC_OPENGL:%.c=$(OBJDIR)/%.o), $(remove_file))
#FEAST# ifeq ($(strip $(STANDALONE)),YES)
#FEAST# 	-rm -f $(OBJDIR)/regressiontest.o
#FEAST# 	-rm -f $(OBJDIR)/benchmark.o	
#FEAST# 	-rm -f $(OBJDIR)/solvertest.o	
#FEAST# 	-rm -f $(OBJDIR)/coproc_solver.o	
#FEAST# 	-rm -f $(OBJDIR)/sbcublasbench
#FEAST# 	-rm -f regressiontest
#FEAST# 	-rm -f benchmark
#FEAST# 	-rm -f solvertest
#FEAST# 	-$(foreach file, $(wildcard *~), $(remove_file))
#FEAST# endif	

# add purge target
purge:
	-$(foreach file, $(patsubst %.c, $(OBJDIR)/%.o, $(filter %.c, $(SRC_COMPLETE))), $(remove_file))
	-$(foreach file, $(patsubst %.cu, $(OBJDIR)/%.o, $(filter %.cu, $(SRC_COMPLETE))), $(remove_file))
