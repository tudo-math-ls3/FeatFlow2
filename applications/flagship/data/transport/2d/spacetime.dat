# -*- mode: any-ini; -*-

################################################################################
#                     Input parameters for the FEM-AFC solver                  #
#                                                                              #
#                      Steady-state convection in space-time                   #
################################################################################

simportdatafiles(2) =
  '../../transport/2d/default.dat'
  '../../solverdefault.dat'

################################################################################

application = transport

################################################################################
[Transport]
################################################################################

# file which contains the application specific data
indatfile = %{sdatadirectory}/transport/2d/spacetime.indat

# section name of boundary condition for primal problem
sprimalbdrcondname = bdrcond_primal1

# section name of boundary condition for dual problem
sdualbdrcondname =

# number of spatial dimensions
ndimension = 2

# solution algorithm
algorithm = stationary_primal

#-------------------------------------------------------------------------------

# type of mass matrix
# 0 = no mass matrix
# 1 = consistent mass matrix
# 2 = lumped mass matrix
imasstype = 0

# type of mass antidiffusion
# 0 = no mass antidiffusion
# 1 = consistent mass antidiffusion
imassantidiffusiontype = 0

# type of approximate time derivative
# 0 = Galerkin method
# 1 = low-order method
iapproxtimederivativetype = 1

# type of flow velocity
# 0 = zero velocity v=0
# 1 = linear constant velocity v=v(x)
# 2 = linear time-dependent velocity v=v(x,t)
# 3 = Burgers equation in space-time
# 4 = Buckley Leverett equation in space-time
# 5 = Burgers' equation in 1D
# 6 = Burgers' equation in 2D
# 7 = Burgers' equation in 3D
# 8 = Buckley Leverett equation in 1D
ivelocitytype = 2

# section name of velocity field
svelocityname(2) =
  @velocity_x
  @velocity_y

# type of flow diffusion
# 0 = zero diffusion
# 1 = isotropic diffusion
# 2 = anisotropic diffusion
# 3 = variable diffusion
idiffusiontype = 0

# section name of diffusion tensor
sdiffusionname = @diffusion

# type of flow reaction
# 0 = zero reactive term
# 1 = analytical initial solution
ireactiontype = 0

# section name of reactive term
sreactionname = @reaction

# type of right-hand side vector
# 0 = zero right-hand side
# 1 = analytical right-hand side
irhstype = 0

# section name of right-hand side vector
srhsname = @rhs

# type of initial solution profile
# 0 = zero initial solution
# 1 = analytical initial solution: pointwise values
# 2 = PGM image
# 3 = anayltical initial solution: consistent L2-projection
# 4 = anayltical initial solution: lumped L2-projection
isolutiontype = 0

# section name of initial solution
ssolutionname = @initsol1

# type of exact solution profile
# 0 = no exact solution available
# 1 = analytical initial solution
# 2 = PGM image
iexactsolutiontype = 0

# section name of exact solution
sexactsolutionname = @exactsol1

# type of target functional
# 0 = zero target functional
# 1 = volume integral
# 2 = surface integral
# 3 = mixed volume/surface integral
# 4 = analytical target functional
itargetfunctype = 1

# section name of target functional
stargetfuncname = @targetFuncInt


#-------------------------------------------------------------------------------

# file which contains the boundary parametrisation
prmfile = %{sgriddirectory}/2d/square_01x01_quads.prm

# file which contains the triangulation
trifile = %{sgriddirectory}/2d/square_01x01_quads.tri

# type of finite element space(s)
celement = EL_Q1_2D

# convert mesh to triangular mesh?
iconvToTria = 0

# type of matrix format
# 7 = matrix format 7
# 9 = matrix format 9
imatrixformat = 9

# type of Jacobian matrix
# 0 = standard sparsity pattern
# 1 = extended sparsity pattern
ijacobianformat = 1

#-------------------------------------------------------------------------------

# section name of the mass stabilisation
mass = Mass

# section name of the convection stabilisation
convection = Convection

# section name of the diffusion stabilisation
diffusion = Diffusion

# section name of the time-stepping algorithm
timestep = Timestepping

# section name of the top-level solver
solver = FullMultigridSolver

# section name of the output configuration
output = Output

# section name of the adaptation configuration
adaptivity = Adaptivity

# section name of the error estimation configuration
errorestimator = ErrorEstimator


################################################################################
[Mass]
################################################################################

# type of spatial stabilisation:
#  0 = no stabilisation
# 40 = nonlinear FEM-LPT for mass contribution
# 50 = linearised FEM-LPT for mass contribution
istabilisation = 0


################################################################################
[Convection]
################################################################################

# type of spatial stabilisation:
#  0 = no stabilisation (Galerkin)
#  1 = discrete upwinding
# 10 = semi-expl. FEM-FCT (iprelimiting =0, =1, =2)
# 11 = semi-impl. FEM-FCT (iprelimiting =0, =2)
# 12 = iterative FEM-FCT (iprelimiting =0, =1, =2)
# 20 = linearised FEM-FCT (iprelimiting =0, =1, =2)
# 30 = FEM-TVD
# 31 = FEM-GP
# 41 = nonlinear upwind-biased FEM-LPT
# 51 = linearised upwind-biased FEM-LPT
istabilisation = 30

# perform prelimiting
#  0 = no prelimiting
#  1 = standard prelimiting
#  2 = minmod prelimiting
iprelimiting = 1


################################################################################
[Diffusion]
################################################################################

# type of spatial stabilisation
#  0 = no stabilisation (Galerkin)
#  2 = discrete maximum principle preservation
# 32 = nonlinear symmetric limiting
# 42 = nonlinear symmetric FEM-LPT
# 52 = linearised symmetric FEM-LPT
istabilisation = 0


################################################################################
[Output]
################################################################################

# type of UCD output format
# 0 = no output
# 1 = GMV
# 2 = AVS
# 3 = Paraview (VTK)
iformatUCD = 1

# type of UCD output
# 0 = standard
# 1 = linearisation with discontinuous P1 finite elements
# 2 = linearisation with continuous P1 finite elements
ilineariseucd = 0

# number of refinement steps
nrefineucd = 0

# time interval for UCD output
dstepUCD = 1.0

# file for UCD output of solution
sucdsolution = out/spacetime

# file for UCD output of error
sucderror = out/spacetime_error


################################################################################
[Timestepping]
################################################################################

# level of output information:
# 0 = no output
# 1 = errors
# 2 = errors+warnings
# 3 = information
# 4 = verbose output
ioutputlevel = 5

# type of time-stepping algorithm
# 1 = two-level theta-scheme
# 2 = explicit Runge-Kutta scheme
# 5 = full MG
ctimestepType = 1

# norm to use for solution variation checking
# 0 = Euclidian norm
# 1 = L1-norm
# 2 = L2-norm
# 3 = MAX-norm
isolNorm = 0

# implicitness parameter: Valid values of THETA are in the range [0,1]
theta = 1.0

# number of steps for multisteps scheme
multisteps = 2

# initial time for the simulation
dinitialTime = 0.0

# final time for the simulation.
dfinalTime = 1.0

# initial time step size
dinitialStep = 1.0

# lower bound for the admissible time step
dminStep = 0.01

# upper bound for the admissible time step
dmaxStep = 10.0

# adaptive time stepping algorithm
iadaptTimestep = 0

# initial time for adaptive time stepping
dadaptTime = 0.0

# minimum factor by which time step may change
ddecreaseFactor = 0.1

# maximum factor by which time step may change
dincreaseFactor = 2.0

# reduction factor by which time step is reduced if simulation fails
dstepReductionFactor = 0.8

# target tolerace for relative changes
depsRel = 0.0

# absolute tolerance for relative changes
depsAbs = 0.0

# tolerance for steady state convergence
depsSteady = 0.0


################################################################################
[FullMultigridSolver]
 csolverType = 5
################################################################################

# level of output information:
# 0 = no output
# 1 = errors
# 2 = errors+warnings
# 3 = information
# 4 = verbose output
ioutputlevel = 2

# minimum multigrid level number
nlmin = 6

# maximum multigrid level number
nlmax = 6

# type of multigrid cycle
# 0 = F-cylce
# 1 = V-cycle
# 2 = W-cycle
# 3,4,5 = corresponding saw tooth variants
icycle = 0

# minimum number of multigrid steps
ilmin = 1

# maximum number of multigrid steps
ilmax = 1

# nonlinear subsolver
# 1 = nonlinear single-grid solver
# 3 = nonlinear multigrid solver
isolver = 1

# name of the subsolver
ssolvername = NonlinearSolver


################################################################################
[NonlinearMultigridSolver]
 csolverType = 3
################################################################################

# level of output information:
# 0 = no output
# 1 = errors
# 2 = errors+warnings
# 3 = information
# 4 = verbose output
ioutputlevel = 0

# norm to use for defect checking
# 0 = Euclidian norm
# 1 = L1-norm
# 2 = L2-norm
# 3 = MAX-norm
iresNorm = 0

# minimum multigrid level number
# If NLMIN = NLMAX then the nonlinear problem is solved by a single-grid solver
nlmin = 1

# maximum multigrid level number (see NLMIN)
nlmax = 1

# minimum number of linear mg steps
ilmin = 1

# maximum number of linear mg steps
ilmax = 1

# type of multigrid cycle
# 0 = F-cylce
# 1 = V-cycle
# 2 = W-cycle
# 3,4,5 =  corresponding saw tooth variants
icycle = 1

# nonlinear coarse grid solver
# 1 = nonlinear single-grid solver
# 3 = nonlinear multigrid solver
isolver = 1

# name of nonlinear coarse grid solver
ssolvername = NonlinearSolver

# smoother for the nonlinear multigrid solver
# =1, nonlinear single-grid smoother, =3 nonlinear multigrid smoother
ismoother = 1

# name of nonlinear smoother
ssmoothername = NonlinearSolver

# number of presmoothing steps (if saw tooth variant is used, then no
# presmoothing steps are performed in the coarse-to-fine part of the cycle)
npresmooth = 2

# number of postsmoothing steps (if saw tooth variant is used, then no
# postsmoothing steps are performed in the coarse-to-fine part of the cycle)
npostsmooth = 2

# factor for pre/postsm. on coarser levels (On each level l, the number of
# smoothing steps is computed from SM_l=SM_L*NSFAC**(L-l), where L stands
# for the finest grid level and SM_L is the prescribed number of smoothing steps)
nsfac = 1

# nonlinear relaxation parameter
domega = 1.0

# absolute tolerance for residual
depsAbs = 1e-12

# relative tolerance for residual
depsRel = 0.0

# relative tolerance for stagnation
depsStag = 0.0


################################################################################
[NonlinearSolver]
 csolverType = 1
################################################################################

# level of output information:
# 0 = no output
# 1 = errors
# 2 = errors+warnings
# 3 = information
# 4 = verbose output
ioutputlevel = 3

# norm to use for defect checking
# 0 = Euclidian norm
# 1 = L1-norm
# 2 = L2-norm
# 3 = MAX-norm
iresNorm = 0

# minimum number of nonlinear steps
nminIterations = 1

# maximum number of nonlinear steps
nmaxIterations = 1000

# preconditioner for the nonlinear solver
# 1 = block-diagonal preconditioner
# 2 = defect-correction algorithm
# 3 = algebraic Newton algorithm
iprecond = 2

# nonlinear solver
# 101 = fixed-point iteration
# 102 = predictor-corrector fixed-point iteration
isolver = 101

# strategy for choosing the perturbation parameter in Newton's method
# 1 = NITSOL
# 2 = SQRT(EPS)
# otherwise, user-defined value
dperturbationStrategy = 1

# strategy for choosing the forcing term in Newton's method
# 1 = choice 1 by Eisenstat/Walker
# 2 = choice 2 by Eisenstat/Walker
# 3 = choice by Brown/Saad
# 4 = choice by Dembo/Steihaug
# otherwise, user-defined fixed value
dforcingStrategy = 1

# check sufficient decrease condition in globalisation
# 0 = apply Newton increment without globalisation
# 1 = check sufficient decrease condition and perform backtracking if required
icheckSufficientDecrease = 1

# maximum number of backtracking steps
nmaxBacktrackingSteps = 5

# update frequency of Jacobian
iupdateFrequency = 0

# nonlinear relaxation parameter
domega = 1.0

# absolute tolerance for residual
depsAbs = 1e-12

# relative tolerance for residual
depsRel = 0.0

# relative tolerance for stagnation
depsStag = 0.0

# name of linear sub-solver
ssolvername = LinearSolver


################################################################################
[LinearMultigridSolver]
 csolverType = 4
################################################################################

# level of output information:
# 0 = no output
# 1 = errors
# 2 = errors+warnings
# 3 = information
# 4 = verbose output
ioutputlevel = 3

# norm to use for defect checking
# 0 = Euclidian norm
# 1 = L1-norm
# 2 = L2-norm
# 3 = MAX-norm
iresNorm = 0

# minimum multigrid level number
# If NLMIN = NLMAX then the nonlinear problem is solved by a single-grid solver
nlmin = 1

# maximum multigrid level number (see NLMIN)
nlmax = 1

# minimum number of linear mg steps
ilmin = 1

# maximum number of linear mg steps
ilmax = 100

# type of multigrid cycle
# 0 = F-cylce
# 1 = V-cycle
# 2 = W-cycle
# 3,4,5 =  corresponding saw tooth variants
icycle = 1

# linear coarse grid solver
# 2 = linear single-grid solver
isolver = 2

# name of linear coarse grid solver
ssolvername = LinearSolver

# smoother for the linear multigrid solver
# 2 = linear single-grid solver
# 4 = linear multigrid solver
ismoother = 2

# name of smoother
ssmoothername = LinearSmoother

# number of presmoothing steps (if saw tooth variant is used, then no
# presmoothing steps are performed in the coarse-to-fine part of the cycle)
npresmooth = 2

# number of postsmoothing steps (if saw tooth variant is used, then no
# postsmoothing steps are performed in the coarse-to-fine part of the cycle)
npostsmooth = 2

# factor for pre/postsm. on coarser levels (On each level l, the number of
# smoothing steps is computed from SM_l=SM_L*NSFAC**(L-l), where L stands
# for the finest grid level and SM_L is the prescribed number of smoothing steps)
nsmoothfactor = 1

# linear relaxation parameter
domega = 1.0

# absolute tolerance for residual
depsAbs = 1e-12

# relative tolerance for residual
depsRel = 1e-8

# relative tolerance for stagnation
depsStag = 0.0


################################################################################
[LinearSmoother]
 csolverType = 2
################################################################################

# smoother for the linear multigrid solver
#  2 = Jacobi
#  4 = SOR
#  5 = SSOR
#  7 = BiCGSTAB
#  8 = FGMRES
# 50 = ILU
isolver = 5

# dimension of the Krylov subspace for FGMRES method
nkrylov = 15

# tolerance of (M)ILU-preconditioner
depsILU = 1e-12

# size of fill-in for (M)ILU(s)
ifill = 0

# (M)ILU(s) relaxation
domega = 1.0

# name of preconditioner
sprecondName = LinearPrecond


################################################################################
[LinearSolver]
 csolverType = 2
################################################################################

# level of output information:
# 0 = no output
# 1 = errors
# 2 = errors+warnings
# 3 = information
# 4 = verbose output
ioutputlevel = 0

# norm to use for defect checking
# 0 = Euclidian norm
# 1 = L1-norm
# 2 = L2-norm
# 3 = MAX-norm
iresNorm = 0

# minimum number of linear steps
nminIterations = 1

# maximum number of linear steps
nmaxIterations = 100

# type of linear solver
#  2 = Jacobi
#  4 = SOR
#  5 = SSOR
#  7 = BiCGSTAB
#  8 = FGMRES
# 11 = UMFPACK4
isolver = 7

# dimension of the Krylov subspace for FGMRES method
nkrylov = 50

# linear relaxation parameter
domega = 1.0

# absolute tolerance for residual
depsAbs = 1e-12

# relative tolerance for residual
depsRel = 0.0

# relative tolerance for stagnation
depsStag = 0.0

# name of preconditioner
sprecondName = LinearPrecond


################################################################################
[LinearPrecond]
 csolverType = 2
################################################################################

# preconditioner for the linear single-grid solver
#  2 = Jacobi
#  4 = SOR
#  5 = SSOR
# 50 = ILU
isolver = 50

# tolerance of (M)ILU-preconditioner
depsILU = 1e-10

# size of fill-in for (M)ILU(s)
ifill = 0

# (M)ILU(s) relaxation
domega = 1.0


################################################################################
[Adaptivity]
################################################################################

# number of pre-adaptation steps
npreadapt = 0

# number of adaptation steps
nadapt = 0

# time for grid adaptivity
dtimeadapt = 0.0

# time step for grid adaptivity
dstepadapt = 0.0

# maximum number of refinement levels
nsubdividemax = 0

# adaptation strategy
# 1 = red-green
iadaptationStrategy = 1

# refinement tolerance
drefinementTolerance = 0.05

# coarsening tolerance
dcoarseningTolerance = 0.01


################################################################################
[ErrorEstimator]
################################################################################

# type of error estimator
# 1 = L2-projection
# 2 = node-based SPR
# 3 = element-based SPR
# 4 = face-based SPR
# 5 = limited gradient averaging
# 6 = second-difference indicator
ierrorestimator = 1

# type or grid indicator
# 0 = as is
# 1 = equidistribution
# 2 = logarithmic equidistribution
# 3 = fixed-rate strategy
# 4 = RMS automatic treshold
# 5 = balancing strategy
igridindicator = 1

# noise filter
dnoisefilter = 0.2

# absolute filter
dabsfilter = 0.001

# number of protection layers
nprotectLayers = 0

# tolerance for protection layers
dprotectLayerTolerance = 0.0