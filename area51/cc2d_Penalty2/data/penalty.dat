############
[CC-PENALTY]
############

# Activate penalty method and choose the way of calculating penalty parameter
#   - 0.0 - not active
#   - 1.0 - active

dPenalty = 1.0

# Penalty method
#   - 1 - full Lambda (standard)
#   - 2 - fractional Lambda
#   - 3 - exponential Lambda (1/(1+exp(d(x)/eps))

ipenalty = 1

# Penalty parameter (standard 1000)
dlambda = 1e3

# itypePenaltyAssem indicates how to assemble Penalty matrix
#   - 1 means only one bilinear form with a cub. formula and non constant coeff cc_Lambda
#   - 2 means two bilinear forms combining simple cub. formula with adaptive cub. formula

itypePenaltyAssem = 1

# Generation of penalty matrix. 0=real mass,1= diagonaliz. + scale, 2 = HRZ mass
iPenalty_lump = 0

# Element type 
#  0 = Q1~(E031) / Q1~(E031) / Q0
#  1 = Q1~(E030) / Q1~(E030) / Q0
#  2 = Q1~(EM31) / Q1~(EM31) / Q0
#  3 = Q1~(EM30) / Q1~(EM30) / Q0 = standard
#  4 = Q2 (E013) / Q2 (E013) / QP1
#  5 = Q1~(EM30) / Q1~(EM30) / Q0 unpivoted (much faster than 3 but less stable)
# ... (see discretisation.dat)

ielementType_Penalty = 3

# cubature formula for Penalty matrix. 
# ="": use default cubature formula.

scubPenalty = G3x3

# adaptive cubature formula for Penalty matrix. Only for itypePenaltyAssem = 2 
# ="": use default cubature formula.

scubPenaltySum = TRZ

# ilocalrefinement - indicates the local refinement we want (level n -> pow(2,2*n))

irefinement     = 5

# Calculate the mass of the penalty matrix (default 0 / 1 for activation)

iarea = 0
sfilenamePenaltyMatrix_Vol = '%{ssolutiondirectory}/PenaltyMatrix_Vol'

# Output the penalty matrix to txt file (default 0 / 1 for activation)

ipenmat = 0
sfilenamePenaltyMatrix = PenaltyMatrix
