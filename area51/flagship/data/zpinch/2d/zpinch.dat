# -*- mode: any-ini; -*-

################################################################################
#                     Input parameters for the FEM-AFC solver                  #
#                                                                              #
#                  Z-pinch implosion problem in x-y coordinates                #
################################################################################

simportdatafiles(3) =
  'data/zpinch/2d/default.dat'
  'data/solverdefault.dat'
  'data/zpinch/solverdefault.dat'

################################################################################

application = zpinch

################################################################################
[Zpinch]
################################################################################

# section names of sub-applications
subapplication(2) =
  Hydro
  Transport

# file which contains the application specific data
indatfile = data/zpinch/2d/zpinch.indat

# section name of boundary condition for primal problem
sprimalbdrcondname(2) =
  bdrcond_hydro_primal
  bdrcond_transport_primal

# section name of boundary condition for dual problem
sdualbdrcondname(2) =
  bdrcond_hydro_dual
  bdrcond_transport_dual

# number of spatial dimensions
ndimension = 2

# solution algorithm
algorithm = transient_primal

#-------------------------------------------------------------------------------

# section name of Lorentz force term
slorentzforcename = @forceterm

# minimum effective radius
deffectiveradius = 1e-4

# type of coordinate system
#  0 = Cartesian coodinate system (x,y,z) 1D, 2D, 3D
#  1 = axi-symmetric coordinate system (r,z) 2D
#  2 = cylindrically symmetric coordinate system (r) 1D
#  3 = spherically symmetric coordinate system (r) 1D
icoordsystem = 0

# type of geometric source term
# 0 = evaluate linear form by numerical integration
# 1 = group formulation with consistent mass matrix
# 2 = group formulation with lumped mass matrix
ilorentzforcetype = 2

# type of synchronization used for flux correction
# 0 = no synchronization
# 1 = minimum synchronization
# 2 = Hydrodynamic model first, transport model second
# 3 = Transport model first, hydrodynamic model second
# 4 = Hydrodynamic model only
# 5 = Transport model only
ilimitersynchronisation = 3

#-------------------------------------------------------------------------------

# file which contains the boundary parametrisation
prmfile = grids/2d/zpinch_60x240.prm

# file which contains the triangulation
trifile = grids/2d/zpinch_60x240.tri

# convert mesh to triangular mesh?
iconvToTria = 0

#-------------------------------------------------------------------------------

# section name of the time-stepping algorithm
timestep = Timestepping

# section name of the top-level solver
solver = CoupledSolver

# section name of the output configuration
output = Output

# section name of the adaptation configuration
adaptivity = Adaptivity

# section name of the error estimation configuration
errorestimator = ErrorEstimator


################################################################################
[Hydro]
################################################################################

# file which contains the application specific data
indatfile = %{Zpinch.indatfile}

# section name of boundary condition for primal problem
sprimalbdrcondname = %{Zpinch.sprimalbdrcondname:1}

# section name of boundary condition for dual problem
sdualbdrcondname = %{Zpinch.sdualbdrcondname:1}

# number of spatial dimensions
ndimension = %{Zpinch.ndimension}

#-------------------------------------------------------------------------------

# type of mass matrix
# 0 = no mass matrix
# 1 = consistent mass matrix
# 2 = lumped mass matrix
imasstype = 2

# type of mass antidiffusion
# 0 = no mass antidiffusion
# 1 = consistent mass antidiffusion
imassantidiffusiontype = 1

# type of dissipation
# 0 = no dissipation
# 1 = scalar dissipation (-1 = dimensional splitting)
# 2 = tensorial dissipation (-2 = dimensional splitting)
# 3 = Rusanov type (-3 = dimensional splitting)
idissipationtype = 3

# type of system coupling
# 0 = segregated approach
# 1 = fully-coupled approach
isystemcoupling = 0

# type of preconditioner
# 0 = Galerkin scheme
# 1 = low-order scheme with scalar dissipation
# 2 = low-order scheme with tensorial dissipation
# 3 = low-order schemes of Rusanov type
isystemPrecond = 3

#-------------------------------------------------------------------------------

# variables for flux correction
# (i)  for synchronized flux correction list 
#      all variables in alphabetical(!) order, e.g.
#
# slimitingvariable = density,pressure,velocity
#
# (ii) for sequential/multiplicative flux correction list
#      all variables one by one, e.g.
#
# slimitingvariable(3) =
#      density
#      pressure
#      velocity
slimitingvariable(2) = 
  density
  pressure

# number of failsafe steps
nfailsafe = 0

# variables for failsafe flux correction
sfailsafevariable(3) =
  density
  pressure
  advect

#-------------------------------------------------------------------------------

# type of initial solution profile
# 0 = zero initial solution
# 1 = analytical initial solution: pointwise values
# 2 = PGM image
# 3 = anayltical initial solution: consistent L2-projection
# 4 = anayltical initial solution: lumped L2-projection
isolutiontype = 3

# absolute tolerance for Richardson iteration
depsAbsSolution = 1e-4

# relative tolerance for Richardson iteration
depsRelSolution = 1e-3

# maximum number of Richardson iterations
nmaxIterationsSolution = 100

# section name of initial solution
ssolutionname(4) = 
  @initsol_rho
  @initsol_vel
  @initsol_vel
  @initsol_Etot

# type of exact solution profile
# 0 = no exact solution available
# 1 = analytical initial solution
iexactsolutiontype = 0

# section name of exact solution
sexactsolutionname = 

# variables for constrained initialization
ssolutionconstrainvariable(2) =
  density
  pressure
  
# number of failsafe steps in constrained initialization
nsolutionfailsafe = 0

# variables for failsafe constrained initialization
ssolutionfailsafevariable(2) =
  density
  energy

#-------------------------------------------------------------------------------

# type of finite element space(s)
celement(2) =
  EL_P1_2D
  EL_Q1_2D

# type of matrix format
# 7 = matrix format 7
# 9 = matrix format 9
imatrixformat = 9

# type of system format
# 0 = interleave scalar format
# 1 = block system
isystemformat = 0

#-------------------------------------------------------------------------------

# Number of refinement steps used for summed cubature rules
nsumcubRefLinForm = 2

#-------------------------------------------------------------------------------

# section name of the inviscid stabilization
inviscid = Inviscid

#-------------------------------------------------------------------------------

# type of coordinate system
#  0 = Cartesian coodinate system (x,y,z) 1D, 2D, 3D
#  1 = axi-symmetric coordinate system (r,z) 2D
#  2 = cylindrically symmetric coordinate system (r) 1D
#  3 = spherically symmetric coordinate system (r) 1D
icoordsystem = %{Zpinch.icoordsystem}

# type of geometric source term
# 0 = evaluate linear form by numerical integration
# 1 = group formulation with consistent mass matrix
# 2 = group formulation with lumped mass matrix
igeometricsourcetype = 2


################################################################################
[Inviscid]
################################################################################

# type of spatial stabilization:
#  0 = no stabilization (Galerkin)
#  1 = discrete upwinding
# 10 = semi-impl. FEM-FCT
# 11 = semi-expl. FEM-FCT
# 12 = linearised FEM-FCT
# 13 = iterative FEM-FCT
# 14 = characteristic FEM-FCT
# 20 = FEM-TVD
# 21 = FEM-GP
istabilisation = 12

# perform prelimiting
iprelimiting = 0


################################################################################
[Transport]
################################################################################

# file which contains the application specific data
indatfile = %{Zpinch.indatfile}

# section name of boundary condition for primal problem
sprimalbdrcondname = %{Zpinch.sprimalbdrcondname:2}

# section name of boundary condition for dual problem
sdualbdrcondname = %{Zpinch.sdualbdrcondname:2}

# number of spatial dimensions
ndimension = %{Zpinch.ndimension}

#-------------------------------------------------------------------------------

# type of mass matrix
# 0 = no mass matrix
# 1 = consistent mass matrix
# 2 = lumped mass matrix
imasstype = %{Hydro.imasstype}

# type of mass antidiffusion
# 0 = no mass antidiffusion
# 1 = consistent mass antidiffusion
imassantidiffusiontype = %{Hydro.imassantidiffusiontype}

# type of flow velocity
# 0 = zero velocity v=0
# 1 = linear constant velocity v=v(x)
# 2 = linear time-dependent velocity v=v(x,t)
# 3 = Burgers equation in space-time (x,t)
# 4 = Buckley Leverett equation in space-time (x,t)
# 5 = Burgers' equation in 1D
# 6 = Burgers' equation in 2D
# 7 = Burgers' equation in 3D
# 8 = Buckley Leverett equation in 1D
ivelocitytype = -1

# section name of velocity field
svelocityname = 

# type of flow diffusion
# 0 = zero diffusion
# 1 = isotropic diffusion
# 2 = anisotropic diffusion
# 3 = variable diffusion
idiffusiontype = 0

# section name of diffusion tensor
sdiffusionname = 

# type of flow reaction
# 0 = zero reactive term
# 1 = analytical initial solution
ireactiontype = 0

# section name of reactive term
sreactionname = 

# type of right-hand side vector
# 0 = zero right-hand side
# 1 = analytical right-hand side
irhstype = 0

# section name of right-hand side vector
srhsname = 

#-------------------------------------------------------------------------------

# type of initial solution profile
# 0 = zero initial solution
# 1 = analytical initial solution: pointwise values
# 2 = PGM image
# 3 = anayltical initial solution: consistent L2-projection
# 4 = anayltical initial solution: lumped L2-projection
isolutiontype = %{Hydro.isolutiontype}

# absolute tolerance for Richardson iteration
depsAbsSolution = %{Hydro.depsAbsSolution}

# relative tolerance for Richardson iteration
depsRelSolution = %{Hydro.depsRelSolution}

# maximum number of Richardson iterations
nmaxIterationsSolution = %{Hydro.nmaxIterationsSolution}

# section name of initial solution
ssolutionname = @initsol_tracer

# type of exact solution profile
# 0 = no exact solution available
# 1 = analytical exact solution
# 2 = PGM image
iexactsolutiontype = %{Hydro.iexactsolutiontype}

# section name of exact solution
sexactsolutionname = 

# type of target functional
# 0 = no target variable
# 1 = volume integral
# 2 = surface integral
itargetfunctype = 0

# section name of target functional
stargetfuncname = 

# type of exact target functional type
# 0 = zero target functional
# 1 = volume integral
# 2 = surface integral
# 3 = analytical target functional
iexacttargetfunctype = 0

# section name of exact target functional
sexacttargetfuncname = 

#-------------------------------------------------------------------------------

# type of finite element space(s)
#  1 = P1 finite elements
#  2 = P2 finite elements
# 11 = Q1 finite elements
# 12 = Q2 finite elements
# -1 = mixed P1/Q1 finite elements
# -2 = mixed P2/Q2 finite elements
celement = %{Hydro.celement}

# type of matrix format
# 7 = matrix format 7
# 9 = matrix format 9
imatrixformat = %{Hydro.imatrixformat}

# type of Jacobian matrix
# 0 = standard sparsity pattern
# 1 = extended sparsity pattern
ijacobianformat = 0

#-------------------------------------------------------------------------------

# Number of refinement steps used for summed cubature rules
nsumcubRefLinForm = %{Hydro.nsumcubRefLinForm}

#-------------------------------------------------------------------------------

# section name of the convection stabilization
convection = Convection

#-------------------------------------------------------------------------------

# type of coordinate system
#  0 = Cartesian coodinate system (x,y,z) 1D, 2D, 3D
#  1 = axi-symmetric coordinate system (r,z) 2D
#  2 = cylindrically symmetric coordinate system (r) 1D
#  3 = spherically symmetric coordinate system (r) 1D
icoordsystem = %{Hydro.icoordsystem}

# type of geometric source term
# 0 = evaluate linear form by numerical integration
# 1 = group formulation with consistent mass matrix
# 2 = group formulation with lumped mass matrix
igeometricsourcetype = %{Hydro.igeometricsourcetype}


################################################################################
[Convection]
################################################################################

# type of spatial stabilization: 
#  0 = no stabilization (Galerkin)
#  1 = discrete upwinding
# 10 = semi-impl. FEM-FCT
# 11 = semi-expl. FEM-FCT
# 12 = linearised FEM-FCT
# 13 = iterative FEM-FCT
# 14 = characteristic FEM-FCT
# 20 = FEM-TVD
# 21 = FEM-GP
istabilisation = %{Inviscid.istabilisation}

# perform prelimiting
iprelimiting = %{Inviscid.iprelimiting}


################################################################################
[Output]
################################################################################

# type of UCD output format
# 0 = no output
# 1 = GMV
# 2 = AVS
# 3 = Paraview (VTK)
iformatUCD = 1

# time interval for UCD output
dstepUCD = 0.01

# file for UCD output of solution
sucdsolution = out/zpinch

# file for UCD import of solution
sucdimport =

# file for UCD output of error
sucderror = out/

# variables for ucd output
sucdvariable(5) =
 density
 velocity
 energy
 pressure
 advect


################################################################################
[Timestepping]
################################################################################

# level of output information:
# 0 = no output
# 1 = errors
# 2 = errors+warnings
# 3 = information
# 4 = verbose output
ioutputlevel = 3

# type of time-stepping algorithm
# 1 = two-level theta-scheme
# 2 = explicit Runge-Kutta scheme
# 5 = full MG
ctimestepType = 1

# norm to use for solution variation checking
# 0 = Euclidian norm
# 1 = L1-norm
# 2 = L2-norm
# 3 = MAX-norm
isolNorm = 0

# implicitness parameter: Valid values of THETA are in the range [0,1]
theta = 0.5

# number of steps for multisteps scheme
multisteps = 0

# initial time for the simulation
dinitialTime = 0.0

# final time for the simulation.
dfinalTime = 1.1

# initial time step size
dinitialStep = 1e-5

# lower bound for the admissible time step
dminStep = 1e-5

# upper bound for the admissible time step
dmaxStep = 1e-5

# adaptive time stepping algorithm
iadaptTimestep = 0

# initial time for adaptive time stepping
dadaptTime = 0.0

# minimum factor by which time step may change
ddecreaseFactor = 0.9

# maximum factor by which time step may change
dincreaseFactor = 1.1

# reduction factor by which time step is reduced if simulation fails
dstepReductionFactor = 0.8

# target tolerace for relative changes
depsRel = 1e-2

# absolute tolerance for relative changes
depsAbs = 0.0

# maximum tolerance for relative changes
dmaxRel = 1e-1

# tolerance for steady state convergence
depsSteady = 0.0


################################################################################
[CoupledSolver]
 csolverType = 6
################################################################################

# level of output information:
# 0 = no output
# 1 = errors
# 2 = errors+warnings
# 3 = information
# 4 = verbose output
ioutputlevel = 3

# norm to use for defect checking
# 0 = Euclidian norm
# 1 = L1-norm
# 2 = L2-norm
# 3 = MAX-norm
iresNorm = 3

# stopping criterion
istoppingCriterion = 0

# minimum number of coupling steps
nminIterations = 1

# maximum number of coupling steps
nmaxIterations = 5

# nonlinear relaxation parameter
domega = 1.0

# absolute tolerance for residual
depsAbs = 1e-8

# relative tolerance for residual
depsRel = 1e-4

# relative tolerance for stagnation
depsStag = 0.0

# names of the subsolvers
ssolvername(2) = 
   FullMultigridSolverHydro
   FullMultigridSolverTransport


################################################################################
[FullMultigridSolverHydro]
 csolverType = 5
################################################################################

# level of output information:
# 0 = no output
# 1 = errors
# 2 = errors+warnings
# 3 = information
# 4 = verbose output
ioutputlevel = 0

# minimum multigrid level number
nlmin = 1

# maximum multigrid level number
nlmax = 1

# type of multigrid cycle
# 0 = F-cylce
# 1 = V-cycle
# 2 = W-cycle
# 3,4,5 = corresponding saw tooth variants
icycle = 0

# minimum number of multigrid steps
ilmin = 1

# maximum number of multigrid steps
ilmax = 1

# nonlinear subsolver
# 1 = nonlinear single-grid solver
# 3 = nonlinear multigrid solver
isolver = 1

# name of the subsolver
ssolvername = NonlinearSolverHydro


################################################################################
[FullMultigridSolverTransport]
 csolverType = 5
################################################################################

# level of output information:
# 0 = no output
# 1 = errors
# 2 = errors+warnings
# 3 = information
# 4 = verbose output
ioutputlevel = %{FullMultigridSolverHydro.ioutputlevel}

# minimum multigrid level number
nlmin = %{FullMultigridSolverHydro.nlmin}

# maximum multigrid level number
nlmax = %{FullMultigridSolverHydro.nlmax}

# type of multigrid cycle
# 0 = F-cylce
# 1 = V-cycle
# 2 = W-cycle
# 3,4,5 = corresponding saw tooth variants
icycle = %{FullMultigridSolverHydro.icycle}

# minimum number of multigrid steps
ilmin = %{FullMultigridSolverHydro.ilmin}

# maximum number of multigrid steps
ilmax = %{FullMultigridSolverHydro.ilmax}

# nonlinear subsolver
# 1 = nonlinear single-grid solver
# 3 = nonlinear multigrid solver
isolver = %{FullMultigridSolverHydro.isolver}

# name of the subsolver
ssolvername = NonlinearSolverTransport


################################################################################
[NonlinearSolverHydro]
 csolverType = 1
################################################################################

# level of output information:
# 0 = no output
# 1 = errors
# 2 = errors+warnings
# 3 = information
# 4 = verbose output
ioutputlevel = 3

# norm to use for defect checking
# 0 = Euclidian norm
# 1 = L1-norm
# 2 = L2-norm
# 3 = MAX-norm
iresNorm = 0

# minimum number of nonlinear steps
nminIterations = 1

# maximum number of nonlinear steps
nmaxIterations = 25

# preconditioner for the nonlinear solver
# 1 = block-diagonal preconditioner
# 2 = defect-correction algorithm
# 3 = algebraic Newton algorithm
iprecond = 2

# nonlinear solver
# 101 = fixed-point iteration
# 102 = predictor-corrector fixed-point iteration
isolver = 101

# strategy for choosing the perturbation parameter in Newton's method
# 1 = NITSOL
# 2 = SQRT(EPS)
# otherwise, user-defined value
dperturbationStrategy = 1

# strategy for choosing the forcing term in Newton's method
# 1 = choice 1 by Eisenstat/Walker
# 2 = choice 2 by Eisenstat/Walker
# 3 = choice by Brown/Saad
# 4 = choice by Dembo/Steihaug
# otherwise, user-defined fixed value
dforcingStrategy = 1

# check sufficient decrease condition in globalization
# 0 = apply Newton increment without globalization
# 1 = check sufficient decrease condition and perform backtracking if required
icheckSufficientDecrease = 1

# maximum number of backtracking steps
nmaxBacktrackingSteps = 5

# update frequency of Jacobian
iupdateFrequency = 0

# nonlinear relaxation parameter
domega = 1.0

# absolute tolerance for residual
depsAbs = 1e-10

# relative tolerance for residual
depsRel = 1e-8

# relative tolerance for stagnation
depsStag = 0.0

# name of linear sub-solver
ssolvername = LinearSolver


################################################################################
[NonlinearSolverTransport]
 csolverType = 1
################################################################################

# level of output information:
# 0 = no output
# 1 = errors
# 2 = errors+warnings
# 3 = information
# 4 = verbose output
ioutputlevel = %{NonlinearSolverHydro.ioutputlevel}

# norm to use for defect checking
# 0 = Euclidian norm
# 1 = L1-norm
# 2 = L2-norm
# 3 = MAX-norm
iresNorm = %{NonlinearSolverHydro.iresNorm}

# minimum number of nonlinear steps
nminIterations = %{NonlinearSolverHydro.nminIterations}

# maximum number of nonlinear steps
nmaxIterations = %{NonlinearSolverHydro.nmaxIterations}

# preconditioner for the nonlinear solver
# 1 = block-diagonal preconditioner
# 2 = defect-correction algorithm
# 3 = algebraic Newton algorithm
iprecond = %{NonlinearSolverHydro.iprecond}

# nonlinear solver
# 101 = fixed-point iteration
# 102 = predictor-corrector fixed-point iteration
isolver = %{NonlinearSolverHydro.isolver}

# strategy for choosing the perturbation parameter in Newton's method
# 1 = NITSOL
# 2 = SQRT(EPS)
# otherwise, user-defined value
dperturbationStrategy = %{NonlinearSolverHydro.dperturbationStrategy}

# strategy for choosing the forcing term in Newton's method
# 1 = choice 1 by Eisenstat/Walker
# 2 = choice 2 by Eisenstat/Walker
# 3 = choice by Brown/Saad
# 4 = choice by Dembo/Steihaug
# otherwise, user-defined fixed value
dforcingStrategy = %{NonlinearSolverHydro.dforcingStrategy}

# check sufficient decrease condition in globalization
# 0 = apply Newton increment without globalization
# 1 = check sufficient decrease condition and perform backtracking if required
icheckSufficientDecrease = %{NonlinearSolverHydro.icheckSufficientDecrease}

# maximum number of backtracking steps
nmaxBacktrackingSteps = %{NonlinearSolverHydro.nmaxBacktrackingSteps}

# update frequency of Jacobian
iupdateFrequency = %{NonlinearSolverHydro.iupdateFrequency}

# nonlinear relaxation parameter
domega = %{NonlinearSolverHydro.domega}

# absolute tolerance for residual
depsAbs = %{NonlinearSolverHydro.depsAbs}

# relative tolerance for residual
depsRel = %{NonlinearSolverHydro.depsRel}

# relative tolerance for stagnation
depsStag = %{NonlinearSolverHydro.depsStag}

# name of linear sub-solver
ssolvername = LinearSolver


################################################################################
[LinearSolver]
 csolverType = 2
################################################################################

# level of output information:
# 0 = no output
# 1 = errors
# 2 = errors+warnings
# 3 = information
# 4 = verbose output
ioutputlevel = 2

# norm to use for defect checking
# 0 = Euclidian norm
# 1 = L1-norm
# 2 = L2-norm
# 3 = MAX-norm
iresNorm = 0

# minimum number of linear steps
nminIterations = 1

# maximum number of linear steps
nmaxIterations = 100

# type of linear solver
#  2 = Jacobi
#  4 = SOR
#  5 = SSOR
#  7 = BiCGSTAB
#  8 = FGMRES
# 11 = UMFPACK4
isolver = 2

# dimension of the Krylov subspace for FGMRES method
nkrylov = 0

# linear relaxation parameter
domega = 1.0

# absolute tolerance for residual
depsAbs = 1e-12

# relative tolerance for residual
depsRel = 1e-3

# relative tolerance for stagnation
depsStag = 0.0

# name of preconditioner
sprecondName = LinearPrecond


################################################################################
[LinearPrecond]
 csolverType = 2
################################################################################

# preconditioner for the linear single-grid solver
#  2 = Jacobi
#  4 = SOR
#  5 = SSOR
# 50 = ILU
isolver = 50

# tolerance of (M)ILU-preconditioner
depsILU = 1e-12

# size of fill-in for (M)ILU(s)
ifill = 0

# (M)ILU(s) relaxation
domega = 1.0


################################################################################
[Adaptivity]
################################################################################

# number of pre-adaptation steps
npreadapt = 0

# number of adaptation steps
nadapt = 0

# time for grid adaptivity
dtimeadapt = 0.0

# time step for grid adaptivity
dstepadapt = 0.0

# maximum number of refinement levels
nsubdividemax = 0

# adaptation strategy
# 1 = red-green
iadaptationStrategy = 1

# refinement tolerance
drefinementTolerance = 0.8

# coarsening tolerance
dcoarseningTolerance = 0.2


################################################################################
[ErrorEstimator]
################################################################################

# type of error estimator
# 1 = L2-projection
# 2 = node-based SPR
# 3 = element-based SPR
# 4 = face-based SPR
# 5 = limited gradient averaging
# 6 = second-difference indicator
ierrorestimator = 1

# type or grid indicator
# 0 = as is
# 1 = equidistribution
# 2 = logarithmic equidistribution
igridindicator = 0

# noise filter
dnoisefilter = 0.01

# absolute filter
dabsfilter = 0.0001

# number of protection layers
nprotectLayers = 5

# tolerance for protection layers
dprotectLayerTolerance = 0.8

# type of error variables
#   density
#   velocity_x
#   velocity_y
#   velocity_z
#   energy
#   pressure
#   machnumber
serrorvariable(2) =
  density
  velocity_magnitude
