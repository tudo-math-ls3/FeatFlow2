# -*- mode: sh; -*-

################################################################################
#                     Input parameters for the FEM-AFC solver                  #
#                                                                              #
#                         Steady flow past a cylinder                          #
################################################################################

benchmark       = Benchmark
inputoutput     = InputOutput
primalinviscid  = Inviscid
timestep        = Timestepping
solver          = FullMultigridSolver
adaptivity      = Adaptivity
errorest        = ErrorEstimator

################################################################################
[Benchmark]
################################################################################

# 0 = time-dependent flow, 1 = steady-state, 2 = pseudo time-dependent flow
iflowtype = 0

# treatment of coupling: 0 = segregated, 1 = coupled approach
icoupled = 1

# type of preconditioner
# =0, Galerkin; =1, scalar dissipation; =2, tensorial dissipation
iprecond = 1

# type of elements
# =1, P1 finite elements, =11 Q1 finite elements
# =2, P2 finite elements, =13 Q2 finite elements
# =-1 mixed P1/Q1 finite elements
ieltype = 11

# convert mesh to triangular mesh?
iconvToTria = 0

# type of matrix format
imatrixformat = 9

# type of system format
isystemformat = 0

# number of pre-adaptation steps
npreadapt = 0

# type of UCD output format for error
ierrorUCD = 1

# name of UCD outfile file for error
errorfile = #
gmv/pastcylinder_error

################################################################################
[InputOutput]
################################################################################

# grid parametrization
prmfile = grids/2d/rect_with_circle.prm

# grid triangulation
trifile = grids/2d/rect_with_circle.tri

# indat file
indatfile = data/euler/2d/pastcylinder.indat

# type of UCD output format
# =0, no output; =1, GMV; =2, AVS; =3, VTK
iformatUCD = 1

# time interval for UCD output
dstepUCD = 0.0

# name of UCD output file for solution
sfilenameUCDsolution = out/pastcylinder

# name of UCD output file for error
sfilenameUCDerror = out/pastcylinder_error


################################################################################
[Timestepping]
################################################################################

# level of output information:
# =0, no output; =1, errors; =2, errors+warnings;
# =3, information; =4, verbose output; >9, file output
ioutputlevel = 3

# type of time-stepping algorithm
# =5, two-level theta-scheme; =6, explicit Runge-Kutta scheme; =7, full MG
ctimestepType = 5

# implicitness parameter: Valid values of THETA are in the range [0,1].
theta = 1.0

# number of steps for multisteps scheme
multisteps = 2

# initial time for the simulation.
dinitialTime = 0.0

# final time for the simulation.
dfinalTime = 300.0

# initial time step size
dinitialStep = 0.1

# lower bound for the admissible time step
dminStep = 0.0001

# upper bound for the admissible time step
dmaxStep = 0.01

# adaptive time stepping algorithm
iadaptTimestep = 0

# tolerance for relative changes
epsRel = 0.01

# minimum factor by which time step may change
dDecreaseFactor = 0.1

# maximum factor by which 
dmaxfax = 2.0

# if the initial defect and/or right-hand side are checked, then this is
# adopted tolerance value
epsAbs = 1e-9

# flag: check initial defect vector?
icheckDEF = 1


################################################################################
[Inviscid]
################################################################################

# type of spatial stabilization: 
# =0, no stabilization (Galerkin); =1, discrete upwinding;
# =10, semi-impl. FEM-FCT; =11 semi-expl. FEM-FCT;
# =12, linearized FEM-FCT;
# =20, FEM-TVD; =21, FEM-GP;
istabilisation = 1

# type of dissipation
# =1, scalar dissipation; =2, tensorial dissipation
idissipation = 1

# mass matrix: 
# =0, use row-sum lumped mass matrix; =1, use consistent mass matrix
imass = 0

# extend Jacobian matrix
iextendedJacobian = 0


################################################################################
[FullMultigridSolver]
 csolverType = 7
################################################################################

# level of output information:
# =0, no output; =1, errors; =2, errors+warnings;
# =3, information; =4, verbose output; >9, file output
ioutputlevel = 0

# minimum multigrid level number
nlmin = 3

# maximum multigrid level number
nlmax = 3

# type of multigrid cycle
# =0, F-cylce; =1, V-cycle; =2, W-cycle, =3,=4,=5, corresponding saw tooth variants
icycle = 0

# minimum number of multigrid steps
ilmin = 1

# maximum number of multigrid steps
ilmax = 1

# nonlinear subsolver
# =1 nonlinear single-grid solver, =3 nonlinear multigrid solver
isolver = 1

# name of the subsolver
ssolvername = NonlinearSolver


################################################################################
[NonlinearMultigridSolver]
 csolverType = 3
################################################################################

# level of output information:
# =0, no output; =1, errors; =2, errors+warnings;
# =3, information; =4, verbose output; >9, file output
ioutputlevel = 0

# norm to use for defect checking
# =0, Euclidian norm; =1, L1-norm; =2, L2-norm; =3, MAX-norm
iresNorm = 0

# minimum multigrid level number
# If NLMIN = NLMAX then the nonlinear problem is solved by a single-grid solver
nlmin = 1

# maximum multigrid level number (see NLMIN)
nlmax = 1

# minimum number of linear mg steps
ilmin = 1

# maximum number of linear mg steps
ilmax = 1

# type of multigrid cycle
# =0, F-cylce; =1, V-cycle; =2, W-cycle, =3,=4,=5, corresponding saw tooth variants
icycle = 1

# nonlinear coarse grid solver
# =1, nonlinear single-grid solver, =3, nonlinear multigrid solver
isolver = 1

# name of nonlinear coarse grid solver
ssolvername = NonlinearSolver

# smoother for the nonlinear multigrid solver
# =1, nonlinear single-grid smoother, =3 nonlinear multigrid smoother
ismoother = 1

# name of nonlinear smoother
ssmoothername = NonlinearSolver

# number of presmoothing steps (if saw tooth variant is used, then no
# presmoothing steps are performed in the coarse-to-fine part of the cycle)
npresmooth = 2

# number of postsmoothing steps (if saw tooth variant is used, then no
# postsmoothing steps are performed in the coarse-to-fine part of the cycle)
npostsmooth = 2

# factor for pre/postsm. on coarser levels (On each level l, the number of
# smoothing steps is computed from SM_l=SM_L*NSFAC**(L-l), where L stands
# for the finest grid level and SM_L is the prescribed number of smoothing steps)
nsfac = 1

# nonlinear relaxation parameter
domega = 1.0

# tolerance for the multigrid solver. If TOL > 0 then the absolute value of
# the residual is required to satisfy the prescribed tolerance. If TOL < 0
# then a residual drop of ABS(TOL) is required.
tol = 1e-10

# if the initial defect and/or right-hand side are checked, then this is
# adopted tolerance value
epsAbs = 1e-20

# flag: check initial right-hand side vector?
icheckRHS = 0

# flag: check initial defect vector?
icheckDEF = 0


################################################################################
[NonlinearSolver]
 csolverType = 1
################################################################################

# level of output information:
# =0, no output; =1, errors; =2, errors+warnings;
# =3, information; =4, verbose output; >9, file output
ioutputlevel = 3

# norm to use for defect checking
# =0, Euclidian norm; =1, L1-norm; =2, L2-norm; =3, MAX-norm
iresNorm = 0

# minimum number of nonlinear steps
nminIterations = 1

# maximum number of nonlinear steps
nmaxIterations = 30

# preconditioner for the nonlinear solver
# =1, block-diagonal; =2, defect-correction; =3, algebraic Newton
iprecond = 2

# nonlinear solver
# =101, fixed-point iteration
# =102, predictor-corrector fixed-point iteration
isolver = 101

# strategy for choosing the perturbation parameter in Newton's method
# =1, NITSOL; =2, SQRT(EPS); otherwise, user-defined value
dperturbStrategy = 1

# strategy for choosing the forcing term in Newton's method
# =1, choice 1 by Eisenstat/Walker; =2, choice 2 by Eisenstat/Walker;
# =3, choice by Brown/Saad; =4, choice by Dembo/Steihaug; 
# otherwise, user-defined fixed value
dforcingstrategy = 1

# check sufficient decrease condition in globalization
# =0, apply Newton increment without globalization;
# =1, check sufficient decrease condition and perform backtracking if required
icheckSufficientDecrease = 1

# maximum number of backtracking steps
nmaxBacktrackingSteps = 5

# update frequency of Jacobian
iupdateFrequency = 0

# nonlinear relaxation parameter
domega = 1.0

# tolerance for the nonlinear solver. If TOL > 0 then the absolute value of
# the residual is required to satisfy the prescribed tolerance. If TOL < 0
# then a residual drop of ABS(TOL) is required.
tol = -1e-2

# if the initial defect and/or right-hand side are checked, then this is
# adopted tolerance value
epsAbs = 1e-12

# stagnation tolerance
tolstag = 1e-3

# flag: check initial right-hand side vector?
icheckRHS = 1

# flag: check initial defect vector?
icheckDEF = 1

# flag: check stagnation of defect vector?
icheckStagnation = 0

# name of linear sub-solver
ssolvername = LinearSolver


################################################################################
[LinearMultigridSolver]
 csolverType = 4
################################################################################

# level of output information:
# =0, no output; =1, errors; =2, errors+warnings;
# =3, information; =4, verbose output; >9, file output
ioutputlevel = 0

# norm to use for defect checking
# =0, Euclidian norm; =1, L1-norm; =2, L2-norm; =3, MAX-norm
iresNorm = 0

# minimum multigrid level number
# If NLMIN = NLMAX then the nonlinear problem is solved by a single-grid solver
nlmin = 1

# maximum multigrid level number (see NLMIN)
nlmax = 1

# minimum number of linear mg steps
ilmin = 1

# maximum number of linear mg steps
ilmax = 100

# type of multigrid cycle
# =0, F-cylce; =1, V-cycle; =2, W-cycle, =3,=4,=5, corresponding saw tooth variants
icycle = 1

# linear coarse grid solver
# =2 linear single-grid solver
isolver = 2

# name of linear coarse grid solver
ssolvername = LinearSolver

# smoother for the linear multigrid solver
# =2, linear single-grid solver, =4, linear multigrid solver
ismoother = 2

# name of smoother
ssmoothername = LinearSmoother

# number of presmoothing steps (if saw tooth variant is used, then no
# presmoothing steps are performed in the coarse-to-fine part of the cycle)
npresmooth = 2

# number of postsmoothing steps (if saw tooth variant is used, then no
# postsmoothing steps are performed in the coarse-to-fine part of the cycle)
npostsmooth = 2

# factor for pre/postsm. on coarser levels (On each level l, the number of
# smoothing steps is computed from SM_l=SM_L*NSFAC**(L-l), where L stands
# for the finest grid level and SM_L is the prescribed number of smoothing steps)
nsmoothfactor = 1

# linear relaxation parameter
domega = 1.0

# tolerance for the multigrid solver. If TOL > 0 then the absolute value of
# the residual is required to satisfy the prescribed tolerance. If TOL < 0
# then a residual drop of ABS(TOL) is required.
tol = 1e-12

# if the initial defect and/or right-hand side are checked, then this is
# adopted tolerance value
epsAbs = 1e-20

# flag: check initial right-hand side vector?
icheckRHS = 1

# flag: check initial defect vector?
icheckDEF = 1


################################################################################
[LinearSmoother]
 csolverType = 2
################################################################################

# smoother for the linear multigrid solver
# =2, Jacobi; =4, SOR; =5, SSOR; =7, BiCGSTAB; =8, FGMRES; =50, ILU
isolver = 4

# tolerance for the smoother
tol = 1e-12

# dimension of the Krylov subspace for FGMRES method
nkrylov = 15

# tolerance of (M)ILU-preconditioner
depsILU = 1e-12

# size of fill-in for (M)ILU(s)
ifill = 0

# (M)ILU(s) relaxation
domega = 1.0

# name of preconditioner
sprecondName = LinearPrecond


################################################################################
[LinearSolver]
 csolverType = 2
################################################################################

# level of output information:
# =0, no output; =1, errors; =2, errors+warnings;
# =3, information; =4, verbose output; >9, file output
ioutputlevel = 2

# norm to use for defect checking
# =0, Euclidian norm; =1, L1-norm; =2, L2-norm; =3, MAX-norm
iresNorm = 0

# minimum number of linear steps
nminIterations = 1

# maximum number of linear steps
nmaxIterations = 100

# type of linear solver
# =2, Jacobi; =4, SOR; =5, SSOR; =7, BiCGSTAB; =8, FGMRES; =11, UMFPACK4
isolver = 7

# dimension of the Krylov subspace for FGMRES method
nkrylov = 25

# linear relaxation parameter
domega = 1.0

# tolerance for the linear solver. If TOL > 0 then the absolute value of
# the residual is required to satisfy the prescribed tolerance. If TOL < 0
# then a residual drop of ABS(TOL) is required.
tol = -1e-2

# if the initial defect and/or right-hand side are checked, then this is
# adopted tolerance value
epsAbs = 1e-14

# flag: check initial right-hand side vector?
icheckRHS = 1

# flag: check initial defect vector?
icheckDEF = 1

# name of preconditioner
sprecondName = LinearPrecond


################################################################################
[LinearPrecond]
 csolverType = 2
################################################################################

# preconditioner for the linear single-grid solver
# =2, Jacobi; =4, SOR; 5=, SSOR; =50, ILU
isolver = 50

# tolerance of (M)ILU-preconditioner
depsILU = 1e-12

# size of fill-in for (M)ILU(s)
ifill = 0

# (M)ILU(s) relaxation
domega = 1.0


################################################################################
[Adaptivity]
################################################################################
# time for grid adaptivity
dtimeadapt = 10.0

# time step for grid adaptivity
dstepadapt = 0.0

# maximum number of refinement levels
nsubdividemax = 3

# adaptation strategy: 1 = red-green
iadaptationStrategy = 1

# refinement tolerance
drefinementtolerance = 1e-2

# coarsening tolerance
dcoarseningtolerance = 1e-3


################################################################################
[ErrorEstimator]
################################################################################

# type of error estimator
# =1, L2-projection, =2, node-based SPR, =3, element-based SPR,
# =4, face-based SPR, =5, limited averaging,
# =6, first-difference indicator, =7, second-difference indicator
ierrorestimator = 7

# variable for error estimator
# =1, density, =5, pressure, =6, Mach number
ierrorvariable = 1
