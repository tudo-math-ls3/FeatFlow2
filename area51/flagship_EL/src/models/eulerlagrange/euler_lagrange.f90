!##############################################################################
!# ****************************************************************************
!# <name> euler_lagrange </name>
!# ****************************************************************************


module euler_lagrange

  use afcstabilisation
  use bilinearformevaluation
  use boundary
  use boundaryfilter
  use collection
  use derivatives
  use element
  use eulerlagrange_basic
  use eulerlagrange_callback
  use eulerlagrange_callback1d
  use eulerlagrange_callback2d
  use eulerlagrange_callback3d
  use flagship_basic
  use fparser
  use fsystem
  use genoutput
  use graph
  use groupfemsystem
  use hadaptaux
  use hadaptivity
  use linearformevaluation
  use linearsystemblock
  use linearsystemscalar
  use paramlist
  use pprocerror
  use pprocgradients
  use pprocindicator
  use pprocsolution
  use problem
  use solveraux
  use spatialdiscretisation
  use statistics
  use stdoperators
  use storage
  use thermodynamics
  use timestep
  use timestepaux
  use ucd
  use triasearch
  use basicgeometry
  use geometryaux


   implicit none

   private
   public :: eulerlagrange_init
   public :: eulerlagrange_step
   public :: calculatebarycoords
   public :: findnewelement
   public :: wrongelement
   public :: moveparticle
   public :: checkboundary
   public :: calculatevolumepart

   type , public :: t_Particles
      !number of particles
      integer :: nPart 
      ! element
      integer(I32) :: h_element
      integer, dimension(:), pointer :: p_element
      ! position
      integer(I32) :: h_xpos, h_ypos, h_zpos
      real(DP), dimension(:), pointer :: p_xpos, p_ypos, p_zpos
      ! old position
      integer(I32) :: h_xpos_old, h_ypos_old, h_zpos_old
      real(DP), dimension(:), pointer :: p_xpos_old, p_ypos_old, p_zpos_old
      ! velocity
      integer(I32) :: h_xvelo, h_yvelo, h_zvelo
      real(DP), dimension(:), pointer :: p_xvelo, p_yvelo, p_zvelo
      ! old velocity
      integer(I32) :: h_xvelo_old, h_yvelo_old, h_zvelo_old
      real(DP), dimension(:), pointer :: p_xvelo_old, p_yvelo_old, p_zvelo_old
      ! velocity of the gas
      integer(I32) :: h_xvelo_gas, h_yvelo_gas, h_zvelo_gas
      real(DP), dimension(:), pointer :: p_xvelo_gas, p_yvelo_gas, p_zvelo_gas
      ! old velocity of the gas
      integer(I32) :: h_xvelo_gas_old, h_yvelo_gas_old, h_zvelo_gas_old
      real(DP), dimension(:), pointer :: p_xvelo_gas_old, p_yvelo_gas_old, p_zvelo_gas_old
      ! barycentric coordinates
      integer(I32) :: h_lambda1, h_lambda2, h_lambda3, h_lambda4
      real(DP), dimension(:), pointer :: p_lambda1, p_lambda2, p_lambda3, p_lambda4
      ! diameter and mass 
      integer(I32) :: h_diam, h_mass
      real(DP), dimension(:), pointer :: p_diam, p_mass
      ! midpoints of the element 
      integer(I32) :: h_midpoints_el
      real(DP), dimension(:,:), pointer :: p_midpoints_el
    end type t_Particles


    contains

SUBROUTINE eulerlagrange_init(rparlist,p_rproblemLevel,rsolution,rtimestep,rcollection,rParticles)

    ! parameterlist
    type(t_parlist), intent(inout) :: rparlist

    ! collection structure
    type(t_collection), intent(inout) :: rcollection

    ! time-stepping structure
    type(t_timestep), intent(inout) :: rtimestep

    ! primal solution vector
    type(t_vectorBlock), intent(inout), target :: rsolution

    ! particles
    type(t_Particles), intent(inout) :: rParticles

    ! local variables
    ! pointer to the triangulation
    type(t_triangulation), pointer :: p_rtriangulation

    ! pointer to the multigrid level
    type(t_problemLevel), pointer :: p_rproblemLevel

    ! pointer to the coordinates of the vertices
    !
    ! A list of all corner(!)-vertices of the elements in the triangulation.
    ! Handle to 
    !       p_RcornerCoordinates = array [1..ndim,1..NVT] of double
    ! with
    !   p_DvertexCoords(1,.) = X-coordinate.
    ! for 1D meshes,
    !   p_DvertexCoords(1,.) = X-coordinate.
    !   p_DvertexCoords(2,.) = Y-coordinate.
    ! for 2D meshes and
    !   p_DvertexCoords(1,.) = X-coordinate.
    !   p_DvertexCoords(2,.) = Y-coordinate.
    !   p_DvertexCoords(3,.) = Z-coordinate.
    ! for 3D meshes.
    ! This is a handle to the old DCORVG-array.
    !
    ! Note that the array may be longer than NVT in general!
    ! (May happen in case of a mesh hierarchy generated by a 2-level
    ! refinement, where the coordinates of the points on the
    ! coarser levels are contained in te coordinates of the
    ! finer levels.)
    ! In such a case, only the first NVT n-tuples in this array are valid!
    real(DP), dimension(:,:), pointer :: p_DvertexCoords

    ! pointer to the vertices adjacent to an element
    !
    ! Handle to h_IverticesAtElement=array [1..NVE,1..NEL] of integer
    ! For each element the node numbers of the corner-vertices
    ! in mathematically positive sense.
    ! On pure triangular meshes, there is NVE=3. On mixed or pure quad
    ! meshes, there is NVE=4. In this case, there is 
    ! IverticesAtElement(4,.)=0 for a triangle in a quad mesh.
    ! This is a handle to the old KVERT array.
    integer, dimension(:,:), pointer :: p_IverticesAtElement



    ! pointer to nodal property array. 
    !
    ! Handle to 
    !       p_InodalProperty=array [1..NVT+NMT+NAT] of integer.
    ! p_InodalProperty(i) defines for each vertex i=(1..NVT),
    ! each edge i=(NVT+1..NVT+NMT) and face i=NVT+NMT+1..NVT+NMT+NAT
    ! its function inside of the geometry.
    ! Generally said, the range of the p_InodalProperty-array 
    ! characterizes the type of the node (=vertex/edge):
    ! = 0    : The vertex/edge is an inner vertex/edge
    ! > 0    : The vertex/edge is a boundary vertex/edge on the real
    !           boundary. KNPR(.) defines the number of the boundary
    !           component.
    ! This is the old KNPR-array, slightly modified for edges and
    ! hanging nodes.
    !
    ! In case there are hanging nodes in the mesh, this array
    ! has a special meaning for all hanging vertices and all edges
    ! containing hanging vertices.  Values < 0 indicate hanging
    ! vertices at an edge. 
    ! Let iedgeC (NVT+1..NVT+NMT) be the number of
    ! a a 'full' edge containing the hanging vertex jvertex. 
    ! Let iedge be one of the sub-edges inside of edge iedgeC.
    ! Then there is:
    !   p_InodalProperty(jvertex) = -iedgeC
    !   p_InodalProperty(iedge)   = -iedgeC
    !   p_InodalProperty(iedgeC)  = -jvertex
    ! Let kfaceC (NVT+NMT+1..NVT+NMT+NAT) be the number of a 'full' face
    ! containing the hanging vertex jvertex. 
    ! Let kface be the number of a one of the subfaces inside
    ! the face kfaceC. Let iedge be the number of one of the sub-edges
    ! inside face kfaceC.
    ! Then there is:
    !   p_InodalProperty(jvertex) = -kfaceC
    !   p_InodalProperty(kface)   = -kfaceC
    !   p_InodalProperty(iedge)   = -kfaceC
    !   p_InodalProperty(kfaceC)  = -jvertex
    ! A hanging vertex is either the midpoint of a face or of an edge,
    ! therefore this assignment is unique due to the range of the number.
    ! 'Hanging edges' (only appear in 3D) without a hanging vertex
    ! in the center of an edge/face are not supported.
    !integer, dimension(:), pointer :: p_InodalProperty

 
  ! local variables
  integer :: ivt, iPart

  real(DP) :: random1, random2

  ! midpoints of the elements
  integer(I32) :: h_midpoints
  real(DP), dimension(:,:), pointer :: p_midpoints_el
  integer, dimension(2) :: md_el_length

  ! startingpostions of the particles
  real(DP) :: partxmin, partxmax, partymin, partymax

  ! velocity, mass and diameter of the particles
  real(DP) :: velopartx, veloparty, particlediam, particlemass

  ! gravity
  real(DP) :: gravityx, gravityy

  ! quantity of particles
  integer :: nPart
  
  ! boundarybehaviour
  integer :: boundbehav

  ! kinematic viscosity of the gas
  real(DP) :: gas_nu
  
  ! Set pointer to triangulation
  p_rtriangulation => p_rproblemLevel%rtriangulation
  
  
  ! get quantity of particles
  call parlst_getvalue_int(rparlist, 'Eulerlagrange', "nPart", nPart)

  rParticles%npart = nPart
  
  ! storage_new (scall, sname, isize, ctype, ihandle, cinitNewBlock)
  call storage_new ('euler_lagrange', 'Particle:element', rParticles%npart, ST_INT, rParticles%h_element, &
                            ST_NEWBLOCK_NOINIT)

  call storage_new ('euler_lagrange', 'Particle:lambda1', rParticles%npart, ST_DOUBLE, rParticles%h_lambda1, &
                            ST_NEWBLOCK_NOINIT)
  call storage_new ('euler_lagrange', 'Particle:lambda2', rParticles%npart, ST_DOUBLE, rParticles%h_lambda2, &
                            ST_NEWBLOCK_NOINIT)
  call storage_new ('euler_lagrange', 'Particle:lambda3', rParticles%npart, ST_DOUBLE, rParticles%h_lambda3, &
                            ST_NEWBLOCK_NOINIT)
  call storage_new ('euler_lagrange', 'Particle:lambda4', rParticles%npart, ST_DOUBLE, rParticles%h_lambda4, &
                            ST_NEWBLOCK_NOINIT)

  call storage_new ('euler_lagrange', 'Particle:diameter', rParticles%npart, ST_DOUBLE, rParticles%h_diam, &
                            ST_NEWBLOCK_NOINIT)
  call storage_new ('euler_lagrange', 'Particle:mass', rParticles%npart, ST_DOUBLE, rParticles%h_mass, &
                            ST_NEWBLOCK_NOINIT)

  call storage_new ('euler_lagrange', 'Particle:xpos', rParticles%npart, ST_DOUBLE, rParticles%h_xpos, &
                            ST_NEWBLOCK_NOINIT)
  call storage_new ('euler_lagrange', 'Particle:ypos', rParticles%npart, ST_DOUBLE, rParticles%h_ypos, &
                            ST_NEWBLOCK_NOINIT)
  call storage_new ('euler_lagrange', 'Particle:zpos', rParticles%npart, ST_DOUBLE, rParticles%h_zpos, &
                            ST_NEWBLOCK_NOINIT)

  call storage_new ('euler_lagrange', 'Particle:xpos_old', rParticles%npart, ST_DOUBLE, rParticles%h_xpos_old, &
                            ST_NEWBLOCK_NOINIT)
  call storage_new ('euler_lagrange', 'Particle:ypos_old', rParticles%npart, ST_DOUBLE, rParticles%h_ypos_old, &
                            ST_NEWBLOCK_NOINIT)
  call storage_new ('euler_lagrange', 'Particle:zpos_old', rParticles%npart, ST_DOUBLE, rParticles%h_zpos_old, &
                            ST_NEWBLOCK_NOINIT)

  call storage_new ('euler_lagrange', 'Particle:xvelo', rParticles%npart, ST_DOUBLE, rParticles%h_xvelo, &
                            ST_NEWBLOCK_NOINIT)
  call storage_new ('euler_lagrange', 'Particle:yvelo', rParticles%npart, ST_DOUBLE, rParticles%h_yvelo, &
                            ST_NEWBLOCK_NOINIT)
  call storage_new ('euler_lagrange', 'Particle:zvelo', rParticles%npart, ST_DOUBLE, rParticles%h_zvelo, &
                            ST_NEWBLOCK_NOINIT)

  call storage_new ('euler_lagrange', 'Particle:xvelo_old', rParticles%npart, ST_DOUBLE, rParticles%h_xvelo_old, &
                            ST_NEWBLOCK_NOINIT)
  call storage_new ('euler_lagrange', 'Particle:yvelo_old', rParticles%npart, ST_DOUBLE, rParticles%h_yvelo_old, &
                            ST_NEWBLOCK_NOINIT)
  call storage_new ('euler_lagrange', 'Particle:zvelo_old', rParticles%npart, ST_DOUBLE, rParticles%h_zvelo_old, &
                            ST_NEWBLOCK_NOINIT)

  call storage_new ('euler_lagrange', 'Particle:xvelo_gas', rParticles%npart, ST_DOUBLE, rParticles%h_xvelo_gas, &
                            ST_NEWBLOCK_NOINIT)
  call storage_new ('euler_lagrange', 'Particle:yvelo_gas', rParticles%npart, ST_DOUBLE, rParticles%h_yvelo_gas, &
                            ST_NEWBLOCK_NOINIT)
  call storage_new ('euler_lagrange', 'Particle:zvelo_gas', rParticles%npart, ST_DOUBLE, rParticles%h_zvelo_gas, &
                            ST_NEWBLOCK_NOINIT)

  call storage_new ('euler_lagrange', 'Particle:xvelo_gas_old', rParticles%npart, ST_DOUBLE, rParticles%h_xvelo_gas_old, &
                            ST_NEWBLOCK_NOINIT)
  call storage_new ('euler_lagrange', 'Particle:yvelo_gas_old', rParticles%npart, ST_DOUBLE, rParticles%h_yvelo_gas_old, &
                            ST_NEWBLOCK_NOINIT)
  call storage_new ('euler_lagrange', 'Particle:zvelo_gas_old', rParticles%npart, ST_DOUBLE, rParticles%h_zvelo_gas_old, &
                            ST_NEWBLOCK_NOINIT)

   md_el_length(1)=2
   md_el_length(2)=p_rtriangulation%NEL

   ! midpoints of the elements
   call storage_new ('euler_lagrange', 'Elements:midpoints', md_el_length, ST_DOUBLE, rParticles%h_midpoints_el, &
                            ST_NEWBLOCK_NOINIT)
   
   call storage_getbase_double (rParticles%h_xpos, rParticles%p_xpos)
   call storage_getbase_double (rParticles%h_ypos, rParticles%p_ypos)
   call storage_getbase_double (rParticles%h_zpos, rParticles%p_zpos)
   call storage_getbase_double (rParticles%h_xpos_old, rParticles%p_xpos_old)
   call storage_getbase_double (rParticles%h_ypos_old, rParticles%p_ypos_old)
   call storage_getbase_double (rParticles%h_zpos_old, rParticles%p_zpos_old)
   call storage_getbase_double (rParticles%h_xvelo, rParticles%p_xvelo)
   call storage_getbase_double (rParticles%h_yvelo, rParticles%p_yvelo)
   call storage_getbase_double (rParticles%h_zvelo, rParticles%p_zvelo)
   call storage_getbase_double (rParticles%h_xvelo_old, rParticles%p_xvelo_old)
   call storage_getbase_double (rParticles%h_yvelo_old, rParticles%p_yvelo_old)
   call storage_getbase_double (rParticles%h_zvelo_old, rParticles%p_zvelo_old)
   call storage_getbase_double (rParticles%h_xvelo_gas, rParticles%p_xvelo_gas)
   call storage_getbase_double (rParticles%h_yvelo_gas, rParticles%p_yvelo_gas)
   call storage_getbase_double (rParticles%h_zvelo_gas, rParticles%p_zvelo_gas)
   call storage_getbase_double (rParticles%h_xvelo_gas_old, rParticles%p_xvelo_gas_old)
   call storage_getbase_double (rParticles%h_yvelo_gas_old, rParticles%p_yvelo_gas_old)
   call storage_getbase_double (rParticles%h_zvelo_gas_old, rParticles%p_zvelo_gas_old)
   call storage_getbase_int (rParticles%h_element, rParticles%p_element)
   call storage_getbase_double (rParticles%h_lambda1, rParticles%p_lambda1)
   call storage_getbase_double (rParticles%h_lambda2, rParticles%p_lambda2)
   call storage_getbase_double (rParticles%h_lambda3, rParticles%p_lambda3)
   call storage_getbase_double (rParticles%h_lambda4, rParticles%p_lambda4)
   call storage_getbase_double (rParticles%h_diam, rParticles%p_diam)
   call storage_getbase_double (rParticles%h_mass, rParticles%p_mass)

   call storage_getbase_double2D (rParticles%h_midpoints_el, rParticles%p_midpoints_el)
  
   ! Set pointer to coordinate vector
   call storage_getbase_double2D(&
        p_rtriangulation%h_DvertexCoords, p_DvertexCoords)

   ! Set pointer to vertices at element
   call storage_getbase_int2D(&
        p_rtriangulation%h_IverticesAtElement, p_IverticesAtElement)

   ! Stores the midpoint for each element
    DO ivt=1,p_rtriangulation%NEL

      rParticles%p_midpoints_el(1,ivt)= &
                                (p_DvertexCoords(1,p_IverticesAtElement(1,ivt))+&
                                 p_DvertexCoords(1,p_IverticesAtElement(2,ivt))+&
                                 p_DvertexCoords(1,p_IverticesAtElement(3,ivt)))/3

      rParticles%p_midpoints_el(2,ivt)= &
                                (p_DvertexCoords(2,p_IverticesAtElement(1,ivt))+&
                                 p_DvertexCoords(2,p_IverticesAtElement(2,ivt))+&
                                 p_DvertexCoords(2,p_IverticesAtElement(3,ivt)))/3

    END DO

    ! get values for the startingpositions of the particles
    call parlst_getvalue_double(rparlist, 'Eulerlagrange', "xmin", partxmin)
    call parlst_getvalue_double(rparlist, 'Eulerlagrange', "xmax", partxmax)
    call parlst_getvalue_double(rparlist, 'Eulerlagrange', "ymin", partymin)
    call parlst_getvalue_double(rparlist, 'Eulerlagrange', "ymax", partymax)
 
    ! get particlevelocity
    call parlst_getvalue_double(rparlist, 'Eulerlagrange', "velopartx", velopartx)
    call parlst_getvalue_double(rparlist, 'Eulerlagrange', "veloparty", veloparty)

    ! get particle-mass and diameter
    call parlst_getvalue_double(rparlist, 'Eulerlagrange', "particlemass", particlemass)
    call parlst_getvalue_double(rparlist, 'Eulerlagrange', "particlediam", particlediam)

    ! get values for gravity
    call parlst_getvalue_double(rparlist, 'Eulerlagrange', "gravityx", gravityx)
    call parlst_getvalue_double(rparlist, 'Eulerlagrange', "gravityy", gravityy)

    ! get value of kinematic viscosity
    call parlst_getvalue_double(rparlist, 'Eulerlagrange', "gas_nu", gas_nu)

    ! get boundarybehaviour
    call parlst_getvalue_int(rparlist, 'Eulerlagrange', "boundbehav", boundbehav)
  
    ! initialize data for each particle
    DO iPart=1,rParticles%npart
  
  		!Hole Zufallszahl
		CALL RANDOM_NUMBER(random1)
		CALL RANDOM_NUMBER(random2)
    
        rParticles%p_xpos(iPart)= partxmin + random1*(partxmax - partxmin)
        rParticles%p_ypos(iPart)= partymin + random2*(partymax - partymin)
        rParticles%p_zpos(iPart)= 0.2d0
        rParticles%p_xpos_old(iPart)= velopartx
        rParticles%p_ypos_old(iPart)= veloparty
        rParticles%p_zpos_old(iPart)= 0.2d0
        rParticles%p_diam(iPart)= particlediam
        rParticles%p_mass(iPart)= particlemass
        rParticles%p_element(iPart)= 1
        rParticles%npart = nPart
        
        ! Find the start element for each particle
        call findnewelement(rparlist,p_rproblemLevel,rsolution,rtimestep,rcollection,rParticles,iPart)

        ! calculate barycentric coordinates
        call calculatebarycoords(rparlist,p_rproblemLevel,rsolution,rtimestep,rcollection,rParticles,iPart)
write(*,*) rParticles%p_lambda1(iPart), rParticles%p_lambda2(iPart), rParticles%p_lambda3(iPart)
        ! wrong element
        IF ((abs(rParticles%p_lambda1(iPart))+abs(rParticles%p_lambda2(iPart))+&
                  abs(rParticles%p_lambda3(iPart))-1) .GE. 0.00001) THEN
            call wrongelement(rparlist,p_rproblemLevel,rsolution,rtimestep,rcollection,rParticles,iPart)
        END IF

    END DO


END SUBROUTINE eulerlagrange_init

SUBROUTINE eulerlagrange_step(rparlist,p_rproblemLevel,rsolution,rtimestep,rcollection,rParticles)

    ! parameterlist
    type(t_parlist), intent(inout) :: rparlist

    ! collection structure
    type(t_collection), intent(inout) :: rcollection

    ! time-stepping structure
    type(t_timestep), intent(inout) :: rtimestep

    ! particles
    type(t_Particles), intent(inout) :: rParticles

    ! primal solution vector
    type(t_vectorBlock), intent(inout), target :: rsolution

    ! Pointer to the multigrid level
    type(t_problemLevel), pointer :: p_rproblemLevel
    
    ! pointer to the triangulation
    type(t_triangulation), pointer :: p_rtriangulation
    
    ! current particlenumber
    integer :: iPart

    ! Set pointer to triangulation
    p_rtriangulation => p_rproblemLevel%rtriangulation

    do iPart = 1, rParticles%nPart

      ! subroutine to find the element with the particle
      ! check if particle is in the wrong element
      !call findnewelement(rparlist,p_rproblemLevel,rsolution,&
                            !rtimestep,rcollection,rParticles,iPart)


        ! wrong element
        !IF (((ABS(rParticles%p_lambda1(iPart))+rParticles%p_lambda2(iPart))+&
        !          rParticles%p_lambda3(iPart)-1) .GE. 0.00001) THEN
        !    call wrongelement(rparlist,p_rproblemLevel,rsolution,rtimestep,rcollection,rParticles,iPart)
        !END IF

        ! subroutine to compute the new position of the particles
        !call moveparticle(rparlist,p_rproblemLevel,rsolution,rtimestep,rcollection,rParticles,iPart)

    end do


    ! subroutine to calculate the volume part of the particles
    !call calculatevolumepart(rparlist,p_rproblemLevel,rsolution,rtimestep,rcollection,rParticles)

END SUBROUTINE eulerlagrange_step


!************ SUBROUTINE to calculate the barycentric coordinates ******************************************
!*

SUBROUTINE calculatebarycoords(rparlist,p_rproblemLevel,rsolution,rtimestep,rcollection,rParticles,iPart)

    ! parameterlist
    type(t_parlist), intent(inout) :: rparlist

    ! collection structure
    type(t_collection), intent(inout) :: rcollection

    ! time-stepping structure
    type(t_timestep), intent(inout) :: rtimestep

    ! particles
    type(t_Particles), intent(inout) :: rParticles

     ! primal solution vector
    type(t_vectorBlock), intent(inout), target :: rsolution
    
    ! current number of particle
    integer, intent(inout) :: iPart

    ! Pointer to the multigrid level
    type(t_problemLevel), pointer :: p_rproblemLevel

    ! pointer to the triangulation
    type(t_triangulation), pointer :: p_rtriangulation

    ! pointer to vertices at each element
    integer, dimension(:,:), pointer :: p_IverticesAtElement

    ! pointer to the vertex coordinates
    real(DP), dimension(:,:), pointer :: p_DvertexCoords

    ! current element
    integer :: currentElement

    ! coordinates of the vertices of the actual element
    real(DP), dimension(2,3) :: vert_coord

    ! determinates
    real(DP) :: det_A, det_A1, det_A2, det_A3

    ! local variables
    integer :: ivt

    ! Set pointer to triangulation
    p_rtriangulation => p_rproblemLevel%rtriangulation

    ! Get vertices at element
    call storage_getbase_int2D(&
        p_rtriangulation%h_IverticesAtElement, p_IverticesAtElement)

    ! Get coordinates of the vertices
    call storage_getbase_double2D(&
        p_rtriangulation%h_DvertexCoords, p_DvertexCoords)

    ! store current element
    currentElement = rParticles%p_element(iPart)

    ! store coordinates of the vertices
    DO ivt=1,3

      vert_coord(1,ivt)= p_DvertexCoords(1,p_IverticesAtElement(ivt,currentElement))
      vert_coord(2,ivt)= p_DvertexCoords(2,p_IverticesAtElement(ivt,currentElement))

    END DO

    ! compute determinate
    !	    1 x1 y1
    !    A=	1 x2 y2
    !		1 x3 y3
    ! detA=x2y3+x1y2+x3y1-x2y1-x3y2-x1y3
    det_A=  vert_coord(1,2) * vert_coord(2,3)+&
            vert_coord(1,1) * vert_coord(2,2)+&
            vert_coord(1,3) * vert_coord(2,1)-&
            vert_coord(1,2) * vert_coord(2,1)-&
            vert_coord(1,3) * vert_coord(2,2)-&
            vert_coord(1,1) * vert_coord(2,3)

    ! calculate barycentric coorinates (lambda1,lambda2,lambda3)
    ! lambda1
    !		1 x  y
    !   A1=	1 x2 y2
    !		1 x3 y3
    ! detA1=x2y3+xy2+x3y-x2y-x3y2-xy3
    det_A1= vert_coord(1,2)         * vert_coord(2,3)+&
            rParticles%p_xpos(iPart)* vert_coord(2,2)+&
            vert_coord(1,3)         * rParticles%p_ypos(iPart)-&
            vert_coord(1,2)         * rParticles%p_ypos(iPart)-&
            vert_coord(1,3)         * vert_coord(2,2)-&
            rParticles%p_xpos(iPart)* vert_coord(2,3)
 
    !lambda1=|det_A1/det_A|
    rParticles%p_lambda1(iPart)= abs(det_A1/det_A)

    ! lambda2
    !		1 x1 y1
    !   A2=	1 x  y
    !		1 x3 y3
    ! detA2=xy3+x1y+x3y1-xy1-x3y-x1y3
    det_A2= rParticles%p_xpos(iPart)* vert_coord(2,3)+&
            vert_coord(1,1)         * rParticles%p_ypos(iPart)+&
            vert_coord(1,3)         * vert_coord(2,1)-&
            rParticles%p_xpos(iPart)* vert_coord(2,1)-&
            vert_coord(1,3)         * rParticles%p_ypos(iPart)-&
            vert_coord(1,1)         * vert_coord(2,3)

    !lambda2=|det_A2/det_A|
    rParticles%p_lambda2(iPart)= abs(det_A2/det_A)

    ! lambda3
    !		1 x1 y1
    !   A3=	1 x2 y2
    !		1 x  y
    ! detA3=x2y+x1y2+xy1-x2y1-xy2-x1y
    det_A3= vert_coord(1,2)         * rParticles%p_ypos(iPart)+&
            vert_coord(1,1)         * vert_coord(2,2)+&
            rParticles%p_xpos(iPart)* vert_coord(2,1)-&
            vert_coord(1,2)         * vert_coord(2,1)-&
            rParticles%p_xpos(iPart)* vert_coord(2,2)-&
            vert_coord(1,1)         * rParticles%p_ypos(iPart)

    ! lambda3=|det_A3/det_A|
    rParticles%p_lambda3(iPart)= abs(det_A3/det_A)


END SUBROUTINE calculatebarycoords

    !*
    !**********************************************************************************************************************


    !******************************* SUBROUTINE to find the right element *************************************************
    !*

SUBROUTINE findnewelement(rparlist,p_rproblemLevel,rsolution,rtimestep,rcollection,rParticles,iPart)

    ! parameterlist
    type(t_parlist), intent(inout) :: rparlist

    ! collection structure
    type(t_collection), intent(inout) :: rcollection

    ! time-stepping structure
    type(t_timestep), intent(inout) :: rtimestep

    ! particles
    type(t_Particles), intent(inout) :: rParticles

    ! primal solution vector
    type(t_vectorBlock), intent(inout), target :: rsolution
    
    ! pointer to the multigrid level
    type(t_problemLevel), pointer :: p_rproblemLevel

    ! pointer to the triangulation
    type(t_triangulation), pointer :: p_rtriangulation


    ! pointer to the neighbour elements adjacent to an element
    !
    ! Handle to 
    !       p_IneighboursAtElement = array [1..TRIA_MAXNME2D,1..NEL] of integer
    ! For each element, the numbers of adjacent elements
    ! in mathematically positive sense, meeting the element in an edge.
    ! p_RneighbourElement(IEL)\%Ineighbours(.) describes the elements adjacent 
    ! to IEL along the edges (p_RedgesOnElement(IEL)\%Iedges(.)-NVT).
    ! This is the old KADJ array.
    !
    ! Note:  For meshes with hanging vertices, this array is slightly
    ! modified. For 'big' elements this array contains the element
    ! numbers of the 'first' adjacent element via an edge/face.
    ! Note: To access all elements adjacent to an element via a
    ! hanging vertex, calculate the vertex number of the hanging
    ! vertex via InodalProperty and access all adjacent elements.
    ! For small 'hanging' elements, this array contains as usual
    ! the number of the 'big' adjacent element(s).
    integer, dimension(:,:), pointer :: p_IneighboursAtElement


    ! pointer to the coordinates of the vertices
    !
    ! A list of all corner(!)-vertices of the elements in the triangulation.
    ! Handle to 
    !       p_RcornerCoordinates = array [1..ndim,1..NVT] of double
    ! with
    !   p_DvertexCoords(1,.) = X-coordinate.
    ! for 1D meshes,
    !   p_DvertexCoords(1,.) = X-coordinate.
    !   p_DvertexCoords(2,.) = Y-coordinate.
    ! for 2D meshes and
    !   p_DvertexCoords(1,.) = X-coordinate.
    !   p_DvertexCoords(2,.) = Y-coordinate.
    !   p_DvertexCoords(3,.) = Z-coordinate.
    ! for 3D meshes.
    ! This is a handle to the old DCORVG-array.
    !
    ! Note that the array may be longer than NVT in general!
    ! (May happen in case of a mesh hierarchy generated by a 2-level
    ! refinement, where the coordinates of the points on the
    ! coarser levels are contained in te coordinates of the
    ! finer levels.)
    ! In such a case, only the first NVT n-tuples in this array are valid!
    real(DP), dimension(:,:), pointer :: p_DvertexCoords

    ! pointer to the vertices adjacent to an element
    !
    ! Handle to h_IverticesAtElement=array [1..NVE,1..NEL] of integer
    ! For each element the node numbers of the corner-vertices
    ! in mathematically positive sense.
    ! On pure triangular meshes, there is NVE=3. On mixed or pure quad
    ! meshes, there is NVE=4. In this case, there is 
    ! IverticesAtElement(4,.)=0 for a triangle in a quad mesh.
    ! This is a handle to the old KVERT array.
    integer, dimension(:,:), pointer :: p_IverticesAtElement

   
    ! current number of particle
    integer, intent(inout) :: iPart
  
    ! position of the element
    real(DP), dimension(2) :: particlepos

    ! element number
    integer :: iel
 
    ! particle is in element 
    logical :: binside
    
    ! search mode
    character(LEN=15) :: searchmode

    ! variables for midpoints_el
	real(DP), dimension(1:5) :: distances
	integer :: i, adj, minl, ite, mittelelement
	integer, parameter :: itemax = 10000
	real(DP) :: distToMid

    ! Set pointer to triangulation
    p_rtriangulation => p_rproblemLevel%rtriangulation
   
    ! get vertices at element
    call storage_getbase_int2D(&
        p_rtriangulation%h_IverticesAtElement, p_IverticesAtElement)

    ! get coordinates for elements
    call storage_getbase_double2d (&
        p_rtriangulation%h_DvertexCoords,p_DvertexCoords)
        
    ! get neighboured elements
    call storage_getbase_int2D(&
        p_rtriangulation%h_IneighboursAtElement, p_IneighboursAtElement)
      
    ! set particles position
    particlepos(1)= rParticles%p_xpos(iPart)
    particlepos(2)= rParticles%p_ypos(iPart)
    
    ! Get searchmode (brute force, raytrace, etc.)  
    call parlst_getvalue_string(rparlist, 'Eulerlagrange', "search", searchmode)

    select case(trim(searchmode))
    case('bruteforce')
        ! CHANGED IN KERNEL (for triangles)
        call tsrch_getElem_BruteForce(particlepos,p_DvertexCoords,p_IverticesAtElement,iel)
    case('raytrace2D')
        !call tsrch_getElem_raytrace2D(&
        !        Dpoint,rtriangulation,iel, iresult,ilastElement,ilastEdge,imaxIterations)
    case('midpoint')

	    distToMid = 10000.0d0

	    gotoNextElm: do ite = 1, itemax
	    
		    ! calculate the distances to the midpoints
		    distances = 10000.0d0
   
		    do i = 1, 3 
		      if (p_IneighboursAtElement(i,rParticles%p_element(iPart)) > 0) then
			    adj = p_IneighboursAtElement(i,rParticles%p_element(iPart))
			    distances(i+1) = (rParticles%p_xpos(iPart)-rParticles%p_midpoints_el(1,adj))**2.0d0 +&
								 (rParticles%p_ypos(iPart)-rParticles%p_midpoints_el(2,adj))**2.0d0
			  end if
		    end do
		    
		    distances(1) = (rParticles%p_xpos(iPart)-&
		                        rParticles%p_midpoints_el(1,rParticles%p_element(iPart)))**2.0d0+&
		                   (rParticles%p_ypos(iPart)-&
		                        rParticles%p_midpoints_el(2,rParticles%p_element(iPart)))**2.0d0
		
		    ! Position des geringsten Abstandes
		    minl = minloc(distances,1)

		    ! Teste, ob Abbruch (Abstand wird nicht mehr kleiner)
		    if (minl .EQ. 1) exit gotoNextElm

		    ! Nummer des Elements, dessen Mittelpkt den geringsten Abstand zum Partikel hat
		    adj = p_IneighboursAtElement(minl-1,rParticles%p_element(iPart))

		    ! Setze neues Element
		    rParticles%p_element(iPart) = adj
		    distToMid = distances(minl)
		    
	    end do gotoNextElm
	    
    case DEFAULT
        call output_line('Invalid search mode!',&
                     OU_CLASS_WARNING,OU_MODE_STD,'flagship')
        call sys_halt()
    end select

END SUBROUTINE findnewelement

!*
!**********************************************************************************************************************


!****************************************** SUBROUTINE for wrong elements *********************************************
!*

SUBROUTINE wrongelement(rparlist,p_rproblemLevel,rsolution,rtimestep,rcollection,rParticles,iPart)

    ! parameterlist
    type(t_parlist), intent(inout) :: rparlist

    ! collection structure
    type(t_collection), intent(inout) :: rcollection

    ! time-stepping structure
    type(t_timestep), intent(inout) :: rtimestep

    ! particles
    type(t_Particles), intent(inout) :: rParticles

     ! primal solution vector
    type(t_vectorBlock), intent(inout), target :: rsolution
    
    ! current number of particle
    integer, intent(inout) :: iPart

      ! pointer to elements adjacent to an edge. (Only 2D).
    !
    ! Handle to 
    !       p_IelementsAtEdge = array [1..2,1..NMT] of integer.
    ! The numbers of the two elements adjacent to an edge IMT in 2D. 
    ! For boundary edges, p_IelementsOnEdge(2,IMT) is set to 0.
    ! This is the old KMEL array.
    integer, dimension(:,:), pointer :: p_IelementsAtEdge

    ! pointer to array containing the elements adjacent to a vertex.
    !
    ! Handle to 
    !       p_IelementsAtVertex = array(1..*) of integer
    ! p_IelementsAtVertex ( p_IelementsAtVertexIdx(IVT)..p_IelementsAtVertexIdx(IVT+1)-1 )
    ! contains the number of the adjacent element in a vertex.
    ! This replaces the old KVEL array.
    !
    ! Note: For hanging vertices, this array contains only those
    ! elements which are 'corner adjacent' to a vertex (i.e. the 'smaller' elements).
    ! The 'big' elements adjacent to the edge which the hanging vertex
    ! is a midpoint of are not part of the vertex neighbourhood
    ! in this array.
    integer, dimension(:), pointer :: p_IelementsAtVertex

    ! Pointer to the multigrid level
    type(t_problemLevel), pointer :: p_rproblemLevel

    ! pointer to the triangulation
    type(t_triangulation), pointer :: p_rtriangulation

    ! pointer to the multigrid level
    type(t_problemLevel), pointer :: rproblemLevel

   ! Set pointer to triangulation
    p_rtriangulation => rproblemLevel%rtriangulation
 
    !call storage_getbase_int(p_rtriangulation%h_IelementsAtVertex, p_IelementsAtVertex)

    if (((ABS(rParticles%p_lambda1(iPart))+rParticles%p_lambda2(iPart))+&
              rParticles%p_lambda3(iPart)-1) .GE. 0.00001) then
      write(*,*) 'wrong element'
    end if


END SUBROUTINE wrongelement

!*
!**********************************************************************************************************************

!*************************************** SUBROUTINE to move the particle **********************************************
!*

SUBROUTINE moveparticle(rparlist,p_rproblemLevel,rsolution,rtimestep,rcollection,rParticles,iPart)

    ! parameterlist
    type(t_parlist), intent(inout) :: rparlist

    ! collection structure
    type(t_collection), intent(inout) :: rcollection

    ! time-stepping structure
    type(t_timestep), intent(inout) :: rtimestep

    ! particles
    type(t_Particles), intent(inout) :: rParticles

     ! primal solution vector
    type(t_vectorBlock), intent(inout), target :: rsolution

    ! Pointer to the multigrid level
    type(t_problemLevel), pointer :: p_rproblemLevel
    
    ! current number of particle
    integer, intent(inout) :: iPart


    ! pointer to elements adjacent to the boundary. 
    !
    ! Handle to 
    !       p_IelementsAtBoundary = array [1..NVBD] of integer.
    ! This array contains a list of all elements on the (real) boundary
    ! in mathematically positive sense.
    ! p_IelementsAtBoundary(i) is the element adjacent to edge
    ! h_IedgesAtBoundary - therefore one element number might appear
    ! more than once in this array!
    ! The boundary elements of boundary component i are saved at
    !        p_IboundaryCpIdx(i)..p_IboundaryCpIdx(i+1)-1.
    ! This is the old KEBD array.
    integer, dimension(:), pointer :: p_IelementsAtBoundary

    ! subroutine to check if the element is at the boundary
    call CheckBoundary(rparlist,p_rproblemLevel,rsolution,rtimestep,rcollection,rParticles,iPart)


END SUBROUTINE moveparticle

!*
!**********************************************************************************************************************

!****************************************** SUBROUTINE to check the boundary ******************************************
!*

SUBROUTINE checkboundary(rparlist,p_rproblemLevel,rsolution,rtimestep,rcollection,rParticles,iPart)


    ! parameterlist
    type(t_parlist), intent(inout) :: rparlist

    ! collection structure
    type(t_collection), intent(inout) :: rcollection

    ! time-stepping structure
    type(t_timestep), intent(inout) :: rtimestep

    ! particles
    type(t_Particles), intent(inout) :: rParticles

     ! primal solution vector
    type(t_vectorBlock), intent(inout), target :: rsolution

    ! Pointer to the multigrid level
    type(t_problemLevel), pointer :: p_rproblemLevel
    
    ! current number of particle
    integer, intent(inout) :: iPart

    
    ! pointer to vertices on boundary. 
    !
    ! Handle to 
    !       p_IverticesAtBoundary = array [1..NVBD] of integer.
    ! This array contains a list of all vertices on the (real) boundary
    ! in mathematically positive sense.
    ! The boundary vertices of boundary component i are saved at
    !        p_IboundaryCpIdx(i)..p_IboundaryCpIdx(i+1)-1.
    ! This is the old KVBD array.
    integer, dimension(:), pointer :: p_IverticesAtBoundary

    ! pointer to edges adjacent to the boundary. 
    !
    ! Handle to 
    !       p_IedgesAtBoundary = array [1..NMBD] of integer.
    ! This array contains a list of all edges on the (real) boundary.
    ! 2D: in mathematically positive sense. 
    ! 3D: with increasing number.
    ! The boundary edges of boundary component i are saved at
    !        p_IboundaryCpEdgesIdx(i)..p_IboundaryCpEdgesIdx(i+1)-1.
    ! This is the old KMBD array.
    ! (Note: In 2D, the above index pointer coincides with
    !        p_IboundaryCpEdgesIdx(i)..p_IboundaryCpEdgesIdx(i+1)-1 ).
    integer, dimension(:), pointer :: p_IedgesAtBoundary

    ! pointer to elements adjacent to the boundary. 
    !
    ! Handle to 
    !       p_IelementsAtBoundary = array [1..NVBD] of integer.
    ! This array contains a list of all elements on the (real) boundary
    ! in mathematically positive sense.
    ! p_IelementsAtBoundary(i) is the element adjacent to edge
    ! h_IedgesAtBoundary - therefore one element number might appear
    ! more than once in this array!
    ! The boundary elements of boundary component i are saved at
    !        p_IboundaryCpIdx(i)..p_IboundaryCpIdx(i+1)-1.
    ! This is the old KEBD array.
    integer, dimension(:), pointer :: p_IelementsAtBoundary


END SUBROUTINE checkboundary

!*
!**********************************************************************************************************************

!************************************ SUBROUTINE to calculate the volumepart ******************************************
!*

SUBROUTINE calculatevolumepart(rparlist,p_rproblemLevel,rsolution,rtimestep,rcollection,rParticles)

    ! parameterlist
    type(t_parlist), intent(inout) :: rparlist

    ! collection structure
    type(t_collection), intent(inout) :: rcollection

    ! time-stepping structure
    type(t_timestep), intent(inout) :: rtimestep

    ! particles
    type(t_Particles), intent(inout) :: rParticles

     ! primal solution vector
    type(t_vectorBlock), intent(inout), target :: rsolution

    ! Pointer to the multigrid level
    type(t_problemLevel), pointer :: p_rproblemLevel

    ! pointer to array of the volume for each element
    !
    ! 2D triangulation: Array with area of each element.
    ! 3D triangulation: Array with volume of each element.
    ! Handle to 
    !       p_DelementArea = array [1..NEL+1] of double.
    ! p_DelementArea [NEL+1] gives the total area/voloume of the domain.
    real(DP), dimension(:,:), pointer :: p_DelementVolume




END SUBROUTINE calculatevolumepart

!*
!**********************************************************************************************************************

end module euler_lagrange
