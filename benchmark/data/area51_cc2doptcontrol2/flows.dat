# =======================================================================================
# Section that defines the initial condition in the optimal control problem.

##################
[INITIALCONDITION]
##################

# Type of flow.
# =-1: analytically given as callback function
# =0: zero flow
# =1: stationary flow as prescribed by a solution vector read in from a file.
#     The filename is stargetFlow below.
# =2: The first file of a nonstationary flow as prescribed by a sequence of 
#     files on the hard disc. stargetFlow is the basic filename target. A number
#     '.0000','.0001',... is appended to this to form the filename of the
#     solution vector in every timestep. There must be exactly as many
#     files present on the hard disc as prescribed by the 
#     time discretisation!
# =3: analytically given in expression sflowExpressionX/sflowExpressionY

ctype = -1

# Id of the initial condition in case ctype=0.

iid = 0

# Analytical expression that defines the flow for the X/Y coordinate
# in case ctype = 3. Valid variables/constants:
#    X / Y  = coordinate of the point where to evaluate the expression
#    TIME   = current time
#    _PI    = The number Pi
#    _EXP   = The natural number E
#    _INFTY = infinity

sflowExpressionY1 = ''
sflowExpressionY2 = ''
sflowExpressionP = ''

# Refinement level of the coarse mesh corresponding to the flow vector.
# Only valid if ctype =1 or =2.

ilevel = 7

# Element type of the flow.
# =-1: Use the same element as the discretisation.
# >=0: Use an alternative element.

ielementType = -1

# Name and path to the TRI file containing the mesh that corresponds to the
# flow. ='': Use the same TRI file as for the computation of the
# solution.
# Only valid if ctype =1 or =2.

smesh = ''

# If ctype = 1, this is the filename of a file on disc containing
# the flow. The file must contain a solution at the same spatial
# level as prescribed by ilevel.

sflowFile = ''

# Granularity parameter for the filenames of the flow.
# =1 will read '.00000', '.00001', '.00002', etc.
# =2 will read '.00000', '.00002', '.00004', etc.
# =n will read '.00000', '.0000n', etc.

idelta = 1

# Number of files that describe the flow. If this is set to -1,
# the number of files is automatically determined by the number of timesteps
# in the finest level. If this is >= 0, the flow consists of nimesteps
# files with file extension '.00000', '.00001', '.00002',...
# If there are less files available on the hard disc that specified here,
# the last solution is duplicated to fill the remaining time steps.

ntimesteps = 64

# Start time of a nonstationary flow if ctype=2.
# Default coincides with the start time of the nonstationary simulation.

dstartTime = %{TIME-DISCRETISATION.dtimeInit}

# End time of a nonstationary flow if ctype=2.
# Default coincides with the end time of the nonstationary simulation.

dtimeMax = %{TIME-DISCRETISATION.dtimeMax}

# =======================================================================================
# Section that defines the RHS in the optimal control problem.

###############
[RIGHTHANDSIDE]
###############

# Type of flow.
# =-1: analytically given as callback function using iid
# =0: zero flow
# =3: analytically given in expression sflowExpressionX/sflowExpressionY

ctype = -1

# Id of the flow in case ctype=0.

iid = 0

# Analytical expression that defines the flow for the X/Y coordinate
# in case ctype = 3. Valid variables/constants:
#    X / Y  = coordinate of the point where to evaluate the expression
#    TIME   = current time
#    _PI    = The number Pi
#    _EXP   = The natural number E
#    _INFTY = infinity

sflowExpressionY1 = ''
sflowExpressionY2 = ''
sflowExpressionP = ''

# =======================================================================================
# Section that defines the target flow in the optimal control problem.

################
[OPTCTARGETFLOW]
################

# Type of flow.
# =-1: analytically given as callback function
# =0: zero flow
# =1: stationary flow as prescribed by a solution vector read in from a file.
#     The filename is stargetFlow below.
# =2: nonstationary flow as prescribed by a sequence of files on the 
#     hard disc. stargetFlow is the basic filename target. A number
#     '.0000','.0001',... is appended to this to form the filename of the
#     solution vector in every timestep. There must be exactly as many
#     files present on the hard disc as prescribed by the 
#     time discretisation!
# =3: analytically given in expression sflowExpressionX/sflowExpressionY
# =4: Created by a forward simulation. NOTE: NOT YET SUPPORTED!

ctype = -1

# Id of the flow in case ctype=0.

iid = 0

# Analytical expression that defines the flow for the X/Y coordinate
# in case ctype = 3. Valid variables/constants:
#    X / Y  = coordinate of the point where to evaluate the expression
#    TIME   = current time
#    _PI    = The number Pi
#    _EXP   = The natural number E
#    _INFTY = infinity

sflowExpressionY1 = ''
sflowExpressionY2 = ''
sflowExpressionP = ''

# Refinement level of the coarse mesh corresponding to the flow vector.
# Only valid if ctype =1 or =2.

ilevel = 7

# Element type of the flow.
# =-1: Use the same element as the discretisation.
# >=0: Use an alternative element.

ielementType = -1

# Name and path to the TRI file containing the mesh that corresponds to the
# flow. ='': Use the same TRI file as for the computation of the
# solution.
# Only valid if ctype =1 or =2.

smesh = ''

# If ctype = 1/2, this is the filename of a file on disc containing
# the flow. The file must contain a solution at the same spatial
# level as prescribed by ilevel.

sflowFile = 'ns/drivencav_stat_lv7/solution7'

# Granularity parameter for the filenames of the flow if ctype=2.
# =1 will read '.00000', '.00001', '.00002', etc.
# =2 will read '.00000', '.00002', '.00004', etc.
# =n will read '.00000', '.0000n', etc.

idelta = 1

# If ctype=2/4: Number of files that describe the flow. If this is set to -1,
# the number of files is automatically determined by the number of timesteps
# in the finest level. If this is >= 0, the flow consists of nimesteps
# files with file extension '.00000', '.00001', '.00002',...
# If there are less files available on the hard disc that specified here,
# the last solution is duplicated to fill the remaining time steps.

ntimesteps = 64 

# Start time of a nonstationary flow if ctype=2/4.
# Default coincides with the start time of the nonstationary simulation.

dstartTime = %{TIME-DISCRETISATION.dtimeInit}

# End time of a nonstationary flow if ctype=2/4.
# Default coincides with the end time of the nonstationary simulation.

dtimeMax = %{TIME-DISCRETISATION.dtimeMax}

# If ctype=4, this defines the Time-stepping scheme of the forward simulation.
# 0=one step scheme,
# 1=FS-Theta 3-step scheme
# NOTE: NOT YET SUPPORTED!
# ctimeStepScheme = %{TIME-DISCRETISATION.ctimeStepScheme}

# Parameter for one step scheme (THETA) if itimeStepScheme=0;
# =0:Forward Euler(instable), =1: Backward Euler, =0.5: Crank-Nicolson
# NOTE: NOT YET SUPPORTED!
# dtimeStepTheta = %{TIME-DISCRETISATION.dtimeStepTheta}

# Reference to a section defining the initial condition of the flow
# (solution at the start time).
# NOTE: NOT YET SUPPORTED!
# ssectionInitSol = INITIALCONDITION


# =======================================================================================
# Section that defines the initial iterate in the optimal control problem.

################
[INITIALITERATE]
################

# Type of flow.
# =-1: analytically given as callback function
# =0: zero flow
# =1: stationary flow as prescribed by a solution vector read in from a file.
#     The filename is stargetFlow below.
# =2: The first file of a nonstationary flow as prescribed by a sequence of 
#     files on the hard disc. stargetFlow is the basic filename target. A number
#     '.0000','.0001',... is appended to this to form the filename of the
#     solution vector in every timestep. There must be exactly as many
#     files present on the hard disc as prescribed by the 
#     time discretisation!
# =3: analytically given in expression sflowExpressionX/sflowExpressionY

ctype = 0

# Id of the initial condition in case ctype=0.

iid = 0

# Analytical expression that defines the flow for the X/Y coordinate
# in case ctype = 3. Valid variables/constants:
#    X / Y  = coordinate of the point where to evaluate the expression
#    TIME   = current time
#    _PI    = The number Pi
#    _EXP   = The natural number E
#    _INFTY = infinity

sflowExpressionY1 = ''
sflowExpressionY2 = ''
sflowExpressionP = ''

# Refinement level of the coarse mesh corresponding to the flow vector.
# Only valid if ctype =1 or =2.

ilevel = 7

# Element type of the flow.
# =-1: Use the same element as the discretisation.
# >=0: Use an alternative element.

ielementType = -1

# Name and path to the TRI file containing the mesh that corresponds to the
# flow. ='': Use the same TRI file as for the computation of the
# solution.
# Only valid if ctype =1 or =2.

smesh = ''

# If ctype = 1, this is the filename of a file on disc containing
# the flow. The file must contain a solution at the same spatial
# level as prescribed by ilevel.

sflowFile = ''

# Granularity parameter for the filenames of the flow.
# =1 will read '.00000', '.00001', '.00002', etc.
# =2 will read '.00000', '.00002', '.00004', etc.
# =n will read '.00000', '.0000n', etc.

idelta = 1

# Number of files that describe the flow. If this is set to -1,
# the number of files is automatically determined by the number of timesteps
# in the finest level. If this is >= 0, the flow consists of nimesteps
# files with file extension '.00000', '.00001', '.00002',...
# If there are less files available on the hard disc that specified here,
# the last solution is duplicated to fill the remaining time steps.

ntimesteps = 64 

# Start time of a nonstationary flow if ctype=2.
# Default coincides with the start time of the nonstationary simulation.

dstartTime = %{TIME-DISCRETISATION.dtimeInit}

# End time of a nonstationary flow if ctype=2.
# Default coincides with the end time of the nonstationary simulation.

dtimeMax = %{TIME-DISCRETISATION.dtimeMax}


# =======================================================================================
# Section defining a reference solution for error calculation

####################
[REFERENCE-FUNCTION]
####################

# Type of flow.
# =-1: zero flow
# =0: analytically given as callback function
# =1: stationary flow as prescribed by a solution vector read in from a file.
#     The filename is stargetFlow below.
# =2: nonstationary flow as prescribed by a sequence of files on the 
#     hard disc. stargetFlow is the basic filename target. A number
#     '.0000','.0001',... is appended to this to form the filename of the
#     solution vector in every timestep. There must be exactly as many
#     files present on the hard disc as prescribed by the 
#     time discretisation!
# =3: analytically given in expression sflowExpressionY1/sflowExpressionY2

ctype = -1

# Id of the flow in case ctype=0.

iid = 0

# Analytical expression that defines the flow for the X/Y coordinate
# in case ctype = 3. Valid variables/constants:
#    X / Y  = coordinate of the point where to evaluate the expression
#    TIME   = current time
#    _PI    = The number Pi
#    _EXP   = The natural number E
#    _INFTY = infinity

sflowExpressionY1 = ''
sflowExpressionY2 = ''
sflowExpressionP = ''
sflowExpressionL1 = ''
sflowExpressionL2 = ''
sflowExpressionXI = ''

# Refinement level of the coarse mesh corresponding to the flow vector.
# Only valid if ctype =1 or =2.

ilevel = 7

# Element type of the flow.
# =-1: Use the same element as the discretisation.
# >=0: Use an alternative element.

ielementType = -1

# Name and path to the TRI file containing the mesh that corresponds to the
# flow. ='': Use the same TRI file as for the computation of the
# solution.
# Only valid if ctype =1 or =2.

smesh = ''

# If ctype = 1, this is the filename of a file on disc containing
# the flow. The file must contain a solution at the same spatial
# level as prescribed by ilevel.

sflowFile = 'ns/drivencav_stat_lv7/solution7'

# Granularity parameter for the filenames of the flow.
# =1 will read '.00000', '.00001', '.00002', etc.
# =2 will read '.00000', '.00002', '.00004', etc.
# =n will read '.00000', '.0000n', etc.

idelta = 1

# Number of files that describe the flow. If this is set to -1,
# the number of files is automatically determined by the number of timesteps
# in the finest level. If this is >= 0, the flow consists of nimesteps
# files with file extension '.00000', '.00001', '.00002',...
# If there are less files available on the hard disc that specified here,
# the last solution is duplicated to fill the remaining time steps.

ntimesteps = 64 

# Start time of a nonstationary flow if ctype=2.
# Default coincides with the start time of the nonstationary simulation.

dstartTime = %{TIME-DISCRETISATION.dtimeInit}

# End time of a nonstationary flow if ctype=2.
# Default coincides with the end time of the nonstationary simulation.

dtimeMax = %{TIME-DISCRETISATION.dtimeMax}
