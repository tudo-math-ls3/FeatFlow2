# -------------------------------------------------------------------
# This optional master file is the entry point for all data
# which is processed by the software. The simportdatafiles(.) parameter
# below defines a list of 'child' data files which are read during
# the initialisation. All parameters and sections following
# this parameter overwrite data from the DAT files; this allows
# to centrally define crucial parameters in numeric tests while
# the data files specify the general setting.
#
# If simportdatafiles(.) is not present as first parameter in this
# file, all parameters of the software must be defined here. This
# allows to collect all parameters in one file.
#
# If this file is missing, the software will search for parameters in
# a standard set of data files.
# -------------------------------------------------------------------

# In the following we define some basic directories that can be used
# in all sub-data-files as path specifications for input/output
# files. This allows to run the application in a benchmark
# environment with different settings

# Directory of the application
sappdirectory = .

# Directory with data files
sdatadirectory = %{sappdirectory}/data/apps_cc2d

# Directory for log files
slogdirectory = $LOGDIR

# Directory for visualisation files
spostdirectory = $LOGDIR

# Directory containing/receiving plain solution files
ssolutiondirectory = $LOGDIR

# Directory for preprocessing files
spredirectory = %{sappdirectory}/data/apps_cc2d

# The following defines a list of data files to read. The files may optionally
# contain a path specification. If no path os specified, the files
# are searched for in the same subdirectory as the master.dat.
# By default, we specify the sdatadirectory variable here as path specifier.

simportdatafiles(8) =
  "%{sdatadirectory}/discretisation.dat"
  "%{sdatadirectory}/linsol_cc2d.dat"
  "%{sdatadirectory}/nonlinsol_cc2d.dat"
  "%{sdatadirectory}/output.dat"
  "%{sdatadirectory}/paramtriang.dat"
  "%{sdatadirectory}/bdconditions.dat"
  "%{sdatadirectory}/timediscr.dat"
  "%{sdatadirectory}/postprocessing.dat"

# We redefine the maximum level and the benchmark result file.



####################################################################################
# Customisation section - anything not default comes here, potentially overriding
# prior settings

#############
[PARAMTRIANG]
#############

# Filename of the parametrisation of the domain
sParametrisation = '%{spredirectory}/flow_around_four_boxes.prm'

# Filename of the coarse grid mesh
sMesh = '%{spredirectory}/flow_around_four_boxes.tri'


##############
[BDCONDITIONS]
##############

# Whether there are Neumann boundary components in the domain.
# =-1 : automatic detection (standard; does not work for moving boundary conditions!)
# =0  : The boundary is pure Dirichlet.
# =1  : There are Neumann or pressure drop boundary segments on the domain.
ineumannBoundary = -1

# For each boundary component, a boundary component specifier
# 'bdComponentX([n])' must exist. [n] defines the number of sub-segments
# that follow. A sub-segment either corresponds to an actual boundary
# segment or is a 'free' boundary segment anywhere on the boundary.
# To each sub-segment, a boundary condition is associated.
#
# Definition of boundary segments always starts at parameter value 0.0.
# Each specified sub-segment allows to specify the end parameter
# value of the segment:
# "    0  4.0  3  [bdcid] ..."
#   Creates a boundary condition segment starting from the 'current'
#   parameter value, ending at parameter value '4.0'. '3' specifies
#   that both, starting and ending point should belong to the segment.
#   '1' is the number X of the boundary condition 'bdExpressionX'
#   defined above.
#   Using a parameter value which is larger than the maximum parameter
#   value will result in a 'wrap around', of the boundary condition
#   segment, letting it start at the beginning of the boundary component
#   again.
# The last values in the list "x y a [bdcid] ..." have the following
# meaning:
#  a = 0: Start- and endpoint don't belong to the interval
#    = 1: Include startpoint of the interval
#    = 2: Include endpoint of the interval
#    = 3: Include start- and endpoint
#  [bdcid] = 0 : Do-nothing boundary condition for all directions
#          = 1 : Simple Dirichlet boundary condition for all
#                main solution components (e.g. velocity) component.
#                For every component, an expression identifier follows
#                that defines the value on that part of the boundary.
#                Example:  1.0  3  1  'Dirichlet0'  'Dirichlet0'
#                          2.0  3  1  'Dirichlet1'  'Dirichlet0'
#                Dirichlet-0-values between parameter value 0..1 for X- and
#                Y-velocity. Between parameter value 1..2: Dirichlet-1-value
#                for X-vel., Dirichlet-0-value for Y-vel.
#          = 2 : Pressure-drop / Normal-stress boundary condition.
#                "..." specifies the name of the expression that is
#                evaluated to give the normal stress.
#                Example:  1.0  3  3  'PressValue1'
#          = 3 : Slip boundary conditions. Like Neumann BC's this
#                does not use an expression.
#
# Note: In the default configuration, the expession name 'AnalyticBC'
#  (as defined above with expression type -2) serves as a trigger for
#  analytic Dirichlet boundary conditions that use the callback routione
#  'getBoundaryValues'. Therefore, when the term 'AnalyticBC' is used as
#  X- or Y-velocity, the routine 'getBoundaryValues' in cccallback.f90 is
#  called for that segment to return the analytic boundary value!

# Benchmark configuration:
bdComponent1(4)=
   1.0  3  1  'Dirichlet0'  'Dirichlet0'   # param=[0.0,1.0] : Dirichlet-0 boundary for X and Y, include start- and end point
   2.0  0  0                               # param=]1.0,2.0[ : Neumann boundary = do-nothing, without start- and end point
   3.0  3  1  'Dirichlet0'  'Dirichlet0'   # param=[2.0,3.0] : Dirichlet-0 boundary for X and Y, include start- and end point
   4.0  3  1  'ParProfile'  'Dirichlet0'   # param=[3.0,4.0] : parabolic profile in X, 0.0 in Y, include start- and end point

bdComponent2(1)=
   4.0  3  1  'Dirichlet0'  'Dirichlet0'   # Complete boundary component Dirichlet-0 boundary

bdComponent3(1)=
   4.0  3  1  'Dirichlet0'  'Dirichlet0'   # Complete boundary component Dirichlet-0 boundary

bdComponent4(1)=
   4.0  3  1  'Dirichlet0'  'Dirichlet0'   # Complete boundary component Dirichlet-0 boundary

bdComponent5(1)=
   4.0  3  1  'Dirichlet0'  'Dirichlet0'   # Complete boundary component Dirichlet-0 boundary


###################
[CC-DISCRETISATION]
###################

# minimum mg-level; <=0: Use level (NLMAX - |NLMIN|) as coarse grid
NLMIN = 1

# maximum mg-level = level of computation of nonlinear iteration
NLMAX = $MGLEVEL

# Viscosity parmeter 1/NU if the viscosity is constant
RE = 100  # values up to 200 work. For RE > 250 the solver diverges.

# Type of right hand side.
# 0=zero
# 1=steady inhomog., analytically defined by coeff_RHS_x/coeff_RHS_y
#   before the simulation
# 2=nonsteady force, analytically defined by coeff_RHS_x/coeff_RHS_y
#   in every timestep of the simulation
iRHS = 0


###################
[CC-POSTPROCESSING]
###################

# Type of output file to generate from solutions.
# 0=disabled (standard)
# 1=formatted film output
# 2=unformatted film output
ioutputFilm = 1

# Calculate L2-error to reference solution.
# =0: Don't calculate
# =1: Calculate the error
ierrorAnalysisL2 = 1


###############
[GENERALOUTPUT]
###############
sbenchLog = '$LOGDIR/benchmarkresultfile'
