# ------------------------------------------------------------------------
# Time discretization
# 
# This file contains parameters configuring the time discretization
# of the problem.
# ------------------------------------------------------------------------

#####################
[TIME-DISCRETISATION]
#####################

# Type of problem (ISTAT): 0=steady,1=nonsteady

itimedependence = 0                       # ISTAT

# ----------------------------------------------------------------------

# Maximum number of macro time steps (TIMEMX).
# Simulation stops if time > dtimemax or #iterations > niterations

niterations = 10000                       # NITNS

# Absolute start time of the simulation (TIMENS)

dtimeInit = 0.0                           # TIMENS

# Max. absolute time of the simulation (TIMEMX); simulation stops if 
# time > dtimemax or #iterations > niterations

dtimeMax = 1.0                           # TIMEMX

# Initial time step size

dtimeStep = 0.1                           # DTSTEP

# Lower limit for the time derivative to be treated as zero. (EPSNS)
# Simulation stops if time derivative drops below this value.

dminTimeDerivative = 0.00001              # EPSNS

# ----------------------------------------------------------------------

# Time-stepping scheme (IFRSTP);
#   0=one step scheme
#   1=classic fractional step theta (stiffly accurate, A-stable, convergence
#      order=2 for velocity, =1 for pressure, three internal steps)
#   2=Glowinski new fractional step theta (stiffly accurate, A-stable,
#     conv. order=2 for velocity, =1 for pressure, three internal steps)
#   3=classic fractional step theta, implemented as diagonally implicit
#     Runge-Kutta method (explicit first stage, stiffly accurate, A-stable,
#     convergence order=2 for velocity, =1 for pressure, three internal steps,
#     requires pressure start solution)
#   4=diagonally implicit Runge-Kutta method (E)DIRK23L, in literature also known
#     as cyclic combination of trapezoidal rule and the BDF2 scheme (explicit
#     first stage, stiffly accurate, L-stable, convergence order=2 for
#     velocity and pressure, two internal steps, requires pressure start
#     solution)
#   5=diagonally implicit Runge-Kutta method (ES)DIRK34L variant A (explicit
#     first stage, stiffly accurate, L-stable, convergence order=3 for
#     velocity, =2 for pressure, three internal steps, requires pressure start
#     solution)
#   6=diagonally implicit Runge-Kutta method (ES)DIRK34L variant B, in
#     literature also known as ESDIRK 3/2a (explicit first stage, stiffly
#     accurate, L-stable, convergence order=3 for velocity, =2 for pressure,
#     three internal steps, requires pressure start solution)
#   7=diagonally implicit Runge-Kutta method (E)DIRK44L (explicit first stage,
#     stiffly accurate, L-stable, (theoretical) convergence order=4 for
#     velocity, realistic order =3 for velocity, =2 for pressure, three
#     internal steps, requires pressure start solution)
#   8=diagonally implicit Runge-Kutta method (E)DIRK54L (explicit first stage,
#     stiffly accurate, L-stable, (theoretical) convergence order=5 for
#     velocity, realistic order =3 for velocity, =2 for pressure, three
#     internal steps, requires pressure start solution)
#   9=diagonally implicit Runge-Kutta method SDIRK2 (implicit first stage,
#     stiffly accurate, L-stable, convergence order between 2 and 3.5 for
#     velocity, between 1 and 2 for pressure, four internal steps, requires
#     pressure start solution)
#  10=diagonally implicit Runge-Kutta method SDIRK3PR (explicit first stage,
#     stiffly accurate, L-stable, convergence order between 2 and 4 for
#     velocity, between 1 and 3 for pressure, five internal steps, requires
#     pressure start solution)
# <=-3=initial time steps with a one step scheme to generate a start pressure
#     solution, then the DIRK scheme with identifier |itimeStepScheme|. The
#     number of initial time steps depends on the number of substeps the DIRK
#     scheme consists of: 2 for DIRK23L, 3 for DIRKx4L

itimeStepScheme = 0                       # IFRSTP

# parameter for one step scheme (THETA) if itimeStepScheme=0;
# =0:Forward Euler(instable), =1: Backward Euler, =0.5: Crank-Nicolson

dtimeStepTheta = 1.0                      # THETA

# Time-stepping scheme for the pressure.
# =0: Use the same time-stepping scheme as for the velocity;
#     sometimes referred to as pressure-corrected time-stepping schemes
#     (Note: This approach requires the pressure from time t_n for the
#      computation of the solution at time t_{n+1}. In particular, an
#      initial pressure for the (Navier-)Stokes equiations has to be
#      defined. To circumvent this difficulty, often an inconsistent
#      treatment of the pressure is applied, hence the option =1.)
# =1: Calculate the pressure fully implicitely (standard)
# No effect if Implicit-Euler is used. Difference can only be seen for
# time discretisation schemes of order > 1. Flag is ignored for DIRK
# schemes and forcibly set to 0.

ipressureFullyImplicit = 1

# ----------------------------------------------------------------------

# Adaptive time stepping (similar to IADTIM)
# -1=user defined; determined by calling "calcAdaptiveTimestep".
# 0=fixed time step
# 1=with prediction no repetition if nonlinear solver fails
# 2=with prediction, repetition if nonlinear solver fails
# 3=with prediction, repetition if nonlinear solver fails or
#   time error too large

cadaptiveTimeStepping = 0                 # IADTIM

# max. number of repetitions for |cadaptiveTimeStepping| > 0 (IREPIT)

irepetitions = 3                          # IREPIT

# min. time step (DTMIN)

dtimeStepMin = 0.000001                   # DTMIN

# max. time step (DTMAX)

dtimeStepMax = 1.000000001                # DTMAX

# max. changes for time step (DTFACT) for |cadaptiveTimeStepping|<>0.
# When decreasing the time step size, the new time step size is 
# estimated in the range
#  (old time step)/dtimeStepFactor .. (old time step)/SQRT(dtimeStepFactor).
# When increasing the time step size, the new time step size is
# estimated in the range
#  (old time step size) .. (old time step size) * dtimeStepFactor**(1/#performed repetitions)

dtimeStepFactor = 9.000000001             # DTFACT  

# max. rel. change of time step such that the step is not repeated
# (EPSADU). Applies only for |cadaptiveTimeStepping|=3.
# If 
#  (new time step size)/(old time step size) < depsilonAdaptiveRelTimeStep, 
# the time step is repeated.

depsAdaptiveRelTimeStep = 0.5             # EPSADU

# ----------------------------------------------------------------------

# Type of start procedure (IADIN) when starting a nonstationary 
# simulation if cadaptiveTimeStepping<>0 (to prevent time step
# to be reduced to 0.0)
# 0=constant start
# 1=linear start (linear blending between dadTimeStepEpsDuringInit
#   and dadTimeStepEpsAfterInit)
# 2=logarith. start (logarithmic blending between dadTimeStepEpsDuringInit
#   and dadTimeStepEpsAfterInit)

cadTimeStepInit = 2                       # IADIN

# Time length of start procedure; must be >0 if cadaptiveTimeStepping<>0,
# otherwise nonsteady simulations will stuck at the initial time
# reducing the time step size to 0.0

dadTimeStepInitDuration = 0.5             # TIMEIN

# Type of error indicator to measure error in time (IEPSAD) when doing
# adaptive time stepping;
# 1=u(L2),2=u(MX),3=p(L2),4=p(MX),5-8=mix

cadTimeStepErrorControl = 1               # IEPSAD 

# low accuracy for acceptance during start procedure (EPSADI);
# if time error is larger, the step is repeated

dadTimeStepEpsDuringInit = 1.25E-1        # EPSADI

# low accuracy for acceptance after start procedure (EPSADL);
# if time error is larger, the step is repeated

dadTimeStepEpsAfterInit = 1.25E-3         # EPSADL
