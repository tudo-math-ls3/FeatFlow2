#!/bin/sh

# 'fb_' stands for 'FEAST benchmark'.
# Variables are written in capital letters if used globally


# Initialisations
ALLTESTS=
CPUSPERNODE=2
DOSENDMAIL=
EMAILADDRESS=
GNUMAKE=
JOBFILEPREFIX="feat2job"
MODULESLOADED=
NTASKS=
WALLCLOCKLIMIT="00:40:00"

# ==================================================================
# IMPORTANT
# ==================================================================
# It is assumed this script is called from a fbenchmark2 directory.
# This assumption is not only made here, but also later as the
# Makefile in a fbenchmark2 directory (whatever its actual name is)
# is needed to create a 'runtests' script. The library function
# fb_ensureCorrectWorkingDir even checks whether that's the case.


# ==================================================
# = Load library with functions needed for         =
# = every scheduling script (NEC, LiDO, JUMP etc.) =
# ================================================== 
. include/lib_for_xxx_schedule_tests || exit 1


# Three arrays containing relevant LiDO queue settings
# Indices must always be the same:
# 0 = short_*  ,  1 = med_*  ,  2 = long_*
#
# Names of queues, maximum wallclock times (in seconds) and 
# maximum number of nodes currently available (= online nodes)
declare -a eth[2], ib[2]
declare -a eth_wallclockseconds[2], ib_wallclockseconds[2]
declare -a eth_maxnodes[2], ib_maxnodes[2]


#  Function: Query PBS to find out about available nodes and maximum walltime per queue
fb_queryPBSLiDO() {
    eth[0]="short_eth"
    eth[1]="med_eth"
    eth[2]="long_eth"
    ib[0]="short_ib"
    ib[1]="med_ib"
    ib[2]="long_ib"

    # Create temporary file (with unique file name)
    qmgr=`mktemp`
    if [ $? -ne 0 ]; then
	cat <<EOF 1>&2
$0: Error: Creating temporary file failed. Script cancelled.
EOF
	exit 2
    fi

    # Query PBS queue manager and store result in temporary file
    qmgr -c 'list queue @master' > ${qmgr}
    if [ $? -ne 0 ]; then
	cat <<EOF 1>&2
$0: Error: Could not query PBS manager for available resources. Script cancelled.
EOF
	exit 3
    fi

    # Create temporary file (with unique file name)
    sedFileSuppressOfflineNodes="`mktemp`"".sed"
    if [ $? -ne 0 ]; then
	cat <<EOF 1>&2
$0: Error: Creating temporary file failed. Script cancelled.
EOF
	exit 4
    fi

    # Query PBS for offline nodes, transform the output into sed instructions
    # (that remove any occurrence of offline nodes from input strings) and
    # store it to a temporary file
    pbsnodes -l | grep offline | sed 's/^\([^ ]*\).*$/s\/\1+*\/\/;/' > ${sedFileSuppressOfflineNodes}
    if [ $? -ne 0 ]; then
	cat <<EOF 1>&2
$0: Error: Could not query PBS for offline nodes. Script cancelled.
EOF
	exit 5
    fi

    # Define a smaller helper routine for code repeatedly needed
    fb_getSettingsForQueue() {
	queue="$1"  # IN
        egrep "(^Queue|^[ 	]acl_hosts|^[ 	]resources_max.walltime)" ${qmgr} | \
 		# Turn output into one line per queue
 		grep -v "^Queue default" | \
 		sed 'N; N; s/\n//g;' | \
		# Suppress offline nodes
		sed -f ${sedFileSuppressOfflineNodes} | \
		# Extract current queue
		grep ${queue}
    }

    # eth queue
    for i in 0 1 2; do
	queue=${eth[$i]};
	# Determine maximum wall clock time
	eth_wallclockseconds[$i]=`fb_getSettingsForQueue $queue | awk '{print $NF}' | awk -F: '{print $1*3600+$2*60+$3}'`
	# Determine maximum number of nodes available
	eth_maxavailnodes[$i]=`fb_getSettingsForQueue $queue | sed -e 's/^.*acl_hosts = \([^ 	]*\).*/\1/; s/+/ /g;' | wc -w`
    done

    # ib queue
    for i in 0 1 2; do
	queue=${ib[$i]};
	# Determine maximum wall clock time
	ib_wallclockseconds[$i]=`fb_getSettingsForQueue $queue | awk '{print $NF}' | awk -F: '{print $1*3600+$2*60+$3}'`
	# Determine maximum number of nodes available
	ib_maxavailnodes[$i]=`fb_getSettingsForQueue $queue | sed -e 's/^.*acl_hosts = \([^ 	]*\).*/\1/; s/+/ /g;' | wc -w`
    done

    rm -f ${qmgr} ${sedFileSuppressOfflineNodes}
}


#  Function: Determine most suitable queue depending on node, walltime and interconnect requirements
fb_determineQueue() {
    nodes="$1"      # IN (format: integer)
    queuetype="$3"  # IN (valid: "_eth" or "_ib")

    walltimeseconds="`echo $2 | awk -F: '{print $1*3600+$2*60+$3}'`"   # IN (format: hh:mm:ss)


    # Check ethernet queues
    if test "${queuetype}" = "_eth"; then 
	for i in 0 1 2; do
	    queue=${eth[$i]};
	    # Check whether enough nodes in queue available
	    if test ${nodes} -le ${eth_maxavailnodes[$i]}; then
		# Check whether wall time limits are not exceeded
		if test ${walltimeseconds} -le ${eth_wallclockseconds[$i]}; then
		    echo ${queue};
		    return;
		fi
	    fi
	done
    fi


    # Check infiniband queues
    if test "${queuetype}" = "_ib"; then 
	for i in 0 1 2; do
	    queue=${ib[$i]};
	    # Check whether enough nodes in queue available
	    if test ${nodes} -le ${ib_maxavailnodes[$i]}; then
		# Check whether wall time limits are not exceeded
		if test ${walltimeseconds} -le ${ib_wallclockseconds[$i]}; then
		    echo ${queue};
		    return;
		fi
	    fi
	done
    fi
}


#  Function: Create a jobfile for LiDO for a given test ID
fb_createJobfileLiDO() {
    benchmarktest="$1"  # IN
    file="$2"           # IN

    fb_createRuntestsScript "$benchmarktest"
    if [ $? -ne 0 ]; then
	return 1
    fi

    fb_getNTASKS
    if [ $? -ne 0 ]; then
	return 2
    fi

    # Only allocate complete nodes to prevent that some other
    # cluster user influences this job. Other processes possibly
    # use much more ressources than available (e.g. more memory than 
    # available => swapping, cpu threading => less cpu for us,
    # network card flooding, whatever else)
    nodes=`expr $NTASKS / $CPUSPERNODE`;
    # If number of CPUs per node ($CPUSPERNODE) is not divisor of the 
    # number of processes requested, then there has been an arithmetic 
    # remainder of the devision and we need one more (incompletely used) 
    # node.
    if [ `expr $NTASKS % $CPUSPERNODE` -ne 0 ]; then
	nodes=`expr $nodes + 1`
    fi
    pbsOptionNodes="#PBS -l nodes=$nodes:ppn=2"

    # Send mail on job begin, abort and end?
    pbsOptionMail=""
    if [ "$DOSENDMAIL" -eq "1" ]; then
      pbsOptionMail="#PBS -m bae"
    fi

    # Support for OpenMPI + Infiniband, OpenMPI + GigabitEthernet
    # and LAM/MPI + GigabitEthernet.
    # Detect which MPI flavour is currently in use.
    # Add according settings to the jobfile (!), not a user's rc file.
    # Otherwise it is not possible to add GE jobs with LAM/MPI and
    # OpenMPI+IB jobs at the same time to the queue. Nor would
    # it be possible to use the same MPI flavour, but different
    # compilers at the same time as all would share the same rc file.
    sedQueueingSystem=LIDO
#    sedExecMode=PBSQUEUED
    envSetting=""
    if [ -n "$LOADEDMODULES" ]; then
	# Here enters hard-coded knowledge about maximum walltimes
	# of queues of LiDO (the server could be queries dynamically
	# for maximum walltimes, but this way it is easier.)
	case ":$LOADEDMODULES" in
	    *:mpich/ge/*)
		echo "$0: Using MPICH."
		sedMPIEnv=MPICH
		pbsOptionQueue=`fb_determineQueue "${nodes}" "${WALLCLOCKLIMIT}" "_eth"`
		interconnect=ethernet
		;;
	    *:open-mpi/ib/*)
		echo "$0: Using OpenMPI."
		sedMPIEnv=OpenMPI
		pbsOptionQueue=`fb_determineQueue "${nodes}" "${WALLCLOCKLIMIT}" "_ib"`
		envSetting="OMPI_MCA_btl=openib,self,sm; export OMPI_MCA_btl"
		interconnect=infiniband
		;;
	    *:open-mpi/ge/*)
		echo "$0: Using OpenMPI."
		sedMPIEnv=OpenMPI
		pbsOptionQueue=`fb_determineQueue "${nodes}" "${WALLCLOCKLIMIT}" "_eth"`
		envSetting="OMPI_MCA_btl=tcp,self,sm; export OMPI_MCA_btl"
		interconnect=ethernet
		;;
	    *:lam/*)
		echo "$0: Using LAM/MPI."
		sedMPIEnv=LAMMPI
		pbsOptionQueue=`fb_determineQueue "${nodes}" "${WALLCLOCKLIMIT}" "_eth"`
		envSetting="OMPI_MCA_btl=tcp,self,sm; export OMPI_MCA_btl"
		interconnect=ethernet
		;;
	    *:mvapich/*)
		echo "$0: Using MVAPICH."
		sedMPIEnv=MVAPICH
		pbsOptionQueue=`fb_determineQueue "${nodes}" "${WALLCLOCKLIMIT}" "_ib"`
		interconnect=infiniband
		;;
	    *)
		echo "$0: No MPI required."
		sedMPIEnv=not-needed-as-feat2-is-serial-only
		pbsOptionQueue=`fb_determineQueue "${nodes}" "${WALLCLOCKLIMIT}" "_eth"`
		interconnect=ethernet
		;;
	esac

	# Check whether we got a valid queue
	if test -z "${pbsOptionQueue}"; then
	    if test -z "${interconnect}"; then
		interconnect=">>!!>> (none set) <<!!<<"
	    fi
	    cat <<EOF 1>&2
$0: Error: No queue available that satisfied the node, wallclock and 
$0: interconnect requirements:
$0:   nodes          >= ${nodes}
$0:   wallclock time >= ${WALLCLOCKLIMIT}
$0:   interconnect    : ${interconnect}
EOF
	    return 3
	else
	    echo "$0: Trying to enqueue to <${pbsOptionQueue}>."
	fi

	# Now, it is known which is the target queue.
	# Check whether queue is enabled/disabled.
	queueState="`qstat -Q $pbsOptionQueue | tail -1 | awk '{print \$4}'`"
	if [ "$queueState""x" = "nox" ]; then
	    cat <<EOF 1>&2
$0: Error: Queue $pbsOptionQueue is currently closed, job scheduling
$0: is not possible. Script cancelled.
EOF
	    exit 6
	fi

    # $LOADEDMODULES not set
    else
	cat <<EOF 1>&2
$0: Error: \$LOADEDMODULES not set. Job files cannot be created.
EOF
	exit 7
    fi


    # Now, create the jobfile.
    cat <<EOF > $file
#!/bin/sh

#PBS -l walltime=$WALLCLOCKLIMIT
$pbsOptionNodes
#PBS -q $pbsOptionQueue
#PBS -o $PWD/logs/output.$benchmarktest
# join standard output and error streams
#PBS -j oe
#PBS -M $EMAILADDRESS
$pbsOptionMail

cd $PWD

EOF
    if [ $? -ne 0 ]; then
	cat <<EOF 1>&2
$0: Error while creating jobfile.
EOF
	exit 8
    fi


    # Add environment settings to jobfile
    echo "$envSetting" >> $file
    echo >> $file
    fb_addModuleInstructions >> $file
    echo >> $file


    # Add the content of our runtests script to the jobfile, but
    # * omit the first lines (i.e. the shebang, leading comments)
    # * set execution mode to PBSQUEUED
#    # * give each test its own LOGDIR
    # * set MPI environment to use
#         s|^LOGDIR=[ ]*\.|LOGDIR=$sedLogDir|i;
#         s|^EXECMODE=PARALLEL|EXECMODE=$sedExecMode|i; \
    sed -e \
        "1,7d; \
         s|^QUEUEINGSYSTEM=[ ]*$|QUEUEINGSYSTEM=$sedQueueingSystem|i; \
         s|^MPIENV=[ ]*$|MPIENV=$sedMPIEnv|i;" runtests \
	>> $file


    # Make jobfile executable
    chmod 750 $file

    echo $0": Jobfile <$jobfile> created."
}




# ================================================
# = Here is where to script really gets executed =
# ================================================

fb_readargs "$@"
fb_ensureCorrectWorkingDir
fb_setMailSender
fb_findGNUMake
fb_queryPBSLiDO
echo


successfulTests=0
testIDsWithErrors=""
for testid in $ALLTESTS
do
    jobfile="$JOBFILEPREFIX.$testid.sh"
    echo $0": Creating jobfile for <$testid>."
    fb_createJobfileLiDO "$testid" "$jobfile"
    if [ $? -eq 0 ]; then
	successfulTests=`expr $successfulTests + 1`
	echo $0": Submitting <$jobfile>."
	# Submit the jobfile. Keep trying to submit it in
	# case the maximum number of jobs per user is already
	# reached.
	fb_submitJobfile "$jobfile" "Maximum number of jobs already in queue"
    else
	echo $0": An error occurred creating the jobfile. Submit cancelled."
	testIDsWithErrors="$testIDsWithErrors $testid"
    fi
    echo
done
# Show error messages, if any
fb_postprocess "$successfulTests" "$testIDsWithErrors"
