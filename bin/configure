#!/usr/bin/env perl
#
########################################################################
#                                                                      #
#                   FINITE ELEMENT ANALYSIS TOOLS 2                    #
#                                                                      #
# Authors: M. Koester, M. Moeller, S. Turek, S. Buijssen               #
#                                                                      #
#                                                                      #
# Contact: Applied Mathematics, TU Dortmund University                 #
#          Vogelpothsweg 87, 44227 Dortmund                            #
#          Germany                                                     #
#                                                                      #
# Web:     http://www.featflow.de/en/software/featflow2.html           #
#          mailto:featflow@featflow.de                                 #
#                                                                      #
########################################################################
#
# short description:
#   script to create your FEAT2 application's Makefile
#
# long version:
#   FEAT2's bin/configure is a Perl script which basically does what you
#   would expect from a normal GNU configure: It determines a set of
#   values necessary to compile your FEAT2 application on the machine you
#   logged into, finds the dependencies between the sources files and
#   finally creates a Makefile for your application. There are three
#   reasons why the GNU configure wasn't used: First, FEAT2 is not
#   published under GNU license yet and second, most of the stuff GNU
#   configure does is not necessary for Fortran programs. It was designed
#   to create Makefiles for C / C++ programs. Finally was it easier to
#   design this Perl script to meet our needs than to learn to speak
#   autoconf syntax and make it work for us. FEAT2's bin/configure
#   accepts a bunch of command line arguments. You get a complete list
#   via 'bin/configure --help'. Using these command line arguments you
#   can override the default values of bin/configure,
#   kernel/arch/Makefile.inc and
#   the files in kernel/arch/templates/*.mk. For instance, you can change
#   application name, make program to use, build ID, Fortran compiler and/
#   or libraries to use, the source files your application is built
#   from, special compile flags and preprocessor instructions only your
#   application needs/respects etc. Adding '--debug' to your command line
#   arguments will additionally print a list of all Makefile variables
#   that are explicitly overridden from the command line. Their values
#   will take precedence over the default values set in
#   kernel/arch/Makefile.inc and the template files in
#   kernel/arch/templates/*.mk for these variables.
#
# by Sven H.M. Buijssen (sven.buijssen@math.tu-dortmund.de)
#
# Current version:
# $Id$


# ======================
# === Libraries used ===

# Allow proper programming only
# (a bit like Fortran90's "implicit none")
use strict;
use warnings;

# Use a recent version of Perl
#v-string in use/require non-portable: use v5.6.1;
use 5.006_001;

# For unicode source files
#use Encode;

# being able to use tmpname to create temporary files
use POSIX;

# Portably get the pathname of the current working directory
use Cwd qw(abs_path cwd);

# Portably compute MD5 checksums
use Digest::MD5 qw(md5);

# handling of command line options
# Minimum requirements:
# * Getopt::Long 2.33 added negatable options (with "!")
# * Getopt::Long 2.35 added none or more values for an option (with "s{0,}")
use Getopt::Long 2.35 qw(:config prefix_pattern=--);

# Portably parse a pathname into directory, basename and extensions
use File::Basename;

# Methods for manipulating file specifications.
use File::Spec;

# Portable stat command
use File::stat;

# the current hostname
use Sys::Hostname;

# Don't buffer print messages, show them immediately even if there is no carriage return yet.
use IO::Handle qw(autoflush);
STDOUT->autoflush(1);


# ===========================================
# === Define some constants and variables ===

use constant VERSION => "2.0.8056";

use constant INITIAL_MESSAGE =>
    "This is the FEAT2 custom configuration program.\n" .
    "It is not GNU Configure.\n\n" .
    "There are a couple of optional arguments to this program,\n" .
    "use '--help' command line option to learn about them.\n\n";

# program name
my $progname = &basename($0);

# This configure script is supposed to reside under bin/ in the main FeatFlow2 directory.
# This information is used to locate Makefile settings and source files. To locate those
# files from somewhere in the FeatFlow2 source tree, use the path information that is
# supplied on invocation of this script.

# version with relative paths, guessed from path used to invoke this
# script from the appliction directory
# Constraints: none
(my $FEAT2BASEDIR = &dirname($0)) =~ s/\/bin$//;

#
# version with relative paths
# Constraints: ensure that any FEAT2 application resides in a directory exactly two
#              hierarchy levels beneath the FEAT2 root directory.
#my $FEAT2BASEDIR = "../..";

# version with absolute paths
# Constraints: none
#my $FEAT2BASEDIR = &abs_path(&dirname($0) . "/..");

# another version with absolute paths
# (when changing to absolute paths again, be aware that copying of
# included files to object directory may happen multiple times as
# the file may get on the list with absolute and relative path)
#my $FEAT2BASEDIR = &get_feast_basedir(&cwd());

# name of Makefile to create
my $MAKEFILE     = "GNUmakefile";

# some important files and directories.
# The values are supposed to be relative to the FEAT2 main directory.
my $MAKEFILE_INC          = "Makefile.inc";
my $MAKEFILE_BUILDID_INC  = "Makefile.buildID.inc";
my $MAKEFILE_CPU_INC      = "Makefile.cpu.inc";
my $SRCDIR_KERNEL         = "kernel";
my $SRCDIR_ARCH           = "kernel/arch-specific";
my $SRCDIR_APP            = ".";


# Where to look by default for application-specific source files
use constant SRCDIR_APP    => "src";

# subdirectories to store FEAT2 and third-party libraries
#
# (Third party libraries are independent of FEAT2 sources and, as such, can
# be shared among all FEAT2 applications.)
use constant OBJDIR        => "object/\$(ID)";
use constant OBJDIR_LIB    => "object/\$(LIBID)";

use constant SRCLIST_KERNEL =>
    "Adaptivity/hadaptaux.f90 Adaptivity/hadaptaux1d.f90 Adaptivity/hadaptaux2d.f90 " .
    "Adaptivity/hadaptaux3d.f90 Adaptivity/hadaptivity.f90 " .

    "BasicGeometry/basicgeometry.f90 BasicGeometry/geometry.f90 BasicGeometry/geometryaux.f90 " .

    "Boundary/boundary.f90 Boundary/fictitiousboundary.f90 " .

    "ContinuousFormulation/boundarycondition.f90 ContinuousFormulation/scalarpde.f90 " .

    "DataStructures/arraylistbase.f90 " .
    "DataStructures/arraylistInt.f90 DataStructures/arraylistInt_Int.f90 " .
    "DataStructures/arraylistInt_DP.f90 DataStructures/arraylistInt_SP.f90 " .
    "DataStructures/arraylistDP.f90 DataStructures/arraylistDP_Int.f90 ".
    "DataStructures/arraylistDP_DP.f90 DataStructures/arraylistDP_SP.f90 ".
    "DataStructures/arraylistSP.f90 DataStructures/arraylistSP_Int.f90 " .
    "DataStructures/arraylistSP_DP.f90 DataStructures/arraylistSP_SP.f90 " .

    "DataStructures/listbase.f90 " .
    "DataStructures/listInt.f90 DataStructures/listInt_Int.f90 " .
    "DataStructures/listInt_DP.f90 DataStructures/listInt_SP.f90 " .
    "DataStructures/listDP.f90 DataStructures/listDP_Int.f90 ".
    "DataStructures/listDP_DP.f90 DataStructures/listDP_SP.f90 ".
    "DataStructures/listSP.f90 DataStructures/listSP_Int.f90 " .
    "DataStructures/listSP_DP.f90 DataStructures/listSP_SP.f90 " .

    "DataStructures/mapbase.f90 " .
    "DataStructures/mapInt.f90 DataStructures/mapInt_Int.f90 " .
    "DataStructures/mapInt_DP.f90 DataStructures/mapInt_SP.f90 " .
    "DataStructures/mapDP.f90 DataStructures/mapDP_Int.f90 ".
    "DataStructures/mapDP_DP.f90 DataStructures/mapDP_SP.f90 ".
    "DataStructures/mapSP.f90 DataStructures/mapSP_Int.f90 " .
    "DataStructures/mapSP_DP.f90 DataStructures/mapSP_SP.f90 " .
    
    "DataStructures/quadtreebase.f90 " .
    "DataStructures/quadtreeDP.f90 DataStructures/quadtreeSP.f90 " .

    "DataStructures/octreebase.f90 " .
    "DataStructures/octreeDP.f90 DataStructures/octreeSP.f90 " .

    "DataStructures/stackInt.f90 " .
    "DataStructures/stackDP.f90 DataStructures/stackSP.f90 " .

    "DataStructures/graph.f90  " .
    "DataStructures/numbersets.f90 DataStructures/geneticalgorithm.f90  " .
    
    "DataStructures/intgroupset.f90  " .

    "DOFMaintenance/bcassembly.f90  DOFMaintenance/bcassemblybase.f90 " .
    "DOFMaintenance/bilinearformevaluation.f90 DOFMaintenance/extstdassemblyinfo.f90 " .
    "DOFMaintenance/discretebc.f90 DOFMaintenance/discretefbc.f90 DOFMaintenance/dofmapping.f90 " .
    "DOFMaintenance/domainintegration.f90 DOFMaintenance/feevaluation.f90 " .
    "DOFMaintenance/linearformevaluation.f90 DOFMaintenance/matrixfilters.f90 " .
    "DOFMaintenance/multileveloperators.f90 DOFMaintenance/multilevelprojection.f90 " .
    "DOFMaintenance/sortstrategybase.f90 DOFMaintenance/sortstrategy.f90 " .
    "DOFMaintenance/spatialdiscretisation.f90 " .
    "DOFMaintenance/trilinearformevaluation.f90 DOFMaintenance/vectorfilters.f90 " .
    "DOFMaintenance/boundaryaux.f90 DOFMaintenance/ufci.f90 " .
    "DOFMaintenance/dofpreprocessing.f90 " .
    "DOFMaintenance/feevaluation2.f90 " .
    "DOFMaintenance/blockmatassemblybase.f90 " .
    "DOFMaintenance/blockmatassembly.f90 " .
    "DOFMaintenance/blockmatassemblystdop.f90 " .

    "ElementCubature/cubature.f90 ElementCubature/derivatives.f90 ElementCubature/element.f90 " .
    "ElementCubature/adaptivecubature.f90 " .
    "ElementCubature/element_hexa3d.f90 ElementCubature/element_line1d.f90 " .
    "ElementCubature/element_prism3d.f90 ElementCubature/element_pyra3d.f90 " .
    "ElementCubature/element_quad2d.f90 ElementCubature/element_tetra3d.f90 " .
    "ElementCubature/element_tri2d.f90 ElementCubature/elementbase.f90 " .
    "ElementCubature/elementpreprocessing.f90 ElementCubature/transformation.f90 " .

    "Hierarchies/fespacehierarchybase.f90 Hierarchies/fespacehierarchy.f90 " .
    "Hierarchies/meshhierarchy.f90 Hierarchies/timescalehierarchy.f90 " .

    "LinearAlgebra/linearalgebra.f90 " .

    "LinearSolver/agmgdummy.f90 LinearSolver/coarsegridcorrection.f90 " .
    "LinearSolver/filtersupport.f90 LinearSolver/iluk.f90 LinearSolver/linearsolver.f90 " .
    "LinearSolver/linearsolverautoinitialise.f90 LinearSolver/quicksolver.f90 " .
    "LinearSolver/vanka.f90 LinearSolver/vanka_bouss2d.f90 LinearSolver/vanka_optcontrol.f90 " .
    "LinearSolver/vanka_navst2d.f90 LinearSolver/spsor.f90 " .

    "LinearSystem/globalsystem.f90 LinearSystem/linearsystemblock.f90 " .
    "LinearSystem/linearsystemscalar.f90 LinearSystem/matrixmodification.f90 " .
    "LinearSystem/lsyssc_scalarMatVecAux.f90 LinearSystem/matrixcheck.f90 " .

    "Mathematics/adjacency.f90 Mathematics/mprimitives.f90 Mathematics/random.f90 " .

    "NonlinearSolver/nonlinearsolver.f90 " .

    "PDEOperators/afcstabbase.f90 PDEOperators/afcstabscalar.f90 PDEOperators/afcstabsystem.f90 ".
    "PDEOperators/afcstabscalarfct.f90 PDEOperators/afcstabscalartvd.f90 PDEOperators/afcstabscalargp.f90 ".
    "PDEOperators/afcstabscalarsymm.f90 PDEOperators/afcstabscalarlpt.f90 ".
    "PDEOperators/afcstabsystemfct.f90 PDEOperators/afcstabsystemtvd.f90 ".
    "PDEOperators/groupfembase.f90 PDEOperators/groupfemscalar.f90 PDEOperators/groupfemsystem.f90 " .
    "PDEOperators/matrixrestriction.f90 PDEOperators/stdoperators.f90 PDEOperators/convection.f90 " .
    "PDEOperators/jumpstabilisation.f90 PDEOperators/lumping.f90 " .

    "Postprocessing/boundaryintegral.f90 Postprocessing/mapleio.f90 Postprocessing/matrixio.f90 " .
    "Postprocessing/pprocerror.f90 Postprocessing/pprocgradients.f90 Postprocessing/pprocindicator.f90 " .
    "Postprocessing/pprocnavierstokes.f90 Postprocessing/ucd.f90 Postprocessing/vectorio.f90 " .
    "Postprocessing/geometryoutput.f90 Postprocessing/pprocintegrals.f90 Postprocessing/lineariser.f90 " .
    "Postprocessing/convergencetable.f90 " .

    "Preprocessing/pprocsolution.f90 " .

    "ProblemSupport/collection.f90 ProblemSupport/iterationcontrol.f90 " .

    "Projection/analyticprojection.f90 Projection/spdiscprojection.f90 " .
    "Projection/schurapprox.f90 " .

    "System/externalstorage.f90 System/fparser.f90 " .
    "System/fpersistence.f90 System/fsystem.f90 System/genoutput.f90 System/io.f90 " .
    "System/paramlist.f90 System/signals.f90 System/sort.f90 System/statistics.f90 " .
    "System/storage.f90 System/textstream.f90 System/uuid.f90 System/perfconfig.f90 " .

    "TimeDependence/timestepping.f90 TimeDependence/timediscretisation.f90 " .

    "Triangulation/griddeform.f90 Triangulation/meshadjacency.f90 Triangulation/meshmodification.f90 " .
    "Triangulation/meshgeneration.f90 " .
    "Triangulation/meshregion.f90 Triangulation/triangulation.f90 Triangulation/triasearch.f90";

use constant SRCLIST_ARCH      => "";


# Files generated automatically in the coarse of a make run to
# build either object files or the application itself.
# The list is used to set up the clean up targets 'clean*' and 'purge*'
use constant SRCLIST_GENERATED => " " .
                                  "\$(FILE_F77_INFO).version \$(FILE_F77_INFO).ls " .
                                  "\$(FILE_F90_INFO).version \$(FILE_F90_INFO).ls " .
                                  "\$(FILE_CC_INFO).version  \$(FILE_CC_INFO).ls " .
                                  "\$(FILE_CXX_INFO).version \$(FILE_CXX_INFO).ls " .
                                  "\$(FILE_CUDA_INFO).version \$(FILE_CUDA_INFO).ls " .
                                  "\$(COMPILER_SETTINGS)";

# List of files that should not be included in a Makefile ALTHOUGH
# they are included into a source file via an 'include' statement.
# This list typically contains system header files like "mpif.h".
# Note:
# If an 'include' statement in a Fortran source file contains a
# relative or absolute path (and not only the file' basename), it
# will be included into the Makefile even when the file's basename
# is listed here.
use constant DO_NOT_INCLUDE => "";

# List of files that must be included as prerequisite of each
# object file.
use constant MUST_INCLUDE => "";

# List of header files that needed to be copied to object directory
# instead of being evaluated and then stored in object directory
# (This list typically consists of all files defining C preprocessor
#  macros that need to be evaluated when being included into a
#  Fortran source file.)
my $HEADER_FILES_TO_COPY =
    "$FEAT2BASEDIR/$SRCDIR_KERNEL/feat2constants.h " .
    "$FEAT2BASEDIR/$SRCDIR_KERNEL/feat2macros.h " .
    "$FEAT2BASEDIR/$SRCDIR_KERNEL/template.h " .
    "$FEAT2BASEDIR/$SRCDIR_KERNEL/DataStructures/arraylist.h " .
    "$FEAT2BASEDIR/$SRCDIR_KERNEL/DataStructures/list.h " .
    "$FEAT2BASEDIR/$SRCDIR_KERNEL/DataStructures/map.h " .
    "$FEAT2BASEDIR/$SRCDIR_KERNEL/DataStructures/quadtree.h " .
    "$FEAT2BASEDIR/$SRCDIR_KERNEL/DataStructures/octree.h " .
    "$FEAT2BASEDIR/$SRCDIR_KERNEL/DataStructures/stack.h " .
    "$FEAT2BASEDIR/$SRCDIR_KERNEL/DataStructures/casttogenobject.h " .
    "$FEAT2BASEDIR/$SRCDIR_KERNEL/DataStructures/uncastfromgenobject.h " .
    "$FEAT2BASEDIR/$SRCDIR_KERNEL/LinearSystem/lsyssc_scalarMatVec_latxd.h " .
    "$FEAT2BASEDIR/$SRCDIR_KERNEL/LinearSystem/lsyssc_scalarMatVec_lax79.h " .
    "$FEAT2BASEDIR/$SRCDIR_KERNEL/LinearSystem/lsyssc_scalarMatVec_lax79_padded.h " .
    "$FEAT2BASEDIR/$SRCDIR_KERNEL/LinearSystem/lsyssc_scalarMatVec_lax79intl1.h " .
    "$FEAT2BASEDIR/$SRCDIR_KERNEL/LinearSystem/lsyssc_scalarMatVec_lax79intld.h " .
    "$FEAT2BASEDIR/$SRCDIR_KERNEL/LinearSystem/lsyssc_scalarMatVec_lax9rowc.h " .
    "$FEAT2BASEDIR/$SRCDIR_KERNEL/LinearSystem/lsyssc_scalarMatVec_ltx79.h " .
    "$FEAT2BASEDIR/$SRCDIR_KERNEL/LinearSystem/lsyssc_scalarMatVecAux.h " .
    "$FEAT2BASEDIR/$SRCDIR_KERNEL/PDEOperators/afc.h " .
    "$FEAT2BASEDIR/$SRCDIR_KERNEL/PDEOperators/afcsc_buildVectorFCTScalar_doADIncrements.h " .
    "$FEAT2BASEDIR/$SRCDIR_KERNEL/PDEOperators/afcsc_buildVectorFCTScalar_doBounds.h " .
    "$FEAT2BASEDIR/$SRCDIR_KERNEL/PDEOperators/afcsc_buildVectorFCTScalar_doCorrect.h " .
    "$FEAT2BASEDIR/$SRCDIR_KERNEL/PDEOperators/afcsc_buildVectorFCTScalar_doCorrectScaleByMass.h " .
    "$FEAT2BASEDIR/$SRCDIR_KERNEL/PDEOperators/afcsc_buildVectorFCTScalar_doLimitEdgewise.h " .
    "$FEAT2BASEDIR/$SRCDIR_KERNEL/PDEOperators/afcsc_buildVectorFCTScalar_doLimitEdgewiseConstrained.h " .
    "$FEAT2BASEDIR/$SRCDIR_KERNEL/PDEOperators/afcsc_buildVectorFCTScalar_doLimitNodal.h " .
    "$FEAT2BASEDIR/$SRCDIR_KERNEL/PDEOperators/afcsc_buildVectorFCTScalar_doLimitNodalConstrained.h " .
    "$FEAT2BASEDIR/$SRCDIR_KERNEL/PDEOperators/afcsc_buildVectorFCTScalar_doMinModPrelimit.h " .
    "$FEAT2BASEDIR/$SRCDIR_KERNEL/PDEOperators/afcsc_buildVectorFCTScalar_doStdPrelimit.h " .
    "$FEAT2BASEDIR/$SRCDIR_KERNEL/PDEOperators/afcsc_buildFluxFCTScalar_doFluxesByMatrix.h " .
    "$FEAT2BASEDIR/$SRCDIR_KERNEL/PDEOperators/afcsc_buildFluxFCTScalar_doFluxesByCoeffs.h " .
    "$FEAT2BASEDIR/$SRCDIR_KERNEL/PDEOperators/afcsc_buildFluxFCTScalar_doDifferences.h " .
    "$FEAT2BASEDIR/$SRCDIR_KERNEL/System/fmath.h " .
    "$FEAT2BASEDIR/$SRCDIR_KERNEL/System/idxmanager.h";

# All header files referenced by Fortran 90 source files
# (format: name plus path, inode, md5 sum of content)
my %headerfiles   = ();

# Valid id to build for
my @valid_id      = ();

# Some auxiliary variables
my $objdir         = "";
my $objdir_lib     = "";
my $currentFile    = "";
my $oldEntry       = "";
my $make           = "";
my $makeversion    = "";
my $makeInMakefile = "";
my $defaultBuildID = "";
my $buildID        = "";
my $buildID_lib    = "";
my $counter        = 0;
my $warnings       = "";

# list of modules used in one file
my @module = ();

# hash for use when configuring benchmark applications
# It is not necessary to perform the very same tests for
# every benchmark application. When creating the meta Makefile
# for the benchmark folder these tests are performed.
# sub-configures are called with undocumented command line
# options that set these tested values such that the
# corresponding tests can be skipped.
my %cachedtests = ();

# variables for command line options
my %cl = ();

# defaults for Makefile variables
my %defaults = (
    AGMG                 => "NO",
    APPNAME              => "feat2app",
    APPONLYFLAGS         => [],
    AR                   => "",
    BINARY               => "STD",
    BUILDLIB             => [],
    CC                   => "",
    CFLAGSC              => [],
    CFLAGSCOPROC         => [],
    CFLAGSCXX            => [],
    CFLAGSCUDA           => [],
    CFLAGSF77            => [],
    CFLAGSF90            => [],
    COPROCLIST           => [],
    CPP                  => "",
    CXX                  => "",
    CUDA                 => "",
    F77                  => "",
    F90                  => "",
    FORCE_ID             => "NO",
    HEADER_FILES_TO_COPY => [],
    ID                   => "",
    INC                  => [],
    INTSIZE              => "STD",
    LD                   => "",
    LDFLAGS              => [],
    LIBDIR               => [],
    LIBS                 => [],
    MODE                 => "NO",   # deprecated
    MODEXTENSION         => "",
    MONITOR_COMPILE_ENV  => "YES",
    MOVEMOD              => "",
    MPI                  => "NO",
    MPIINC               => [],
    MPILIBDIR            => [],
    MPILIBS              => [],
    MPIWRAPPERS          => "NO",
    OBJDIR               => "",
    OBJDIR_LIB           => "",
    OPENMP               => "NO",
    OPT                  => "YES",
    PRECC                => "",
    PRECXX               => "",
    PRECUDA              => "",
    PREF77               => "",
    PREF90               => "",
    PRELD                => "",
    PROGRAMFILE          => "DETERMINED_ON_DEMAND_IF_UNSET",
    RANLIB               => "",
    RELINK_ALWAYS        => "YES",
    SRCEXTRA             => [],
    SRCEXTRA_APP         => [ "DETERMINED_ON_DEMAND_IF_UNSET" ],
    SRCLIST_APP          => [ "DETERMINED_ON_DEMAND_IF_UNSET" ],
    WARN                 => [],
);


# ===========================
# === Program starts here ===
#
#
@SIG{'INT', 'HUP', 'QUIT', 'PIPE'} = ('signal_handler') x 4;

#
# Parse command line
#
# If GetOptions() returns false, the function detected one or
# more errors during option parsing. So, this script should die.
#
# Pass the variables by reference (syntax: prefix them with a backslash),
# when passing an array explicitly
#
# Agreement: store command line options that directly translate into
# a Makefile variable (e.g. --opt => OPT) in capital letters, all
# remaining command line options (e.g. --runregressionbenchmark) in
# lower case.
my $unknownoption=0;
GetOptions (
            "no-agmg"                       => sub { $cl{'AGMG'} = 0 },
            "agmg:s"                        => \$cl{'AGMG'},
            "appname=s"                     => \$cl{'APPNAME'},
            "apponlyflags=s{0,}"            => \@{ $cl{'APPONLYFLAGS'} },
            "ar=s"                          => \$cl{'AR'},
            "binary=s"                      => \$cl{'BINARY'},
            "regressionbenchmark"           => \$cl{'regressionbenchmark'},
            "regression-benchmark"          => \$cl{'regressionbenchmark'},
            "buildlib=s{0,}"                => \@{ $cl{'BUILDLIB'} },
            # Store values given via --cached-* in a cache,
            # the related tests will be skipped, greatly speeding up
            # configure process.
            "cached-make-program=s"         => sub { $cachedtests{'make-program'} = $_[1]; },
            "cached-gnumake-version=s"      => sub { $cachedtests{'gnumake-version'} = $_[1]; },
            "cached-make-sets-make-var"     => sub { $cachedtests{'make-sets-make-var'} = 1; },
            "cached-build-id=s"             => sub { $cachedtests{'build-id'} = $_[1]; },
            "cc=s"                          => \$cl{'CC'},
            "cflagsc=s{0,}"                 => \@{ $cl{'CFLAGSC'} },
            "cflagscoproc=s{0,}"            => \@{ $cl{'CFLAGSCOPROC'} },
            "cflagscxx=s{0,}"               => \@{ $cl{'CFLAGSCXX'} },
            "cflagscuda=s{0,}"              => \@{ $cl{'CFLAGSCUDA'} },
            "cflagsf77=s{0,}"               => \@{ $cl{'CFLAGSF77'} },
            "cflagsf90=s{0,}"               => \@{ $cl{'CFLAGSF90'} },
	    "coproclist=s{0,}"              => \@{ $cl{'COPROCLIST'} },
            "cpp=s"                         => \$cl{'CPP'},
            "cuda=s"                        => \$cl{'CUDA'},
            "cxx=s"                         => \$cl{'CXX'},
            "debug"                         => \$cl{'debug'},
            "f77=s"                         => \$cl{'F77'},
            "f90=s"                         => \$cl{'F90'},
            "force-id"                      => \$cl{'FORCE_ID'},
            "help"                          => \$cl{'help'},
            "header-files-to-copy=s{0,}"    => \@{ $cl{'HEADER_FILES_TO_COPY'} },
            "int-size=s"                    => \$cl{'INTSIZE'},
            "id=s"                          => \$cl{'ID'},
            "inc=s"                         => \@{ $cl{'INC'} },
            "ld=s"                          => \$cl{'LD'},
            "ldflags=s{0,}"                 => \@{ $cl{'LDFLAGS'} },
            "libdir=s{0,}"                  => \@{ $cl{'LIBDIR'} },
            "libs=s{0,}"                    => \@{ $cl{'LIBS'} },
            "list-all-ids"                  => \$cl{'listallids'},
            "list-app-modules"              => \$cl{'listappmodules'},
            "list-ids"                      => \$cl{'listids'},
            "list-kernel-modules"           => \$cl{'listkernelmodules'},
            "listallids"                    => \$cl{'listallids'},
            "listids"                       => \$cl{'listids'},
            "make=s"                        => \$cl{'make'},
            "makefile=s"                    => \$cl{'makefile'},
            "mode=s"                        => sub { if ($_[1] =~ m/\bparallel\b/i) {
							 $cl{'MPI'} = 1;
						     } elsif ($_[1] =~ m/\bserial\b/i) {
							 $cl{'MPI'} = 0;
						     } else {
							 $cl{'MODE'} = $_[1]; # in check_options() we'll throw an error
						     }
						   },  # deprecated, use --mpi=
            "modextension=s"                => \$cl{'MODEXTENSION'},
            "monitor-compile-env!"          => \$cl{'MONITOR_COMPILE_ENV'},
            "movemod=s"                     => \$cl{'MOVEMOD'},
            "no-mpi"                        => sub { $cl{'MPI'} = 0 },
            "mpi:s"                         => \$cl{'MPI'},
            "mpiinc=s{0,}"                  => \@{ $cl{'MPIINC'} },
            "mpilibdir=s{0,}"               => \@{ $cl{'MPILIBDIR'} },
            "mpilibs=s{0,}"                 => \@{ $cl{'MPILIBS'} },
            "mpiwrappers!"                  => \$cl{'MPIWRAPPERS'},
            "objdir-prefix=s"               => \$cl{'objdirprefix'},
            "objdir-lib-prefix=s"           => \$cl{'objdirlibprefix'},
            "no-openmp"                     => sub { $cl{'OPENMP'} = 0 },
            "openmp:s"                      => \$cl{'OPENMP'},
            "no-opt"                        => sub { $cl{'OPT'} = 0 },
            "opt:s"                         => \$cl{'OPT'},
            "parallel"                      => sub { $cl{'MPI'} = "yes" },
            "precc=s{0,}"                   => \$cl{'PRECC'},
            "precxx=s{0,}"                  => \$cl{'PRECXX'},
            "precuda=s{0,}"                 => \$cl{'PRECUDA'},
            "pref77=s{0,}"                  => \$cl{'PREF77'},
            "pref90=s{0,}"                  => \$cl{'PREF90'},
            "preld=s{0,}"                   => \$cl{'PRELD'},
            "programfile=s"                 => \$cl{'PROGRAMFILE'},
            "ranlib=s"                      => \$cl{'RANLIB'},
            "relink-always!"                => \$cl{'RELINK_ALWAYS'},
            "serial"                        => sub { $cl{'MPI'} = "no" },
            "srcextra=s{0,}"                => \@{ $cl{'SRCEXTRA'} },
            "srcextra_app=s"                => \@{ $cl{'SRCEXTRA_APP'} },
            "srclist_app=s"                 => \@{ $cl{'SRCLIST_APP'} },
            "suppressflags=s"               => \@{ $cl{'suppressflags'} },
            "version"                       => \$cl{'version'},
            "warn=s{0,}"                    => \@{ $cl{'WARN'} },
            ) || ($unknownoption=1);

$FEAT2BASEDIR = ".." if ($cl{'regressionbenchmark'});

# Show version if requested
&show_version() if ($cl{'version'});

# Show help if requested
&show_help() if ($cl{'help'});


# Check given command line options
&check_options();

print INITIAL_MESSAGE;

# Show values in debug mode
&debug_command_line_options() if ($cl{'debug'});

# Checking for variant of make
# We desperately need GNU make as MAKEFILE_INC heavily uses GNU Make extensions,
# so make sure we have GNU make as we have to invoke GNU make from this script.
&check_for_gnumake();

# Check whether make sets $(MAKE) variable
&check_make_sets_make_variable();

# Get build ID (needed to parse the target platform specific
# files for dependencies) from command line or determine
# the default one for current host.
$buildID = &get_buildID();
$buildID_lib = &get_buildID_lib();

# Show valid build IDs if requested
# (see below for a list restricted to current host. Can be executed
#  not before valid make version has been found and guess_id has been run.)
&list_all_ids() if ($cl{'listallids'});

# Show valid build IDs for current host if requested
&list_ids() if ($cl{'listids'});

# List modules when asked for it
&list_kernel_modules() if ($cl{'listkernelmodules'});
&list_app_modules()    if ($cl{'listappmodules'});

# Check whether build ID is valid (if not a subconfigure for benchmark application
# as then this test has already been performed by a directly preceding call of this
# script)
if (! defined($cachedtests{'build-id'})) {
    if (! &id_is_valid($buildID)) {
        die "\n$progname: ERROR:\n".
            "The build ID is not valid.\n" .
            "There is no such case handled in " .
            &concat_filename($FEAT2BASEDIR, $MAKEFILE_CPU_INC) . ".\n" .
            "I refuse to create a Makefile.\n";
    }
}

# Special feature coproc-bail-out:
# Refuse to create a Makefile in case coprocessor support is requested
# in combination with certain (unsupported) build IDs.
# Note that this has to be held synchroneous with fb2/master.configure
# and also note that there is another location in this file which needs
# updating whenever this is modified. Simply search for the next occurence of
# 'coproc-bail-out' (without the quotation marks)
my $entry = (defined($cl{'COPROCLIST'})) ? $cl{'COPROCLIST'} : $defaults{'COPROCLIST'};
# no support for *-*-*-psc-*, sx*-none-superux-f90-*, *-*-*-open64-*
if ($#{$entry} >= 0 &&
    ($buildID_lib =~ m/^[^-]+-[^-]+-[^-]+-(psc)-[^-]+$/ ||
     $buildID_lib =~ m/^[^-]+-[^-]+-[^-]+-(open64)-[^-]+$/ ||
     $buildID_lib =~ m/^sx[^-]+-none-superux-f90-[^-]+$/)) {
    # Create an empty Makefile to prevent breaking compilation of
    # complete benchmark just because configuring one application
    # failed.
    print "creating $MAKEFILE (with empty targets).\n";
    open(MAKEFILE_HDL, ">" , $MAKEFILE) or
        die "\n$progname: ERROR:\n" .
            "Cannot open file <$MAKEFILE> for writing: $!\n";
    print MAKEFILE_HDL
	"#!/usr/bin/env make\n" .
	"\n" .
	"default:\n" .
	"clean-app:\n" .
	"clean-libs:\n" .
	"clean:\n" .
	"getlibs:\n" .
	"id:\n" .
	"idonly:\n" .
	"libs:\n" .
	"purge:\n";
    close(MAKEFILE_HDL);

    # set error code on exit. The value is queried in fbenchmark2/bin/runregressiontest
    # (certain cases are known to fail and should not trigger an e-mail notification)
    $! = 15;
    die "\n$progname: ERROR:\n".
	"Coprocessor support is not available in combination with\n" .
	"Pathscale, Open64 and NEC compiler suites. Simply because the respective\n" .
	"Fortran compilers create symbol names that can not be cross-language\n" .
	"referenced in C code. I purposely refuse to create a Makefile.\n";
}

# Backup old Makefile if existent and has not zero size
if ( -e $MAKEFILE && -s $MAKEFILE ) {
    print "renaming existing $MAKEFILE to $MAKEFILE" . ".bak\n";
    rename($MAKEFILE, $MAKEFILE . ".bak") or
	die "\n$progname: ERROR:\n" .
	    "Failed to rename $MAKEFILE to $MAKEFILE" . ".bak.\n";
}

# Now, create either the FEAT2 regression directory meta Makefile
# or a Makefile for a simple FEAT2 application
if ($cl{'regressionbenchmark'}) {
    &create_feastBenchmarkMakefile();
    # Loop over all subdirectories matching src_* and
    # configure the FEAT2 benchmark applications
    opendir(DIRECTORY, ".") ||
        die "\n$progname: ERROR:\n" .
            "Can't open directory . for reading. This is supposed never to happen!\n";
    my @srcdirs = grep /^(kernel_|apps_|area51_)/, readdir DIRECTORY;
    my $cwd = &cwd();

    # Pipe through command line options of regression benchmark configure
    # call to benchmark applications' configure
    my $options = "";
    $options .= " --agmg=\""           . $cl{'AGMG'}                       . "\"" if (defined($cl{'AGMG'}) && $cl{'AGMG'});
    $options .= " --apponlyflags=\""   . join(',', @{$cl{'APPONLYFLAGS'}}) . "\"" if ($#{$cl{'APPONLYFLAGS'}}  >= 0);
    $options .= " --binary=\""         . $cl{'BINARY'}                     . "\"" if (defined($cl{'BINARY'}) && $cl{'BINARY'});
    $options .= " --buildlib=\""       . join(',', @{$cl{'BUILDLIB'}})     . "\"" if ($#{$cl{'BUILDLIB'}} >= 0);
    $options .= " --cc=\""             . $cl{'CC'}                         . "\"" if (defined($cl{'CC'}) && $cl{'CC'});
    $options .= " --cflagsc=\""        . join(',', @{$cl{'CFLAGSC'}})      . "\"" if ($#{$cl{'CFLAGSC'}} >= 0);
    $options .= " --cflagscoproc=\""   . join(',', @{$cl{'CFLAGSCOPROC'}}) . "\"" if ($#{$cl{'CFLAGSCOPROC'}} >= 0);
    $options .= " --cflagscxx=\""      . join(',', @{$cl{'CFLAGSCXX'}})    . "\"" if ($#{$cl{'CFLAGSCXX'}} >= 0);
    $options .= " --cflagscuda=\""     . join(',', @{$cl{'CFLAGSCUDA'}})   . "\"" if ($#{$cl{'CFLAGSCUDA'}} >= 0);
    $options .= " --cflagsf77=\""      . join(',', @{$cl{'CFLAGSF77'}})    . "\"" if ($#{$cl{'CFLAGSF77'}} >= 0);
    $options .= " --cflagsf90=\""      . join(',', @{$cl{'CFLAGSF90'}})    . "\"" if ($#{$cl{'CFLAGSF90'}} >= 0);
    $options .= " --coproclist=\""     . join(',', @{$cl{'COPROCLIST'}})   . "\"" if ($#{$cl{'COPROCLIST'}} >= 0);
    $options .= " --cpp=\""            . $cl{'CPP'}                        . "\"" if (defined($cl{'CPP'}) && $cl{'CPP'});
    $options .= " --cuda=\""           . $cl{'CUDA'}                       . "\"" if (defined($cl{'CUDA'}) && $cl{'CUDA'});
    $options .= " --cxx=\""            . $cl{'CXX'}                        . "\"" if (defined($cl{'CXX'}) && $cl{'CXX'});
    $options .= " --debug"                                                        if (defined($cl{'debug'}) && $cl{'debug'});
    $options .= " --f77=\""            . $cl{'F77'}                        . "\"" if (defined($cl{'F77'}) && $cl{'F77'});
    $options .= " --f90=\""            . $cl{'F90'}                        . "\"" if (defined($cl{'F90'}) && $cl{'F90'});
    $options .= " --force-id"                                                     if (defined($cl{'FORCE_ID'}) && $cl{'FORCE_ID'} eq "YES");
    $options .= " --header-files-to-copy=\"" . join(',', @{$cl{'HEADER_FILES_TO_COPY'}}) . "\"" if ($#{$cl{'HEADER_FILES_TO_COPY'}} >= 0);
    $options .= " --id=\""             . $cl{'ID'}                         . "\"" if (defined($cl{'ID'}) && $cl{'ID'});
    $options .= " --inc=\""            . join(',', @{$cl{'INC'}})          . "\"" if ($#{$cl{'INC'}} >= 0);
    $options .= " --int-size=\""       . $cl{'INTSIZE'}                    . "\"" if (defined($cl{'INTSIZE'}) && $cl{'INTSIZE'});
    $options .= " --ld=\""             . $cl{'LD'}                         . "\"" if (defined($cl{'LD'}) && $cl{'LD'});
    $options .= " --ldflags=\""        . join(',', @{$cl{'LDFLAGS'}})      . "\"" if ($#{$cl{'LDFLAGS'}} >= 0);
    $options .= " --libdir=\""         . join(',', @{$cl{'LIBDIR'}})       . "\"" if ($#{$cl{'LIBDIR'}} >= 0);
    $options .= " --libs=\""           . join(',', @{$cl{'LIBS'}})         . "\"" if ($#{$cl{'LIBS'}} >= 0);
    $options .= " --list-app-modules"                                             if (defined($cl{'listappmodules'}) && $cl{'listappmodules'});
    # option $cl{'make'} does not need to be passed as it is passed as
    # a cached value anyway!
    $options .= " --makefile=\""       . $cl{'makefile'}                   . "\"" if (defined($cl{'makefile'}) && $cl{'makefile'});
    $options .= " --mode=\""           . $cl{'MODE'}                       . "\"" if (defined($cl{'MODE'}) && $cl{'MODE'});
    $options .= " --modextension=\""   . $cl{'MODEXTENSION'}               . "\"" if (defined($cl{'MODEXTENSION'}) && $cl{'MODEXTENSION'});
    $options .= " --monitor-compile-env"                                          if (defined($cl{'MONITOR_COMPILE_ENV'}) && $cl{'MONITOR_COMPILE_ENV'} eq "YES");
    $options .= " --no-monitor-compile-env"                                       if (defined($cl{'MONITOR_COMPILE_ENV'}) && $cl{'MONITOR_COMPILE_ENV'} eq "NO");
    $options .= " --movemod=\""        . $cl{'MOVEMOD'}                    . "\"" if (defined($cl{'MOVEMOD'}) && $cl{'MOVEMOD'});
    $options .= " --mpi=\""            . $cl{'MPI'}                        . "\"" if (defined($cl{'MPI'}) && $cl{'MPI'});
    $options .= " --mpiinc=\""         . join(',', @{$cl{'MPIINC'}})       . "\"" if ($#{$cl{'MPIINC'}} >= 0);
    $options .= " --mpilibdir=\""      . join(',', @{$cl{'MPILIBDIR'}})    . "\"" if ($#{$cl{'MPILIBDIR'}} >= 0);
    $options .= " --mpilibs=\""        . join(',', @{$cl{'MPILIBS'}})      . "\"" if ($#{$cl{'MPILIBS'}} >= 0);
    $options .= " --mpiwrappers"                                                  if (defined($cl{'MPIWRAPPERS'}) && $cl{'MPIWRAPPERS'} eq "YES");
    $options .= " --no-mpiwrappers"                                               if (defined($cl{'MPIWRAPPERS'}) && $cl{'MPIWRAPPERS'} eq "NO");
    $options .= " --objdir-prefix=\""     . $cl{'objdirprefix'}            . "\"" if (defined($cl{'objdirprefix'}) && $cl{'objdirprefix'});
    $options .= " --objdir-lib-prefix=\"" . $cl{'objdirlibprefix'}         . "\"" if (defined($cl{'objdirlibprefix'}) && $cl{'objdirlibprefix'});
    $options .= " --openmp=\""         . $cl{'OPENMP'}                     . "\"" if (defined($cl{'OPENMP'}) && $cl{'OPENMP'});
    $options .= " --opt=\""            . $cl{'OPT'}                        . "\"" if (defined($cl{'OPT'}) && $cl{'OPT'});
    $options .= " --precc=\""          . $cl{'PRECC'}                      . "\"" if (defined($cl{'PRECC'}) && $cl{'PRECC'});
    $options .= " --precxx=\""         . $cl{'PRECXX'}                     . "\"" if (defined($cl{'PRECXX'}) && $cl{'PRECXX'});
    $options .= " --precuda=\""        . $cl{'PRECUDA'}                    . "\"" if (defined($cl{'PRECUDA'}) && $cl{'PRECUDA'});
    $options .= " --pref77=\""         . $cl{'PREF77'}                     . "\"" if (defined($cl{'PREF77'}) && $cl{'PREF77'});
    $options .= " --pref90=\""         . $cl{'PREF90'}                     . "\"" if (defined($cl{'PREF90'}) && $cl{'PREF90'});
    $options .= " --preld=\""          . $cl{'PRELD'}                      . "\"" if (defined($cl{'PRELD'}) && $cl{'PRELD'});
    # --parallel skipped as it is an alternative for --mode=".." only
    $options .= " --ranlib=\""         . $cl{'ranlib'}                     . "\"" if (defined($cl{'RANLIB'}) && $cl{'RANLIB'});
    $options .= " --relink-always"                                                if (defined($cl{'RELINK_ALWAYS'}) && $cl{'RELINK_ALWAYS'} eq "YES");
    $options .= " --no-relink-always"                                             if (defined($cl{'RELINK_ALWAYS'}) && $cl{'RELINK_ALWAYS'} eq "NO");
    # --serial skipped as it is an alternative for --mode=".." only
    $options .= " --srcextra=\"" . join(',', @{$cl{'SRCEXTRA'}}) . "\"" if ($#{$cl{'SRCEXTRA'}} >= 0);
    $options .= " --suppressflags=\"" . join(',', @{$cl{'suppressflags'}}) . "\"" if ($#{$cl{'suppressflags'}} >= 0);
    $options .= " --warn=\""          . join(',', @{$cl{'WARN'}})          . "\"" if ($#{$cl{'WARN'}} >= 0);

    foreach my $feastappdir (sort @srcdirs) {
        my $dir = &concat_filename($cwd, $feastappdir);
        print "\n\nEntering directory <$dir>.\n";
        chdir $feastappdir;
	# Ignore directory if no configure script available
	if ( -e "configure" ) {
	    # Call sub-configure with undocumented command line options
	    # that cause skipping of time-consuming (and, for benchmark
	    # applications' configure being sub-configure calls, redundant)
	    # sanity checks.
	    print "./configure --cached-make-program='$make' --cached-gnumake-version='$makeversion' --cached-make-sets-make-var --cached-build-id='$buildID' $options\n" if ($cl{'debug'});
	    system("./configure --cached-make-program='$make' --cached-gnumake-version='$makeversion' --cached-make-sets-make-var --cached-build-id='$buildID' $options");
	    # Catch errors
	    if ($? != 0) {
		$warnings .=
		    "*************************************************************\n" .
		    $progname.": WARNING:\n".
		    "Invoking configure in subdirectory <$feastappdir> returned\n" .
		    "error code " . ($? >> 8) . ". You might want to check.\n" .
		    "*************************************************************\n\n";
	    }
	} else {
	    $warnings .=
		"*************************************************************\n" .
		$progname.": WARNING:\n".
		"Skipping configure in subdirectory <$feastappdir> because\n" .
		"there is no configure script in that directory. You might\n" .
		"want to check.\n" .
		"*************************************************************\n\n";
	}
        print "Leaving directory <$dir>.\n";
        chdir "..";
    }
    if ($#srcdirs == -1) {
        $warnings .=
            "*************************************************************\n" .
            $progname.": WARNING:\n".
            "No subdirectory with any of the prefixes \"kernel_\", \"apps_\"\n" .
            "or \"area51_\" could be found. You might want to check.\n" .
            "*************************************************************\n\n";
    }
    closedir(DIRECTORY);
} else {
    my @srclist_app = &get_sourcefilelist();
    my @srcextra_app = &get_extrasourcefilelist();
    &create_feastAppMakefile(\@srclist_app,\@srcextra_app);
    # Some prose at the end
    &print_statistics_about_feastAppMakefile(\@srclist_app,\@srcextra_app);
}

if ($warnings ne "") {
    warn $warnings;
}









# ===============================
# === Some internal functions ===

# Function: Check for GNU make and version
sub check_for_gnumake {
    if (defined($cachedtests{'make-program'})) {
        # sub-configure calls when configuring regression benchmark
        # applications can skip the test as it has already been
        # performed earlier.
        $make = $cachedtests{'make-program'};

    } else {
        # This is a simple configure of one FEAT2 application

        # If a special 'make' was specified on command line, use it,
        # otherwise you the default 'make'.
        print "checking whether environment sets \$MAKE... ";
        if ($ENV{'MAKE'}) {
            print "yes\n";
            $make = $ENV{'MAKE'};

            # Both $MAKE (env variable) and --make= (command line option) given.
            if (defined($cl{'make'}) && $cl{'make'} ne "") {
                $warnings .=
                    "*************************************************************\n" .
                    $progname.": WARNING:\n".
                    "make program $cl{'make'} given via the command line will\n" .
                    "override the environment variable setting of \$MAKE.\n" .
                    "*************************************************************\n\n";
                $make  = $cl{'make'};
            }
        } else {
            print "no\n";
            # Make not set via environment, use 'make' as default value
            $make = "make";
            if (defined($cl{'make'})) {
                # Use make program given as command line option.
                $make = $cl{'make'};
            }
        }
    }

    print "checking whether $make is GNU make... ";
    if (defined($cachedtests{'gnumake-version'})) {
        # sub-configure calls when configuring regression benchmark
        # applications can skip the test as it has already been
        # performed earlier.
        print "yes (cached)\n";

    } else {
        # This is a simple configure of one FEAT2 application

        $makeversion = `$make --version 2>/dev/null`;
        if ($makeversion =~ m/^GNU Make/i) {
            print "yes\n";
        } else {
            print "no\n";
            die "\n$progname: ERROR:\n".
                "Sorry, GNU Make >= 3.80 is required to create and, later on, use the Makefile.\n" .
                "<$make>, however, is not GNU Make.\n" .
                "Please use '--make=PROG' to specify a valid instance of GNU make or set the\n" .
                "environment variable \$MAKE accordingly.\n";
        }
    }

    # Checking for version of make
    # We need at least 3.80.
    print "checking whether $make is GNU make version >= 3.80... ";
    if (defined($cachedtests{'gnumake-version'})) {
        # sub-configure calls when configuring regression benchmark
        # applications can skip the test as it has already been
        # performed earlier.
        print $cachedtests{'gnumake-version'} . ", yes (cached)\n";

    } else {
        # Re-use the return value of the previous 'make --version' call.
        $makeversion =~ s/^GNU Make.* (\d*\.[\d\.]*).*$/$1/s;
        if ($makeversion =~ m/^(3\.[8-9].*|[4-9]\.\d.*)$/) {
            print "$makeversion, yes\n";
        } else {
            print "$makeversion, no\n";
            die "\n$progname: ERROR:\n".
                "Sorry, GNU Make >= 3.80 is required to create and, later on, use the Makefile.\n" .
                "<$make>, however, is $makeversion.\n" .
                "Please use '--make=PROG' to specify a valid instance of GNU make or set the\n" .
                "environment variable \$MAKE accordingly.\n";
        }
    }
}



# Function: Check whether make sets $(MAKE) variable
sub check_make_sets_make_variable {
    # Checking for setting of $(MAKE) variable
    print "checking whether $make sets \${MAKE}... ";
    if (defined($cachedtests{'make-sets-make-var'})) {
        # sub-configure calls when configuring regression benchmark
        # applications can skip the test as it has already been
        # performed earlier.
        print "yes (cached)\n";
        $makeInMakefile = "\$(MAKE)";

    } else {
        my $tmpfile = POSIX::tmpnam();
        open(TMPFILE, ">", $tmpfile) or
            die "\n$progname: ERROR:\n".
	        "Cannot open file <$tmpfile> for writing: $!\n";
        print TMPFILE "all:\n\t\@echo 'maketemp=\"\${MAKE}\"'";
        close(TMPFILE);
        my $currentString = `$make -f $tmpfile | grep maketemp=`;
        unlink($tmpfile);
        undef $tmpfile;

        # If $(MAKE) variable is set, use $(MAKE) in Makefile rules instead of
        # hardcoding the value of $make.
        # Reason: Submake processes only know of each other when using $(MAKE),
        # not if they are called like an ordinary program, even if the program
        # name used is 'make'.
        # Consequence: Parallel make may fail!
        # Note: This should never fail as GNU Make sets $(MAKE).
        if ($currentString ne "") {
            print "yes\n";
            $makeInMakefile = "\$(MAKE)";
        } else {
            print "no\n";
            $makeInMakefile = $make;
        }
    }
}


# Function: Check whether command line options make sense and normalise them
#           (i.e. capitalise if needed, remove duplicates etc.)
sub check_options {
    my $cloption = "";

    # First detect if any unknown option has been given
    if ($unknownoption) {
	die "\n$progname: ERROR:\n".
           INITIAL_MESSAGE .
           "Unknown option(s) found: " . join(' ', @ARGV) . "\n" .
           (" " x (length($progname)+2)) . "Check options specified on command line or in your local\n" .
           (" " x (length($progname)+2)) . "configure script.\n";
    }

    # Now detect a wrong use of command line options, check whether
    # we have still command line arguments after processing all valid
    # command line options. (Only strings that do not start with '--'
    # are detected here.)
    if ($#ARGV > -1) {
	die "\n$progname: ERROR:\n".
           INITIAL_MESSAGE .
            "Unknown option(s) found: " . join(' ', @ARGV) . "\n" .
            "Check options specified on command line or in your local configure script.\n" .
            "Try `$progname --help' for more information.\n";
    }

    # For options that can take multiple strings, whitespace and comma-separated
    # lists of values and multiple instances of the option are allowed.
    # Normalise the values by converting strings to real arrays.
    foreach my $entry ('APPONLYFLAGS', 'BUILDLIB', 'CFLAGSC', 'CFLAGSCOPROC', 'CFLAGSCXX',
    		       'CFLAGSCUDA', 'CFLAGSF77', 'CFLAGSF90', 'COPROCLIST',
    		       'HEADER_FILES_TO_COPY', 'INC', 'LDFLAGS', 'LIBDIR', 'LIBS',
    		       'MPIINC', 'MPILIBDIR', 'MPILIBS', 'SRCEXTRA', 'SRCEXTRA_APP',
		       'SRCLIST_APP', 'WARN') {
    	# $cl{'...'} has been passed as an array to GetOptions()
    	# and as such is always defined. But is does not necessarily have
    	# entries: unset => #entries=-1; set, but empty => #entries=0
    	# So, don't test with perl function defined(). Test whether set.
    	if (defined($cl{$entry})) {
	    my $numentries = $#{$cl{$entry}};
    	    if ($numentries > -1) {
    		@{ $cl{$entry} } = split(/\s+/,
    					 join(' ',
    					      split(/,/,
    						    join(',', @{ $cl{$entry} })
    					      )));
    	    }
	    # Converting comma-separated entries into space-separated
	    # ones may only increase the number of array entries, not
	    # reduce them. If an array merely contained an empty
	    # string, though, that string got removed by the previous
	    # block. Re-add it.
	    if ($numentries > $#{$cl{$entry}}) {
		push @{ $cl{$entry} }, " ";
	    }
    	}
    }

    # For this list only commas are allowed to separate things.
    # (Because sometimes options are to be filtered that are space-separated.)
    @{$cl{'suppressflags'}} = split(/,/, join(',', @{$cl{'suppressflags'}}));

    # Do not allow whitespace-only values for OBJDIR_PREFIX and OBJDIR_LIB_PREFIX
    if (defined($cl{'objdirprefix'}) && $cl{'objdirprefix'} =~ m/^\s*$/) {
	die "\n$progname: ERROR:\n".
	    INITIAL_MESSAGE .
            "Argument to --objdir-prefix must not contain whitespace characters only.\n" .
            "Try `$progname --help' for more information.\n";
    }
    if (defined($cl{'objdirlibprefix'}) && $cl{'objdirlibprefix'} =~ m/^\s*$/) {
	die "\n$progname: ERROR:\n".
	    INITIAL_MESSAGE .
            "Argument to --objdir-lib-prefix must not contain whitespace characters only.\n" .
            "Try `$progname --help' for more information.\n";
    }

    # Linking will fail (at least on Ubuntu 12.04) if the only reference to
    # the object directory in the linker command is given by "-L~/<some
    # path>". "~/" needs to be resolved.
    if (defined($cl{'objdirprefix'}) && $cl{'objdirprefix'} =~ m/^~\//) {
	$cl{'objdirprefix'} =~ s/^~\//$ENV{HOME}\//;
    }
    if (defined($cl{'objdirlibprefix'}) && $cl{'objdirlibprefix'} =~ m/^~\//) {
	$cl{'objdirlibprefix'} =~ s/^~\//$ENV{HOME}\//;
    }

    # Override default setting for Makefile name?
    $MAKEFILE = $cl{'makefile'} if (defined($cl{'makefile'}));


    # Special treatment of --opt/--no-opt/--opt=expensive|native|native-expensive
    # option, as well as --mpi/--no-mpi, --openmp/--no-openmp.
    # The problem is that we want to provide a consistent way to specify
    # optimisation levels: --opt, --no-opt (as with every other switch),
    # but also want to allow for arguments: --opt=expensive|native|native-expensive.
    #
    # There is no easy way to immediately allow this with Getopt::Long.
    #
    # Exploit the facts that
    # * $cl{'OPT'} is uninitialised by default
    # * $cl{'OPT'} has an empty value when --opt has been specified
    # * $cl{'OPT'} has value 0 when --no-opt has been specified
    # * $cl{'OPT'} has value "string" when --opt="string" has been specified
    foreach my $entry ('AGMG', 'MPI', 'OPT', 'OPENMP') {
	if (defined($cl{$entry})) {
	    $cl{$entry} = 1 if ($cl{$entry} eq "");
	}
    }

    # Special feature for Sven who always forgets the correct
    # keyword for all-in-optimisation: it's "expensive".
    if ($ENV{'MAKEFLAGS'}) {
	$ENV{'MAKEFLAGS'} =~ s/\bOPT=(EXPENSIVE|EXTREME|EXTENDED|MASSIVE)\b/OPT=EXPENSIVE/ig;
    }

    # Now check whether some options are inherited via MAKEFLAGS and
    # given as command line arguments. Include binary options here, i.e.
    # options that do not take an argument (e.g. --force-id, --opt)
    # because of agreement no.3 (see below).
    #
    # Agreement:
    # * Environment variable values take precedence over
    #   command line options
    # * Values are converted to upper case for the Makefile
    # * 0/1 values are mapped to NO/YES for the Makefile
    foreach my $entry ('AGMG', 'BINARY', 'FORCE_ID', 'INTSIZE', 'MODE',
		       'MONITOR_COMPILE_ENV', 'MPI', 'MPIWRAPPERS',
		       'OPENMP', 'OPT', 'RELINK_ALWAYS') {
	# Check environment variable MAKEFLAGS and give a warning if
	# options given via environment *and* command line collide.
	if ($ENV{'MAKEFLAGS'}) {
	    if ($ENV{'MAKEFLAGS'} =~ /\b$entry=(.+?)\b/i) {
		my $envvalue = $1;
		# Capitalise value
		$envvalue =~ tr/a-z/A-Z/;
		# Map 0/1 values to NO/YES
		$envvalue = "NO"  if ($envvalue eq "0");
		$envvalue = "YES" if ($envvalue eq "1");

		if (defined($cl{$entry})) {
		    my $clvalue = $cl{$entry};
		    # Capitalise value
		    $clvalue =~ tr/a-z/A-Z/;
		    # Map 0/1 values to NO/YES
		    $clvalue = "NO"  if ($clvalue eq "0");
		    $clvalue = "YES" if ($clvalue eq "1");

		    # Value collision? Then issue a warning
		    if ($clvalue ne $envvalue) {
			# reconstruct name of command line option for variable
			$cloption = lc("--" . $entry);
			$cloption =~ s/_/-/g;
                        $warnings .=
			    "************************************************************************\n" .
			    $progname.": WARNING:\n" .
			    &format_filelist("", 0, 72,
					     "\$MAKEFLAGS contains \"$entry=$envvalue\" while \"" . $cloption .
					     "=$clvalue\" has been specified as well. Environment variables " .
					     "take precedence, will take \"$entry=$envvalue\" for the " .
					     "Makefile.\n", "", "") . "\n" .
			    "************************************************************************\n\n";
		    }
		} else {
		    # Treat an environment variable as if given via command line option.
		    $cl{$entry} = $envvalue;
		}
	    }
	}

	# Normal case: option not inherited by a make process (i.e. via MAKEFLAGS)
        # It cannot happen that an option is given directly via the environment,
        # as that would have triggered the unknown option error, we can now
        # proceed with capitalising and normalising values
	elsif (defined($cl{$entry})) {
	    # Capitalise value
	    $cl{$entry} =~ tr/a-z/A-Z/;
	    # Map 0/1 values to NO/YES
	    $cl{$entry} = "NO"  if ($cl{$entry} eq "0");
	    $cl{$entry} = "YES" if ($cl{$entry} eq "1");
	}
    }


    # Valid keywords? (both for options that take exactly one string and those that can take multiple)
    my %validkeywords = (
        "AGMG"                => [ "yes", "no" ],
	"BINARY"              => [ "std", "32", "64" ],
	"COPROCLIST"          => [ "cpu", "cuda10", "cuda11", "cuda12", "cuda13", "cuda20", "cuda21", "cuda30", "cuda35", "opengl" ],  # List of valid coprocessor backends
	"FORCE_ID"            => [ "yes", "no" ],
        "INTSIZE"             => [ "std", "large" ],
        "MPI"                 => [ "yes", "no" ],
        "MODE"                => [ "parallel", "serial" ],  # deprecated, use MPI=yes/no
	"MONITOR_COMPILE_ENV" => [ "yes", "no" ],
	"MPIWRAPPERS"         => [ "yes", "no" ],
        "OPENMP"              => [ "yes", "no" ],
	"OPT"                 => [ "yes", "no", "expensive", "native", "native-expensive" ],
	"RELINK_ALWAYS"       => [ "yes", "no" ],
	"WARN"                => [ "debug", "deprecated", "off", "unsupported", "unusual" ],
    );

    foreach my $entry (keys %validkeywords) {
	if (defined($cl{$entry})) {
	    if (ref($cl{$entry}) eq "") {
		# Dealing with a scalar value

		# Trim whitespace (not necessary?)
#	        $cl{$entry} =~ s/^\s*(\S*)\s*$/$1/;

		my $regexp = "^(" . join('|', @{ $validkeywords{$entry} }) . ')$';
		if ($cl{$entry} !~ m/$regexp/i) {
		    # reconstruct name of command line option from variable name
		    $cloption = lc("--" . $entry);
		    $cloption =~ s/_/-/g;
		    die "\n$progname: ERROR:\n".
			INITIAL_MESSAGE .
			"Unknown keyword for option $cloption: <$cl{$entry}>\n" .
			"Valid keywords are <" . join("> and <", @{ $validkeywords{$entry} }) . ">.\n" .
			"Try `$progname --help' for more information.\n";
		}

	    } elsif (ref($cl{$entry}) eq "ARRAY") {
		# Dealing with an array

		# convert array of valid keywords into hash for easier lookups
		my %isvalid = ();
		map { $isvalid{$_} = $_; } @{ $validkeywords{$entry} };

                # Check whether every keyword is a valid one.
		foreach my $key ( @{ $cl{$entry} } ) {
		    if (! defined($isvalid{$key})) {
			# reconstruct name of command line option from variable name
			$cloption = lc("--" . $entry);
			$cloption =~ s/_/-/g;
			die "\n$progname: ERROR:\n".
			    INITIAL_MESSAGE .
			    "Unknown keyword for option $cloption: <$key>\n" .
			    "Valid keywords are <" . join("> and <", @{ $validkeywords{$entry} }) . ">.\n" .
                            "Try '$progname --help' for more information.\n";
		    }
		}
		undef %isvalid;
	    } # end case command line option takes multiple values
	} # end case command line option has been given
    } # end loop over all command line options to test

    # Map deprecated MODE=PARALLEL/SERIAL to MPI=YES/NO
    if (defined($cl{'MODE'})) {
	warn "\n$progname: WARNING:\n".
	     "The use of --mode=<parallel,serial> is deprecated, use --[no-]mpi\n" .
	     "or --mpi=<yes,no> instead.\n\n";
	if ($cl{'MODE'} eq "PARALLEL") {
	    $cl{'MPI'} = "YES";
	} elsif ($cl{'MODE'} eq "SERIAL") {
	    $cl{'MPI'} = "NO";
	}
    }


    return;
}



# Function: Create Makefile for a FEAT2 application
sub create_feastAppMakefile {
    my $srclist_app = $_[0];
    my $srcextra_app = $_[1];
    my $entry;

    # Hash containing -- with special keywords -- all dependencies of
    # all files for which make_dep_list / get_dependency has been called.
    my %dependencyLists = ();

    # Hash for efficiently accessing entries in $cl{'HEADER_FILES_TO_COPY'}
    my %headerFilesToCopy = ();
    map { (my $entry = $_) =~ s|^.*/([^/]+)$|$1|; $headerFilesToCopy{$entry} = "" } @{ $cl{'HEADER_FILES_TO_COPY'}};

    &get_programsourcefile();
    print "creating dependency lists... ";

    # A hash that maps module file names to file system object (including path information)
    my %path = ();

    # Dependencies of each object file
    my $objectfiles_and_dependencies = "";
    # Determine Makefile dependency list for every kernel module object file
    foreach $entry (split(/\s+/, join(' ', SRCLIST_KERNEL))) {
	$path{$entry} = &concat_filename($FEAT2BASEDIR, $SRCDIR_KERNEL, $entry);
        $objectfiles_and_dependencies .=
            &make_dep_list(\%dependencyLists, $path{$entry},
                           "\$(SRCDIR_KERNEL)/" . $entry, 1, "o", "o",
                           "\$(OBJDIR)", \%headerFilesToCopy) . "\n\n";
    }

    # Dependencies of each object file from architecture-specific
    # kernel modules
    foreach $entry (split(/\s+/, join(' ', SRCLIST_ARCH))) {
	$path{$entry} = &concat_filename($FEAT2BASEDIR, $SRCDIR_ARCH, $entry);
        $objectfiles_and_dependencies .=
            &make_dep_list(\%dependencyLists, $path{$entry},
                           "\$(SRCDIR_ARCH)/" . $entry, 1, ".o", "o",
                           "\$(OBJDIR)", \%headerFilesToCopy) . "\n\n";
    }

    # Dependencies of each object file from application modules
    foreach $entry ( @{$srclist_app} ) {
	$path{$entry} = &concat_filename($SRCDIR_APP, $entry);
        $objectfiles_and_dependencies .=
	    &make_dep_list(\%dependencyLists, $path{$entry},
			   "\$(SRCDIR_APP)/" . $entry, 1, "o", "o",
			   "\$(OBJDIR)", \%headerFilesToCopy) . "\n\n";
    }

    # Dependencies of each object file from application extra source files
    foreach $entry ( @{$srcextra_app} ) {
	$path{$entry} = &concat_filename($SRCDIR_APP, $entry);
        $objectfiles_and_dependencies .=
	    &make_dep_list(\%dependencyLists, $path{$entry},
			   "\$(SRCDIR_APP)/" . $entry, 1, "o", "o",
			   "\$(OBJDIR)", \%headerFilesToCopy) . "\n\n";
    }

    # Dependencies of program file
#    $entry = ((defined($cl{'PROGRAMFILE'})) ? $cl{'PROGRAMFILE'} : $defaults{'PROGRAMFILE'});
    $entry = &get_programsourcefile();
	$path{$entry} = $entry;
        $objectfiles_and_dependencies .=
	    &make_dep_list(\%dependencyLists, $path{$entry},
			   $entry, 1, "o", "o",
			   "\$(OBJDIR)", \%headerFilesToCopy) . "\n\n";

    # Dependencies of Fortran 90 files listed in Makefile variable $(SRCEXTRA)
    # can not be determined unfortunately at configure time. Because they may
    # be defined using Makefile variables (e.g. $(FEAT2BASEDIR)/kernel/arch/amub.f90)
    # which cannnot easily be expanded by configure.
    $objectfiles_and_dependencies .=
	"# Dependencies of Fortran 90 files listed in Makefile variable \$(SRCEXTRA)\n" .
	"# can not be determined unfortunately at configure time and incorporated into\n" .
	"# this Makefile. Because the path to these files or the files themselves may\n" .
	"# be defined using Makefile variables (e.g. \$(FEAT2BASEDIR)/kernel/arch/amub.f90)\n" .
	"# whose value cannnot easily be expanded by configure.\n\n";

    print "done\n";

    # The instructions above ensure that for all FEAT2 source files
    # a dependency list is written to the Makefile. Later, (generic)
    # compile rule will be added.
    # But sometimes, some source files are not required for a particular
    # application. The dependency list of the application itself and the
    # link command should only contain the files that are really referenced.
    # In other words, if module A is not referenced anywhere, it should neither
    # be compiled nor included in the application binary.
    # Hence, loop again through (possibly all) files, starting
    # with the program file, to find out which FEAT2 kernel files are really
    # used. This could not be done previously as previously the loop forcibly
    # was over all source files.
    #
    # Remark: To avoid i/o redundancy, i.e. to not open and parse source
    # files again, the cached results of previous get_dependency() calls
    # are used. It makes a small difference (12-15% faster).
    my @modulesToParse;
#    push @modulesToParse, ((defined($cl{'PROGRAMFILE'})) ? $cl{'PROGRAMFILE'} : $defaults{'PROGRAMFILE'});
    push @modulesToParse, &get_programsourcefile();
    my %modulesParsed;
    my $i = -1;
    while ($i < $#modulesToParse) {
	$i++;
	# remove any path information
	my $currentFile = &get_filename($modulesToParse[$i]);

	# Skip file if it has already been parsed.
	next if (defined($modulesParsed{$currentFile}));

	# Set flag that the files has already been parsed to
	# prevent duplicate parsing.
	$modulesParsed{$currentFile} = 1;

	# Reuse the cached list of dependencies (modules and include files)
	foreach my $entry (@{ $dependencyLists{$currentFile} }) {
	    # Module?
	    if ($entry =~ m/^module:(.+)$/) {
		push @modulesToParse, $1 . ".f90";
	    }
	}
    }
    undef $i;
    my @requiredObjFiles;
    foreach my $entry (sort keys %modulesParsed) {
	$entry =~ s/^(.*)\.f90$/\$(OBJDIR)\/$1.o/;
	push @requiredObjFiles, $entry;
    }

    #
    # Start to create the Makefile
    #
    print "creating $MAKEFILE.\n";
    open(MAKEFILE_HDL, ">" , $MAKEFILE) or
	die "\n$progname: ERROR:\n".
	    "Cannot open file <$MAKEFILE> for writing: $!\n";

    # Create head section: include global Makefile settings,
    # specifying the application name, sbblas version
    print MAKEFILE_HDL
        "#!/usr/bin/env make\n" .
        "\n" .

	"########################################################################\n" .
	"#                                                                      #\n" .
	"#                   FINITE ELEMENT ANALYSIS TOOLS 2                    #\n" .
	"#                                                                      #\n" .
	"# Authors: M. Koester, M. Moeller, S. Turek, S. Buijssen               #\n" .
	"#                                                                      #\n" .
	"#                                                                      #\n" .
	"# Contact: Applied Mathematics, TU Dortmund University                 #\n" .
	"#          Vogelpothsweg 87, 44227 Dortmund                            #\n" .
	"#          Germany                                                     #\n" .
	"#                                                                      #\n" .
	"# Web:     http://www.featflow.de/en/software/featflow2.html           #\n" .
	"#          mailto:featflow\@featflow.de                                 #\n" .
	"#                                                                      #\n" .
	"########################################################################\n" .
        "#                                                                      #\n";
    $entry = (defined($cl{'APPNAME'})) ? $cl{'APPNAME'} : $defaults{'APPNAME'};
    print MAKEFILE_HDL
        "# Makefile for application $entry for architecture:" .
	(" " x (26 - length($entry))) . "#\n" .
        "#          " . $buildID . (" " x (60 - length($buildID))) . "#\n" .
        "#                                                                      #\n" .
        "# Automatically generated by:                                          #\n";
    $entry = &get_version();
    print MAKEFILE_HDL
        "#          FEAT2-configure script " . $entry . (" " x (36 - length($entry))) . "#\n" .
	"########################################################################\n" .
	"\n";

    if (defined($cl{'ID'})) {
	print MAKEFILE_HDL
	    "# Fix a particular build ID, do not use the default one\n" .
	    "# (There are Makefile rules that will verify that the given build ID\n" .
	    "#  fits to the archicecture, cpu and operating system at make runtime.)\n" .
	    "ID                   := $cl{'ID'}\n\n";
    }
    print MAKEFILE_HDL
        "# Path to this FEAT2 installation\n" .
        "FEAT2BASEDIR          = " . $FEAT2BASEDIR . "\n\n" .
        "# Location of Makefile.buildID.inc\n" .
        "MAKEFILE_BUILDID_INC  = \$(FEAT2BASEDIR)/" . $MAKEFILE_BUILDID_INC . "\n\n" .
        "# Location of Makefile.cpu.inc\n" .
        "MAKEFILE_CPU_INC      = \$(FEAT2BASEDIR)/" . $MAKEFILE_CPU_INC . "\n\n";
    $entry = (defined($cl{'OPT'})) ? $cl{'OPT'} : $defaults{'OPT'};
    print MAKEFILE_HDL
        "# For development and debugging turn this to \"NO\", for good\n" .
        "# optimisation to \"YES\". To squeeze out the last bit of performance out\n" .
        "# of your machine (at the expense of a possibly drastic increase in compile\n" .
        "# compile time) enable full optimisation with \"EXPENSIVE\".\n" .
        "# If you want to compile your code to run maybe exclusively on the build host\n" .
        "# use \"NATIVE\" or \"NATIVE-EXPENSIVE\" to enable\n" .
	"OPT                 = $entry\n\n";

    $entry = (defined($cl{'AGMG'})) ? $cl{'AGMG'} : $defaults{'AGMG'};
    print MAKEFILE_HDL
        "# Create binary with AGMG support?\n" .
        "AGMG                = $entry\n\n";

    $entry = (defined($cl{'APPNAME'})) ? $cl{'APPNAME'} : $defaults{'APPNAME'};
    print MAKEFILE_HDL
        "# Application name\n" .
        "APPNAME             = $entry\n\n";

    $entry = (defined($cl{'BINARY'})) ? $cl{'BINARY'} : $defaults{'BINARY'};
    print MAKEFILE_HDL
        "# Defines the binary type.\n" .
	"# =STD : Standard code environment of the system.\n" .
        "# =32  : Force 32-bit code environment.\n" .
        "# =64  : Force 64-bit code environment.\n" .
        "BINARY              = $entry\n\n";

    $entry = (defined($cl{'FORCE_ID'})) ? $cl{'FORCE_ID'} : $defaults{'FORCE_ID'};
    print MAKEFILE_HDL
        "# Force using given build ID, skip tests that verify that the given\n" .
        "# build ID fits to the current archicecture, cpu and operating system\n" .
        "FORCE_ID            = $entry\n\n";

    $entry = (defined($cl{'INTSIZE'})) ? $cl{'INTSIZE'} : $defaults{'INTSIZE'};
    print MAKEFILE_HDL
        "# Defines the size of integers.\n" .
        "# =STD  : Standard integer size (32 bit integers).\n" .
        "# =LARGE: Large integers (64 bit integers). Supports arrays with > 4GB size and\n" .
        "#         enables the 64 bit interface of UMFPACK.\n" .
        "INTSIZE             = $entry\n\n";

    $entry = (defined($cl{'MONITOR_COMPILE_ENV'})) ? $cl{'MONITOR_COMPILE_ENV'} : $defaults{'MONITOR_COMPILE_ENV'};
    print MAKEFILE_HDL
        "# Enable checks whether compiler modification dates or compiler settings for\n" .
        "# current build ID have changed since last invocation of make?\n" .
        "MONITOR_COMPILE_ENV = $entry\n\n";

    $entry = (defined($cl{'RELINK_ALWAYS'})) ? $cl{'RELINK_ALWAYS'} : $defaults{'RELINK_ALWAYS'};
    print MAKEFILE_HDL
        "# Relink application every time make is invoked\n" .
        "# (i.e. regardless whether a source file has changed?)\n" .
        "# (Might be useful when developing on multiple platforms.)\n" .
        "RELINK_ALWAYS       = $entry\n\n";

    $entry = (defined($cl{'OPENMP'})) ? $cl{'OPENMP'} : $defaults{'OPENMP'};
    print MAKEFILE_HDL
        "# Create binary with OpenMP support?\n" .
        "OPENMP              = $entry\n\n";

#    $entry = (defined($cl{'MODE'})) ? $cl{'MODE'} : $defaults{'MODE'};
    $entry = (defined($cl{'MPI'})) ? $cl{'MPI'} : $defaults{'MPI'};
    print MAKEFILE_HDL
        "# Create binary for use with MPI?\n" .
        "MPI                 = $entry\n\n";

    $entry = (defined($cl{'MPIWRAPPERS'})) ? $cl{'MPIWRAPPERS'} : $defaults{'MPIWRAPPERS'};
    print MAKEFILE_HDL
        "# Create binary with or without mpi wrappers\n" .
        "MPIWRAPPERS         = $entry\n\n";

    $entry = (defined($cl{'COPROCLIST'})) ? $cl{'COPROCLIST'} : $defaults{'COPROCLIST'};
    print MAKEFILE_HDL
        "# Create binary with Coprocessor support?\n";

    if ($#{$entry} >= 0) {

	# convert array with coprocessors into hash for easier lookups
	my %coprocs = ();
	map { $coprocs{$_} = $_; } @{ $entry };

	foreach $entry ('cuda10', 'cuda11', 'cuda12', 'cuda13',
			'cuda20', 'cuda21', 'cuda30', 'cuda35') {
	    print MAKEFILE_HDL
		"HAS_" . uc($entry) . "          = ";
	    print MAKEFILE_HDL "YES\n" if (defined($coprocs{$entry}));
	    print MAKEFILE_HDL "NO\n" unless (defined($coprocs{$entry}));
	}

    }
    print MAKEFILE_HDL
	"\n";
    
    $entry = (defined($cl{'WARN'})) ? $cl{'WARN'} : $defaults{'WARN'};
    print MAKEFILE_HDL
        "# Create binary with Warnings enabled?\n";

    if ($#{$entry} >= 0) {

	# convert array with warnings into hash for easier lookups
	my %warns = ();
	map { $warns{$_} = $_; } @{ $entry };

	foreach $entry ('debug', 'deprecated', 'off', 'unsupported', 'unusual') {
	    print MAKEFILE_HDL
		"WARN_" . uc($entry) . "          = ";
	    print MAKEFILE_HDL "YES\n" if (defined($warns{$entry}));
	    print MAKEFILE_HDL "NO\n" unless (defined($warns{$entry}));
	}
    }
    print MAKEFILE_HDL
	"\n";

    ##############################################################################
    # Create section specifying source directories and source files
    print MAKEFILE_HDL
        "# source directories of sparse banded blas, kernel and application files\n" .
        "SRCDIR_KERNEL = \$(FEAT2BASEDIR)/" . $SRCDIR_KERNEL . "\n" .
        "SRCDIR_ARCH   = \$(FEAT2BASEDIR)/" . $SRCDIR_ARCH   . "\n" .
        "SRCDIR_APP    = " . $SRCDIR_APP    . "\n\n";


    # Determine object directories
    $objdir = OBJDIR;
    # The object directory for libraries should be shared among all
    # FEAT2 applications. By design, there is no dependency of a
    # library on the FEAT2 kernel or a FEAT2 application. Compiler
    # command line settings are identical for a library, regardless
    # the FEAT2 application that needs it.
    # FEAT2 applications are always stored two directory levels deeper
    # than the FEAT2 base directory where the libraries are.
    # The same structure should hold for object files:
    #    .../applications/poisson/object/<build ID>/
    #    .../applications/tutorial/object/<build ID>/
    #    .../object/<build ID>/
    $objdir_lib = File::Spec->catdir($FEAT2BASEDIR, OBJDIR_LIB);

    if ($cl{'objdirprefix'}) {
        # Prefix given for object directories, override defaults
        my $objdirprefix = $cl{'objdirprefix'};
        chomp($objdirprefix);

        # Try to remove path portion of $FEAT2BASEDIR.
        $objdirprefix =~ s/^\Q$FEAT2BASEDIR\E/\$(FEAT2BASEDIR)/;

        # Try to remove home directory portion of $FEAT2BASEDIR.
        $objdirprefix =~ s/^\Q$ENV{HOME}\E/\$(HOME)/;

	# append default name for object directories
        $objdir = File::Spec->catdir($objdirprefix, OBJDIR);
    }

    if ($cl{'objdirlibprefix'}) {
        # Prefix given for libraries' object directories, override defaults
        my $objdirlibprefix = $cl{'objdirlibprefix'};
        chomp($objdirlibprefix);

        # Try to remove path portion of $FEAT2BASEDIR.
        $objdirlibprefix =~ s/^\Q$FEAT2BASEDIR\E/\$(FEAT2BASEDIR)/;

        # Try to remove home directory portion of $FEAT2BASEDIR.
        $objdirlibprefix =~ s/^\Q$ENV{HOME}\E/\$(HOME)/;

	# append default name for object directories
        $objdir_lib = File::Spec->catdir($objdirlibprefix, OBJDIR_LIB);
    }
    print MAKEFILE_HDL
        "# Create an appropriate directory name for object files, based on build\n" .
        "# ID, execution mode and optimisation level.  \n" .
        "#\n" .
        "# Object directory for FEAT2 object files. Build ID already contains\n" .
        "# most of the necessary information (even choice of MPI in case of parallel mode)\n" .
        "# we simply have to distinguish here the optimisation level (on/off aka yes/no)\n" .
        "OBJDIR = " . $objdir . "-opt\$(OPT)\n" .
        "\n" .
        "# Object directory for libraries (third party tools)\n" .
        "OBJDIR_LIB = " . $objdir_lib . "-opt\$(OPT)\n" .
        "\n" .

        "# names of files for sparse banded blas, kernel (also platform specific)\n" .
        "# and application\n" .
        &format_list("SRCLIST_KERNEL = ", 8, 70, SRCLIST_KERNEL, "\\\n", "\\") . "\n" .
        &format_list("SRCLIST_ARCH   = ", 8, 70, SRCLIST_ARCH, "\\\n", "\\") . "\n";

    # Source file containing the Fortran keyword PROGRAM needs separate handling and
    # is not to be included in Makefile's SRCLIST_APP variable.
    # Convert array on the fly into a hash from which program file can be easily
    # deleted.
    my %srclist = ();
    map { $srclist{$_} = "" } @{$srclist_app};
#    delete $srclist{((defined($cl{'PROGRAMFILE'})) ? $cl{'PROGRAMFILE'} : $defaults{'PROGRAMFILE'})};
    delete $srclist{&get_programsourcefile()};

    print MAKEFILE_HDL
	&format_list("SRCLIST_APP    = ", 8, 70, join(' ', sort keys %srclist), "\\\n", "\\") . "\n";

    %srclist = ();
    map { $srclist{$_} = "" } @{$srcextra_app};

    print MAKEFILE_HDL
	&format_list("SRCEXTRA_APP   = ", 8, 70, join(' ', sort keys %srclist), "\\\n", "\\") . "\n";
    undef %srclist;

    print MAKEFILE_HDL
        &format_list("PROGRAM_FILE   = ", 8, 70, &get_programsourcefile(), "\\\n", "\\") . "\n\n";

    # The idea is to have only paths relative to FEAT2BASEDIR.
    # Substitute absolute path information accordingly.
    my @tmparray = ();
    foreach $entry (split(/\s+/, $HEADER_FILES_TO_COPY)) {
	my $file_PathUsingBasedir = $entry;
	$file_PathUsingBasedir =~ s/^\Q$FEAT2BASEDIR\E/\$(FEAT2BASEDIR)/;
	push @tmparray, $file_PathUsingBasedir;
    }
    foreach $entry (@{$cl{'HEADER_FILES_TO_COPY'}}) {
	my $file_PathUsingBasedir = $entry;
	$file_PathUsingBasedir =~ s/^\Q$FEAT2BASEDIR\E/\$(FEAT2BASEDIR)/;
	push @tmparray, $file_PathUsingBasedir;
    }
    print MAKEFILE_HDL
        "# Files included in source files that need to be copied, not evaluated by cpp\n" .
        &format_list("INCLUDED_FILES_TO_COPY = ", 8, 70,
		     join(' ', sort @tmparray), "\\\n", "\\") . "\n\n";
    undef @tmparray;

    # The idea is to have only paths relative to FEAT2BASEDIR.
    # Substitute absolute path information in %headerfiles accordingly.
    my %tmparray = ();
    foreach $entry (sort keys %headerfiles) {
        my $file_PathUsingBasedir = $headerfiles{$entry}->{'URI'};
	$file_PathUsingBasedir =~ s/^\Q$FEAT2BASEDIR\E/\$(FEAT2BASEDIR)/;
	# Remove relative paths. This approach is feasible as we can assume
	# that not many Feat2 users will do weird stuff with symbolic links
	# in their checkout. If they do, strange things may happen during 'make',
	# but then that's the users fault. If we would not remove the relative
	# path information here, 'make' would regularly complain about duplicate
	# definitions for e.g.
        # $(FEAT2BASEDIR)/kernel/Projection/intf_coefficientVectorSc.inc
        # $(FEAT2BASEDIR)/kernel/Projection/intf_refFunctionSc.inc
	# as they are referenced both without path and with path in Feat2 sources:
        # $(FEAT2BASEDIR)/kernel/Projection/../DOFMaintenance/intf_coefficientVectorSc.inc
        # $(FEAT2BASEDIR)/kernel/Projection/../Postprocessing/intf_refFunctionSc.inc
	$file_PathUsingBasedir =~ s|/[^/]+/\.\./|/|;
	$tmparray{$file_PathUsingBasedir} = 1;
    }
    print MAKEFILE_HDL
        "# Files included in source files that need to be evaluated by cpp\n" .
        &format_list("INCLUDED_FILES_TO_EVALUATE_WITH_CPP = ", 8, 70,
		     join(' ', sort keys %tmparray), "\\\n", "\\") . "\n\n";
    undef %tmparray;

    # Create section where the source directories and files are put together
    # and the object files resulting from them.
    print MAKEFILE_HDL
        "# List of all Fortran 77 source files\n" .
	"SRCF77   = \$(filter %.f, \\\n" .
	"\t\t\$(SRCLIST_KERNEL:%=\$(SRCDIR_KERNEL)/%) \\\n" .
	"\t\t\$(SRCLIST_ARCH:%=\$(SRCDIR_ARCH)/%) \\\n" .
	"\t\t\$(SRCLIST_APP:%=\$(SRCDIR_APP)/%))\n\n" .
        "# List of all Fortran 90 source files (without program file)\n" .
	"SRCF90   = \$(filter %.f90, \\\n" .
	"\t\t\$(SRCLIST_KERNEL:%=\$(SRCDIR_KERNEL)/%) \\\n" .
	"\t\t\$(SRCLIST_ARCH:%=\$(SRCDIR_ARCH)/%) \\\n" .
	"\t\t\$(SRCLIST_APP:%=\$(SRCDIR_APP)/%))\n\n" .
        "# List of all object files from Fortran 77 source files\n" .
        "OBJF77   = \$(patsubst %.f, \$(OBJDIR)/%.o, \$(notdir \$(SRCF77)))\n\n" .
        "# List of all object files from Fortran 90 source files (only modules)\n" .
        "OBJF90   = \$(patsubst %.f90, \$(OBJDIR)/%.o, \$(notdir \$(SRCF90)))\n\n" .
        "# List of object files only needed for current build ID\n" .
        "OBJEXTRA = \$(patsubst %.f,   \$(OBJDIR)/%.o, \$(filter %.f,   \$(notdir \$(SRCEXTRA) \$(SRCEXTRA_APP)))) \\\n" .
        "\t   \$(patsubst %.f90, \$(OBJDIR)/%.o, \$(filter %.f90, \$(notdir \$(SRCEXTRA) \$(SRCEXTRA_APP)))) \\\n" .
        "\t   \$(patsubst %.c,   \$(OBJDIR)/%.o, \$(filter %.c,   \$(notdir \$(SRCEXTRA) \$(SRCEXTRA_APP)))) \\\n" .
        "\t   \$(patsubst %.cc,  \$(OBJDIR)/%.o, \$(filter %.cc,  \$(notdir \$(SRCEXTRA) \$(SRCEXTRA_APP)))) \\\n" .
        "\t   \$(patsubst %.cu,  \$(OBJDIR)/%.o, \$(filter %.cu,  \$(notdir \$(SRCEXTRA) \$(SRCEXTRA_APP)))) \n\n" .

        "# Main object file (i.e. file containing the 'program' statement)\n" .
        "OBJPRG = \$(patsubst %.f90, \$(OBJDIR)/%.o, \$(notdir \$(PROGRAM_FILE)))\n\n" .

        "# List of header files to be copied to object directory\n" .
        "OBJHEADERCOPY = \$(patsubst %, \$(OBJDIR)/%, \$(notdir \$(INCLUDED_FILES_TO_COPY)))\n\n" .

        "# List of header files to be evaluated and stored to object directory\n" .
        "OBJHEADEREVAL = \$(patsubst %, \$(OBJDIR)/%, \$(notdir \$(INCLUDED_FILES_TO_EVALUATE_WITH_CPP)))\n\n" .

        "# List of all object files (dynamically generated from the list\n" .
        "# of .f90 and .f files)\n" .
        "#OBJ = \$(OBJF77) \$(OBJF90) \$(OBJEXTRA) \$(OBJPRG)\n\n" .
        "# Minimal list of object files needed to build the application\n" .
        &format_list("OBJ =", 6, 70,
		     join(' ', @requiredObjFiles) . " \$(OBJF77) \$(OBJEXTRA)", "", "\\") . "\n\n" .
        "# List of library files\n" .
        "LIB = \$(BUILDLIB:%=\$(OBJDIR_LIB)/lib%.a)\n\n\n\n";

    ##############################################################################
    # Import settings for compiler, linker etc.
    print MAKEFILE_HDL
        "##############################################################################\n" .
        "# Import a default build ID setting in case no build ID has been set yet.\n" .
        "include \$(MAKEFILE_BUILDID_INC)\n\n" .
        "# Import settings for compiler, linker etc.\n" .
        "include \$(MAKEFILE_CPU_INC)\n\n";


    ##############################################################################
    # Override settings from Makefile.inc with settings from command line
    # (or default values from hash %default.)
    print MAKEFILE_HDL "# Settings from configure command line which override settings from Makefile.inc\n";
    my $colwidth = 0;
    foreach my $entry ('APPONLYFLAGS', 'AR', 'BUILDLIB', 'CC', 'CFLAGSC', 'CFLAGSCOPROC',
		       'CFLAGSCXX', 'CFLAGSCUDA', 'CFLAGSF77', 'CFLAGSF90', 'CPP', 'CXX',
		       'CUDA', 'F77', 'F90', 'INC', 'LD', 'LDFLAGS', 'LIBDIR', 'LIBS',
		       'PRECC', 'PRECXX', 'PRECUDA', 'PREF77', 'PREF90', 'PRELD',
		       'MODEXTENSION', 'MOVEMOD', 'MPIINC', 'MPILIBDIR',
		       'MPILIBS', 'RANLIB', 'SRCEXTRA') {
	$colwidth = &max(length($entry), $colwidth);
    }
    $colwidth++;
    my $overwritten = 0;
    foreach my $entry ('APPONLYFLAGS', 'AR', 'BUILDLIB', 'CC', 'CFLAGSC', 'CFLAGSCOPROC',
		       'CFLAGSCXX', 'CFLAGSCUDA', 'CFLAGSF77', 'CFLAGSF90', 'CPP', 'CXX',
		       'CUDA', 'F77', 'F90', 'INC', 'LD', 'LDFLAGS', 'LIBDIR', 'LIBS',
		       'PRECC', 'PRECXX', 'PRECUDA', 'PREF77', 'PREF90', 'PRELD',
		       'MODEXTENSION', 'MOVEMOD', 'MPIINC', 'MPILIBDIR',
		       'MPILIBS', 'RANLIB', 'SRCEXTRA') {
	# Determine type of variable: scalar or array
	if (ref($cl{$entry}) eq "") {
	    # current token is a scalar value, print if not empty
	    # (Remember that an empty string is not allowed for
	    #  command line options that take a string, not an array!)
	    my $string = (defined($cl{$entry})) ? $cl{$entry} : $defaults{$entry};
 	    if (length($string) > 0) {
 		print MAKEFILE_HDL $entry . " "x($colwidth-length($entry)) . ":= $string\n";
 		$overwritten++;
 	    }

	} elsif (ref($cl{$entry}) eq "ARRAY") {
	    # current token is an array, print if at least one entry

	    # $cl{'...'} has been passed as an array to GetOptions()
	    # and as such is always defined. But is does not necessarily have
	    # entries: unset => #entries=-1; set, but empty => #entries=0
	    # So, don't test with perl function defined(). Test whether set.
	    my ($string, $minlengthToBeSet);
	    if ($#{ $cl{$entry} } > -1) {
		$string = $cl{$entry};
		$minlengthToBeSet = 0;      # unset arrays have length -1, empty arrays length 0
	    } else {
		$string = $defaults{$entry};
		$minlengthToBeSet = 1;     # defaults are always set; size of an empty array is 0, not -1 as for an unset array
	    }

	    if ($#{$string} >= $minlengthToBeSet) {
		# Exception for 'APPONLYFLAGS': for better readability put every preprocessor directive on a separate line
		if ($entry eq "APPONLYFLAGS") {
		    print MAKEFILE_HDL $entry . " "x($colwidth-length($entry)) . ":= " . join(" \\\n\t", @{$string}) . "\n";
		} else {
		    print MAKEFILE_HDL $entry . " "x($colwidth-length($entry)) . ":= " . join(' ', @{$string}) . "\n";
		}
		$overwritten++;
	    }
	}
    }
    if ($#{$cl{'suppressflags'}} >= 0) {
        foreach $entry ("CFLAGSF77", "CFLAGSF90", "CFLAGSC", "CFLAGSCOPROC", "CFLAGSCXX", "CFLAGSCUDA", "LDFLAGS") {
            foreach (@{$cl{'suppressflags'}}) {
                print MAKEFILE_HDL
                    $entry . " " x ($colwidth - length($entry)) . ":= \$(filter-out $_, \$($entry))\n";
            }
        }
        $overwritten++;
    }
    undef $colwidth;

    print MAKEFILE_HDL "# (none given on command line)\n" unless ($overwritten);
    print MAKEFILE_HDL "\n";
    undef $overwritten;


    ##############################################################################
    # New style support for coprocessors
    #
    # It is somewhat counterintuitive and against our intention to include the
    # instructions enabling coprocessor support in FEAT2 here instead of *before*
    # the previous section where Makefile.inc settings are overridden
    # with any setting from the command line. If settings are to be overridden
    # (e.g. CC, CFLAGSF90, BUILDLIB or APPONLYFLAGS), this operation should be the
    # last one.
    # But in this case a configure call like:
    #   ../../bin/configure --apponlyflags=-DDISABLE_ERRORCONTROL --coproclist=cpu
    # would first *append* coprocessor settings to APPONLYFLAGS
    #   APPONLYFLAGS := -DENABLE_COPROCESSOR_SUPPORT $(APPONLYFLAGS)
    # and then *override* any settings with those from the command line:
    #   APPONLYFLAGS = -DDISABLE_ERRORCONTROL
    # So, one would be required to know all settings for all possible coprocessors
    # and specify them on the command line. That is not a feasible approach.
    # Coprocessor support is hence included *after* including settings from the
    # command line that override previous settings. For sake of user convenience
    # we cede a bit of strictness.
    $entry = (defined($cl{'COPROCLIST'})) ? $cl{'COPROCLIST'} : $defaults{'COPROCLIST'};
    if ($#{$entry} >= 0) {

	# convert array with coprocessors into hash for easier lookups
	my %coprocs = ();
	map { $coprocs{$_} = $_; } @{ $entry };

	# if CUDA is listed as coprocessor,  it needs to be linked linked against the binary
	foreach $entry ('cuda10', 'cuda11', 'cuda12', 'cuda13',
			'cuda20', 'cuda21', 'cuda30', 'cuda35') {
	    if (defined($coprocs{$entry})) {
		print MAKEFILE_HDL
		    "# CUDA is among the list of coprocessors, so link against the CUDA runtime.\n" .
		    "ifeq (\$(strip \$(CUDA_INC_PATH)),)\n" .
		    "MESSAGE  := \$(MESSAGE) \\\n" .
		    "\t    echo '*** Warning: CUDA_INC_PATH unset. Only standard include paths will'; \\\n" .
		    "\t    echo '*** Warning: be searched for the file <cuda_runtime.h>.';\n" .
		    "else\n" .
		    "APPONLYFLAGS := -DHAS_" . uc($entry) . " \$(APPONLYFLAGS) -I\$(CUDA_INC_PATH) \n" .
		    "endif\n" .
		    "ifeq (\$(strip \$(CUDA_LIB_PATH)),)\n" .
		    "MESSAGE  := \$(MESSAGE) \\\n" .
		    "\t    echo '*** Warning: CUDA_LIB_PATH unset. Only standard library paths will'; \\\n" .
		    "\t    echo '*** Warning: be searched for the libraries <libcudart.so> and <libcublas.so>.';\n" .
		    "LIBS         := \$(LIBS) -lcudart -lcublas\n" .
		    "else\n" .
		    "LDFLAGS      := \$(LDFLAGS) -L\$(CUDA_LIB_PATH)\n" .
		    "LIBS         := \$(LIBS) -lcudart -lcublas\n" .
		    "endif\n";
	    }
	}

	# if OPENGL is listed as coprocessor, X11, GL and GLEW need to be linked linked against the binary
	if (defined($coprocs{'opengl'})) {
	    print MAKEFILE_HDL
		"# OPENGL is among the list of coprocessors, so link against X11, GL and GLEW and add appropriate includes.\n" .
		"ifeq (\$(strip \$(GLEW_INC_PATH)),)\n" .
		"MESSAGE  := \$(MESSAGE) \\\n" .
		"\t    echo '*** Warning: GLEW_INC_PATH unset. Only standard include paths will'; \\\n" .
		"\t    echo '*** Warning: be searched for the file <GL/glew.h>.';\n" .
		"APPONLYFLAGS := -DHAS_OPENGL \$(APPONLYFLAGS)\n" .
		"else\n" .
		"APPONLYFLAGS := -DHAS_OPENGL \$(APPONLYFLAGS) -I\$(GLEW_INC_PATH)\n" .
		"endif\n" .
		"ifeq (\$(strip \$(GLEW_LIB_PATH)),)\n" .
		"MESSAGE  := \$(MESSAGE) \\\n" .
		"\t    echo '*** Warning: GLEW_LIB_PATH unset. Only standard library paths will'; \\\n" .
		"\t    echo '*** Warning: be searched for the library <libGLEW.{a,so}>.';\n" .
		"LIBS         := -lGLEW -lGL -lGLU -lX11\n" .
		"else\n" .
		"LDFLAGS      := \$(LDFLAGS)\n" .
		"LIBS         := -lGLEW -lGL -lGLU -lX11\n" .
		"endif\n";
	}

	# write out general coproc-specific variable additions
        print MAKEFILE_HDL
            "# Coprocessor-specific special options\n" .
	    "SRCEXTRA     := \$(SRCEXTRA)\n" .
	    "BUILDLIB     := coproc \$(BUILDLIB)\n" .
        "INC          := -I\$(FEAT2BASEDIR)/librariesNEW/coproc \$(INC)\n" .
	    "LIBS         := -lcoproc \$(LIBS)\n" .
	    "APPONLYFLAGS := -DENABLE_COPROCESSOR_SUPPORT \$(APPONLYFLAGS) \n";

	print MAKEFILE_HDL "\n";
    }
    print MAKEFILE_HDL "\n";



    ##############################################################################
    # assemble settings for include paths, library search path and libraries to
    # link against, depending on whether we have a parallel or sequential build
    # (has to be done in every application's Makefile to allow override of
    #  settings on the command line or as a configure option.)
    print MAKEFILE_HDL
        "##############################################################################\n" .
        "# assemble settings for include paths, library search path and libraries to\n" .
        "# link against, depending on whether we have a parallel or sequential build\n" .
        "# (has to be done in every application's Makefile to allow override of\n" .
        "#  settings on the command line or as a configure option.)\n" .
        "##############################################################################\n" .
        "\n" .
        "ifeq (\$(strip \$(MPI)), YES)\n" .
        "LIBDIR := \$(MPILIBDIR) \$(LIBDIR)\n" .
        "LIBS   := \$(MPILIBS)   \$(LIBS)\n" .
        "endif\n\n\n\n";


    ##############################################################################
    # Define all functions
    print MAKEFILE_HDL
        "##############################################################################\n" .
        "# Functions\n\n" .

    # Define a function as a switch whether to move created .mod files to
    # $(OBJDIR) or not
        "# Define a function as a switch whether to move newly created module information\n" .
        "# files (extension: \$(MODEXTENSION)) to \$(OBJDIR) or not. Some compilers don't do\n" .
        "# that automatically and mess up the working directory instead with those files.\n" .
        "ifeq (\$(strip \$(MOVEMOD)), YES)\n" .
        "MOVE_MOD_FILES = && \\\n" .
        "    mv \$(patsubst %.f90,%.\$(MODEXTENSION),\$(filter %.f90,\$(notdir \$<))) \$(dir \$\@)\n" .
        "else\n" .
        "MOVE_MOD_FILES =\n" .
        "endif\n\n" .

    # Test whether the object directory where files are created is identical
    # to the one where they are supposed to be stored. If not, copy file to
    # \$(OBJDIR)
    #    "# Test whether the object directory where files are created is identical\n" .
    #    "# to the one where they are supposed to be stored. If not, copy file to\n" .
    #    "# \$(OBJDIR)\n" .
    #    "COPY_IF_NEEDED = \\\n" .
    #    "    \$(if \$(findstring \\\n" .
    #    "\t\$(shell (cd \$(DIR)/\$(OBJDIR); /bin/pwd)), \\\n" .
    #    "\t\$(shell (cd \$(OBJDIR); /bin/pwd))), , cp -p \$(DIR)/\$\@ \$(OBJDIR))\n\n\n" .

    # Function to delete a single file at once
    # (The reason why we need this and the magic why this works lies within
    #  the blank line after the remove command. This way the remove commands
    #  in a foreach-loop are triggered one after another - in separate
    #  sub-shells. Not in a single sub-shell command. As this may result
    #  on some machines in error messages of type:
    #  execvp: rm: Arg list too long)
        "# Functions to delete a single file / directory at once\n" .
        "# (The reason why we need this and the magic why this works lies within\n" .
        "#  the blank line after the remove command. This way the remove commands\n" .
        "#  in a foreach-loop are triggered one after another - in separate\n" .
        "#  sub-shells. Not in a single sub-shell command. As this may result\n" .
        "#  on some machines in error messages of type:\n" .
        "#  execvp: rm: Arg list too long)\n" .
        "define remove_file\n" .
        "    rm -f \$(file)\n\n" .
        "endef\n\n" .
        "# Recursively remove directories. For the first two directory levels\n" .
        "# print an error message if removal failed. (The restriction to two\n" .
        "# levels is rather arbitrary. It's the least number of directory levels\n" .
        "# created by a FEAT2 Makefile. To show an error message unconditionally\n" .
	"# is not desired as one would eventually always get an error message, at\n" .
	"# least when trying to remove /)\n" .
	"# The for loop is to deal with given directory wildcards like object/pc-*-*-*.\n" .
        "define remove_directory\n" .
	"    \@rmdirFailures=\"\"; \\\n" .
	"     for dir in \$(dir); do \\\n" .
	"\tdepth=0; \\\n" .
	"\twhile test -d \"\$\${dir}\" -a \"\$\${dir}\" != '.' -a \"\$\${dir}\" != '/'; do \\\n" .
	"\t    if rmdir \"\$\${dir}\" 2>/dev/null; then \\\n" .
	"\t\techo \"rmdir \$\${dir}\"; \\\n" .
	"\t\tdir=`dirname \$\${dir}`; \\\n" .
	"\t    else \\\n" .
	"\t\ttest \$\${depth} -lt 2 && rmdirFailures=\"\$\${rmdirFailures} \$\${dir}\"; \\\n" .
	"\t\tdir='.'; \\\n" .
	"\t    fi; \\\n" .
	"\t    depth=`expr \$\${depth} + 1`; \\\n" .
	"\tdone; \\\n" .
	"    done; \\\n" .
	"    for dir in \$\${rmdirFailures}; do \\\n" .
	"\tif test -d \"\$\${dir}\"; then \\\n" .
	"\t    \$(print_directory_not_empty); \\\n" .
	"\tfi; \\\n" .
        "    done\n\n" .
        "endef\n\n" .
        "# Function to be called if directory removal did not work unexpectedly.\n" .
        "define print_directory_not_empty\n" .
        "    (echo; \\\n" .
        "     echo '# ---------------------------------------------------------------------'; \\\n" .
        "     echo '# This Makefile previously created the directory '; \\\n" .
        "     echo '#'; \\\n" .
        "     echo \"# \$\${dir}\"; \\\n" .
        "     echo '#'; \\\n" .
        "     echo '# and was about to remove it. Since there are files in that directory'; \\\n" .
        "     echo '# that this Makefile did not create, it will not be removed.'; \\\n" .
        "     echo '# ---------------------------------------------------------------------')\n" .
        "endef\n\n\n\n";


    ##############################################################################
    # Final sanity checks
    print MAKEFILE_HDL
        "##############################################################################\n" .
        "# Final sanity checks\n\n" .

#	"# Sanity check. Don't let path to object directory become too long for PGI!\n" .
#	"# Reason:\n" .
#	"#   The PGI compiler cannot handle object directories exceeding a length\n" .
#	"#   of 120 characters. Using it to store files works, using it to look\n" .
#	"#   for module files works, using it as include path (for header files)\n" .
#	"#   does *not* work - *without* any error message! Header files are simply\n" .
#	"#   reported to not be found.\n" .
#	"ifneq (,\$(findstring -DUSE_COMPILER_PGI, \$(APPONLYFLAGS) \$(CFLAGSF90) ))\n" .
#	"ifeq (\$(shell echo \"`echo \$(OBJDIR) | wc -c` > 120\" | bc), 1)\n" .
#	"MESSAGE := \$(MESSAGE) \\\n" .
#	"\t   echo; \\\n" .
#	"\t   echo '*** Error: Object directory too long. PGI compiler is unable to handle'; \\\n" .
#	"\t   echo '***        include directories of this length. Cowardly refusing compilation.'; \\\n" .
#	"\t   echo; \\\n" .
#	"\t   exit 1;\n" .
#	"# The trailing 'echo' in the next command definition is necessary to catch\n" .
#	"# all the command line options a compile command usually gets.\n" .
#	"F77  = \$(MESSAGE) echo\n" .
#	"F90  = \$(F77)\n" .
#	"CC   = \$(F77)\n" .
#	"CUDA = \$(F77)\n" .
#	"CXX  = \$(F77)\n" .
#	"LD   = \$(F77)\n" .
#	"endif\n" .
#	"endif\n\n" .

	# Ensure there are no modules (stored in different directories) with identical names.
	"# Ensure there are no modules (stored in different directories) with identical names.\n" .
	"ifneq (\$(shell echo \$(notdir \$(SRCF90)) | tr ' ' '\\n' | sort -u),\$(shell echo \$(notdir \$(SRCF90)) | tr ' ' '\\n' | sort))\n" .
	"MESSAGE := \$(MESSAGE) \\\n" .
	"	   echo; \\\n" .
	"	   echo '*** Error: There are at least two modules that share the same name.'; \\\n" .
	"	   echo '***        This is not feasible given that all object files will be created in one common directory.'; \\\n" .
	"	   echo '***        Look out for Makefile warnings \"<file> given more than once in the same rule.\" for a list'; \\\n" .
	"	   echo '***        of a all identically named modules.'; \\\n" .
	"	   echo '***        Cowardly refusing compilation.'; \\\n" .
	"	   echo; \\\n" .
	"	   exit 1;\n" .
	"# The trailing 'echo' in the next command definition is necessary to catch\n" .
	"# all the command line options a compile command usually gets.\n" .
	"F77  = \$(MESSAGE) echo\n" .
	"F90  = \$(F77)\n" .
	"CC   = \$(F77)\n" .
	"CUDA = \$(F77)\n" .
	"CXX  = \$(F77)\n" .
	"LD   = \$(F77)\n" .
	"endif\n\n" .

	"# Makefile variable AGMG must have exactly one out of two possible values:\n" .
        "# YES or NO\n" .
        "# In case neither YES nor NO are given as mode, unset all compiler\n" .
        "# definitions in order to always raise an error when make is invoked.\n" .
        "ifneq (\$(strip \$(AGMG)), YES)\n" .
        "ifneq (\$(strip \$(AGMG)), NO)\n" .
        "MESSAGE := \$(MESSAGE) \\\n" .
        "\t   echo; \\\n" .
        "\t   echo '*** Error: Build type AGMG=\$(AGMG) unknown.'; \\\n" .
        "\t   echo '***        Valid keywords are YES or NO.'; \\\n" .
        "\t   echo '***        Cowardly refusing compilation.'; \\\n" .
        "\t   echo; \\\n" .
        "\t   exit 1;\n" .
        "# The trailing 'echo' in the next command definition is necessary to catch\n" .
        "# all the command line options a compile command usually gets.\n" .
        "F77 = \$(MESSAGE) echo\n" .
        "F90 = \$(F77)\n" .
        "CC  = \$(F77)\n" .
        "CXX = \$(F77)\n" .
        "LD  = \$(F77)\n" .
        "endif\n" .
        "endif\n" .
        "\n\n" .

	"# Makefile variable BINARY must have exactly one out of three possible values:\n" .
        "# STD, 32 or 64\n" .
        "# In case neither STD, 32 nor 64 is specified, unset all compiler\n" .
        "# definitions in order to always raise an error when make is invoked.\n" .
        "ifneq (\$(strip \$(BINARY)), STD)\n" .
        "ifneq (\$(strip \$(BINARY)), 32)\n" .
        "ifneq (\$(strip \$(BINARY)), 64)\n" .
        "MESSAGE := \$(MESSAGE) \\\n" .
        "\t   echo; \\\n" .
        "\t   echo '*** Error: Binary type BINARY=\$(BINARY) unknown.'; \\\n" .
        "\t   echo '***        Valid keywords are STD, 32 or 64.'; \\\n" .
        "\t   echo '***        Cowardly refusing compilation.'; \\\n" .
        "\t   echo; \\\n" .
        "\t   exit 1;\n" .
        "# The trailing 'echo' in the next command definition is necessary to catch\n" .
        "# all the command line options a compile command usually gets.\n" .
        "F77 = \$(MESSAGE) echo\n" .
        "F90 = \$(F77)\n" .
        "CC  = \$(F77)\n" .
        "CXX = \$(F77)\n" .
        "LD  = \$(F77)\n" .
        "endif\n" .
	"endif\n" .
	"endif\n" .
	"\n\n" .

	"# Makefile variable OPT must have exactly one out of three possible values:\n" .
	"# NO, YES, EXPENSIVE, NATIVE, or NATIVE-EXPENSIVE. If that requirement is not\n" .
        "# met, unset all compiler definitions in order to always raise an error when\n" .
        "# make is invoked.\n" .
	"ifneq (\$(strip \$(OPT)), NATIVE-EXPENSIVE)\n" .
	"ifneq (\$(strip \$(OPT)), NATIVE)\n" .
	"ifneq (\$(strip \$(OPT)), EXPENSIVE)\n" .
	"ifneq (\$(strip \$(OPT)), YES)\n" .
	"ifneq (\$(strip \$(OPT)), NO)\n" .
	"MESSAGE := \$(MESSAGE) \\\n" .
	"\t   echo; \\\n" .
        "\t   echo '*** Error: Optimisation level keyword OPT=\$(OPT) unknown.'; \\\n" .
	"\t   echo '***        Valid keywords are NO, YES, EXPENSIVE, NATIVE and NATIVE-EXPENSIVE.'; \\\n" .
	"\t   echo '***        Cowardly refusing compilation.'; \\\n" .
	"\t   echo; \\\n" .
	"\t   exit 1;\n" .
	"# The trailing 'echo' in the next command definition is necessary to catch\n" .
	"# all the command line options a compile command usually gets.\n" .
	"F77  = \$(MESSAGE) echo\n" .
	"F90  = \$(F77)\n" .
	"CC   = \$(F77)\n" .
	"CUDA = \$(F77)\n" .
	"CXX  = \$(F77)\n" .
	"LD   = \$(F77)\n" .
	"endif\n" .
	"endif\n" .
	"endif\n" .
	"endif\n" .
	"endif\n" .
	"\n\n" .

        "# Makefile variable INTSIZE must have exactly one out of two possible values:\n" .
        "# STD or LARGE\n" .
        "# In case neither STD nor LARGE is specified, unset all compiler\n" .
        "# definitions in order to always raise an error when make is invoked.\n" .
        "ifneq (\$(strip \$(INTSIZE)), STD)\n" .
        "ifneq (\$(strip \$(INTSIZE)), LARGE)\n" .
        "MESSAGE := \$(MESSAGE) \\\n" .
        "\t   echo; \\\n" .
        "\t   echo '*** Error: Integer size INTSIZE=\$(INTSIZE) unknown.'; \\\n" .
        "\t   echo '***        Valid keywords are STD or LARGE.'; \\\n" .
        "\t   echo '***        Cowardly refusing compilation.'; \\\n" .
        "\t   echo; \\\n" .
        "\t   exit 1;\n" .
        "# The trailing 'echo' in the next command definition is necessary to catch\n" .
        "# all the command line options a compile command usually gets.\n" .
        "F77 = \$(MESSAGE) echo\n" .
        "F90 = \$(F77)\n" .
        "CC  = \$(F77)\n" .
        "CXX = \$(F77)\n" .
        "LD  = \$(F77)\n" .
        "endif\n" .
	"endif\n" .
	"\n\n" .

        "# Makefile variable MPI must have exactly one out of two possible values:\n" .
        "# YES or NO\n" .
        "# In case neither YES nor NO are given as mode, unset all compiler\n" .
        "# definitions in order to always raise an error when make is invoked.\n" .
        "ifneq (\$(strip \$(MPI)), YES)\n" .
        "ifneq (\$(strip \$(MPI)), NO)\n" .
        "MESSAGE := \$(MESSAGE) \\\n" .
        "\t   echo; \\\n" .
        "\t   echo '*** Error: Build type MPI=\$(MPI) unknown.'; \\\n" .
        "\t   echo '***        Valid keywords are YES or NO.'; \\\n" .
        "\t   echo '***        Cowardly refusing compilation.'; \\\n" .
        "\t   echo; \\\n" .
        "\t   exit 1;\n" .
        "# The trailing 'echo' in the next command definition is necessary to catch\n" .
        "# all the command line options a compile command usually gets.\n" .
        "F77 = \$(MESSAGE) echo\n" .
        "F90 = \$(F77)\n" .
        "CC  = \$(F77)\n" .
        "CXX = \$(F77)\n" .
        "LD  = \$(F77)\n" .
        "endif\n" .
        "endif\n" .
        "\n\n" .

        "# Makefile variable OPENMP must have exactly one out of two possible values:\n" .
        "# YES or NO\n" .
        "# In case neither YES nor NO are given as mode, unset all compiler\n" .
        "# definitions in order to always raise an error when make is invoked.\n" .
        "ifneq (\$(strip \$(OPENMP)), YES)\n" .
        "ifneq (\$(strip \$(OPENMP)), NO)\n" .
        "MESSAGE := \$(MESSAGE) \\\n" .
        "\t   echo; \\\n" .
        "\t   echo '*** Error: Build type OPENMP=\$(OPENMP) unknown.'; \\\n" .
        "\t   echo '***        Valid keywords are YES or NO.'; \\\n" .
        "\t   echo '***        Cowardly refusing compilation.'; \\\n" .
        "\t   echo; \\\n" .
        "\t   exit 1;\n" .
        "# The trailing 'echo' in the next command definition is necessary to catch\n" .
        "# all the command line options a compile command usually gets.\n" .
        "F77 = \$(MESSAGE) echo\n" .
        "F90 = \$(F77)\n" .
        "CC  = \$(F77)\n" .
        "CXX = \$(F77)\n" .
        "LD  = \$(F77)\n" .
        "endif\n" .
        "endif\n" .
        "\n\n" .

        "# If a parallel application should be built, but preprocessor switch\n" .
        "# -DENABLE_SERIAL_BUILD appears among compiler flags, unset all compiler definitions\n" .
        "# in order to always raise an error when make is invoked.\n" .
        "ifeq (\$(strip \$(MPI)), YES)\n" .
        "ifneq (,\$(findstring -DENABLE_SERIAL_BUILD ,\\\n" .
        "\t\$(APPONLYFLAGS) \$(CFLAGSF77) \$(CFLAGSF90) \$(CFLAGSC) \$(CFLAGSCOPROC) \$(CFLAGSCUDA) \$(CFLAGSCXX) ))\n" .
        "MESSAGE := \$(MESSAGE) \\\n" .
        "\t   echo; \\\n" .
        "\t   echo '*** Error: Build type MPI=YES cannot be used in combination'; \\\n" .
        "\t   echo '***        with preprocessor switch -DENABLE_SERIAL_BUILD.'; \\\n" .
        "\t   echo '***        Please choose for either one. Cowardly refusing compilation.'; \\\n" .
        "\t   echo; \\\n" .
        "\t   exit 1;\n" .
        "# The trailing 'echo' in the next command definition is necessary to catch\n" .
        "# all the command line options a compile command usually gets.\n" .
        "F77 = \$(MESSAGE) echo\n" .
        "F90 = \$(F77)\n" .
        "CC  = \$(F77)\n" .
        "CXX = \$(F77)\n" .
        "LD  = \$(F77)\n" .
        "endif\n" .
        "endif\n" .
	"\n\n" .

	"# Warn about deprecated Makefile variable MODE=PARALLEL|SERIAL\n" .
	"ifneq (\$(strip \$(MODE)),)\n" .
	"MESSAGE := \$(MESSAGE) \\\n" .
	"\t   echo; \\\n" .
	"\t   echo '*** Warning: Use of Makefile variable MODE=\$(MODE) is deprecated.'; \\\n" .
	"\t   echo '***          Use MPI=<YES|NO> instead.'; \\\n" .
        "\t   exit 1;\n" .
        "# The trailing 'echo' in the next command definition is necessary to catch\n" .
        "# all the command line options a compile command usually gets.\n" .
        "F77 = \$(MESSAGE) echo\n" .
        "F90 = \$(F77)\n" .
        "CC  = \$(F77)\n" .
        "CXX = \$(F77)\n" .
        "LD  = \$(F77)\n" .
	"endif\n" .
	"\n\n" .

        "# Catch case that a build ID has been given for which\n" .
        "# compiler settings are not (fully) set up.\n" .
        "DETAIL := \n" .
	"ifneq (\$(TOKEN1)\$(TOKEN2)\$(TOKEN3)\$(TOKEN4)\$(TOKEN5), 11111)\n" .
        "ifneq (\$(TOKEN1), 1)\n" .
        "DETAIL := \$(DETAIL) echo '***        1st token not matched against any rule in \$(MAKEFILE_CPU_INC).';\n" .
        "endif\n" .
        "ifneq (\$(TOKEN2), 1)\n" .
        "DETAIL := \$(DETAIL) echo '***        2nd token not matched against any rule in \$(MAKEFILE_CPU_INC)';\n" .
        "endif\n" .
        "ifneq (\$(TOKEN3), 1)\n" .
        "DETAIL := \$(DETAIL) echo '***        3rd token not matched against any rule in \$(MAKEFILE_CPU_INC)';\n" .
        "endif\n" .
        "ifneq (\$(TOKEN4), 1)\n" .
        "DETAIL := \$(DETAIL) echo '***        4th token not matched against any rule in \$(MAKEFILE_CPU_INC).';\n" .
        "endif\n" .
        "ifneq (\$(TOKEN5), 1)\n" .
        "DETAIL := \$(DETAIL) echo '***        5th token not matched against any rule in \$(MAKEFILE_CPU_INC).';\n" .
        "endif\n" .
        "endif\n" .
	"\n\n" .

        "# Test for 6th token in case of MPI=YES\n" .
        "ifeq (\$(strip \$(MPI)), YES)\n" .
        "ifneq (\$(TOKEN6), 1)\n" .
        "DETAIL := \$(DETAIL) echo '***        6th token not matched against any rule in \$(MAKEFILE_CPU_INC).';\n" .
        "endif\n" .
        "endif\n" .
	"\n\n" .

        "# Now, override any compiler settings in case any token is unset\n" .
        "ifneq (\$(DETAIL),)\n" .
        "MESSAGE := \$(MESSAGE) \\\n" .
        "\t   echo; \\\n" .
        "\t   echo '*** Error: Invalid build ID \$(ID)'; \\\n" .
        "\t   \$(DETAIL) \\\n" .
        "\t   echo; \\\n" .
        "\t   exit 1;\n" .
        "# The trailing 'echo' in the next command definition is necessary to catch\n" .
        "# all the command line options a compile command usually gets.\n" .
        "F77 = \$(MESSAGE) echo\n" .
        "F90 = \$(F77)\n" .
        "CC  = \$(F77)\n" .
        "CXX = \$(F77)\n" .
        "LD  = \$(F77)\n" .
        "endif\n" .
	"\n\n" .

	"# Catch case (coproc-bail-out) that coprocessor support is not available for all build IDs\n" .
	"ifneq (,\$(findstring -DENABLE_COPROCESSOR_SUPPORT ,\\\n" .
	"\t\$(APPONLYFLAGS) \$(CFLAGSF77) \$(CFLAGSF90) \$(CFLAGSC) \$(CFLAGSCOPROC) \$(CFLAGSCUDA) \$(CFLAGSCXX) ))\n" .
	"# Initialise value\n" .
	"DETAIL :=\n" .
	"ifneq (, \$(findstring -DUSE_COMPILER_PATHSCALE ,\\\n" .
	"\t\$(APPONLYFLAGS) \$(CFLAGSF77) \$(CFLAGSF90) \$(CFLAGSC) \$(CFLAGSCOPROC) \$(CFLAGSCUDA) \$(CFLAGSCXX) ))\n" .
	"DETAIL := \$(DETAIL) echo '*** because cross-language linking is not possible with the Pathscale compiler suite:';\n" .
	"endif\n" .
	"ifneq (, \$(findstring -DUSE_COMPILER_OPEN64 ,\\\n" .
	"\t\$(APPONLYFLAGS) \$(CFLAGSF77) \$(CFLAGSF90) \$(CFLAGSC) \$(CFLAGSCOPROC) \$(CFLAGSCUDA) \$(CFLAGSCXX) ))\n" .
	"DETAIL := \$(DETAIL) echo '*** because cross-language linking is not possible with the Open64 compiler suite:';\n" .
	"endif\n" .
	"ifneq (, \$(findstring -DUSE_COMPILER_NEC ,\\\n" .
	"\t\$(APPONLYFLAGS) \$(CFLAGSF77) \$(CFLAGSF90) \$(CFLAGSC) \$(CFLAGSCOPROC) \$(CFLAGSCUDA) \$(CFLAGSCXX) ))\n" .
	"DETAIL := \$(DETAIL) echo '*** because cross-language linking is not possible with NEC compilers:';\n" .
	"endif\n" .
	"# Throw error if value is set by now\n" .
	"ifneq (,\$(DETAIL))\n" .
	"MESSAGE := \$(MESSAGE) \\\n" .
	"\t   echo; \\\n" .
	"\t   echo '*** Error: Coprocessor support not available for build ID \$(ID)'; \\\n" .
	"\t   \$(DETAIL) \\\n" .
	"\t   echo '*** Symbol names generated by its Fortran compiler lead to incompilable C code.'; \\\n" .
	"\t   echo; \\\n" .
	"\t   exit 51;\n" .
	"# The trailing 'echo' in the next command definition is necessary to catch\n" .
	"# all the command line options a compile command usually gets.\n" .
	"F77  = \$(MESSAGE) echo\n" .
	"F90  = \$(F77)\n" .
	"CC   = \$(F77)\n" .
	"CUDA = \$(F77)\n" .
	"CXX  = \$(F77)\n" .
	"LD   = \$(F77)\n" .
	"endif\n" .
	"endif\n\n\n\n";



    ##############################################################################
    # Define default target
    print MAKEFILE_HDL
        "##############################################################################\n" .
        "# Default target if make is invoked without any argument:\n" .
        "# compile the application\n" .
        "default: all\n\n\n\n";


    ##############################################################################
    # Dependencies of each object file
    print MAKEFILE_HDL
        "##############################################################################\n" .
        "# Dependencies of each object file\n\n" .
        $objectfiles_and_dependencies . "\n\n";


    ##############################################################################
    # Dependencies of header files to be copied or evaluated and stored in
    # object directory
    print MAKEFILE_HDL
        "##############################################################################\n" .
        "# Dependencies of header files to be copied or evaluated and stored in\n" .
        "# object directory\n\n";
    foreach $entry (split(/\s+/, $HEADER_FILES_TO_COPY)) {
	my $file_PathUsingBasedir = $entry;
	$file_PathUsingBasedir =~ s,^$FEAT2BASEDIR/$SRCDIR_KERNEL,\$(SRCDIR_KERNEL),;
	$file_PathUsingBasedir =~ s,^$FEAT2BASEDIR/$SRCDIR_KERNEL,\$(FEAT2BASEDIR),;
        print MAKEFILE_HDL
            &make_dep_list(\%dependencyLists, $entry,
                           $file_PathUsingBasedir, 0, "", "o",
                           "\$(OBJDIR)", \%headerFilesToCopy) . "\n\n" if ($entry);
    }
    foreach $entry (@{$cl{'HEADER_FILES_TO_COPY'}}) {
        print MAKEFILE_HDL
            &make_dep_list(\%dependencyLists, $entry, $entry, 0, "", "o",
                           "\$(OBJDIR)", \%headerFilesToCopy) . "\n\n" if ($entry);
    }
    foreach $entry (sort keys %headerfiles) {
        $entry = $headerfiles{$entry}->{'URI'};
        # Some include files are from kernel directory, some from sbblas directory.
        # They are to be treated differently.
        if ($entry) {
            # if (&dirname($entry) =~ m|/$SRCDIR_KERNEL$|) {
            #     print MAKEFILE_HDL
            #         &make_dep_list(\%dependencyLists, $entry,
            #                        "\$(SRCDIR_KERNEL)/" . &basename($entry), 0, "", "o",
            #                        "\$(OBJDIR)", \%headerFilesToCopy) . "\n\n";
            #     warn $progname.":\n" .
            #         "Obsolete branch 1 for <$entry>.\n" .
            #         "Inform the configure maintainer about this case.\n";
            # } elsif (&dirname($entry) =~ m|/$SRCDIR_ARCH$|) {
            #     print MAKEFILE_HDL
            #         &make_dep_list(\%dependencyLists, $entry,
            #                        "\$(SRCDIR_ARCH)/" . &basename($entry), 0, "", "o",
            #                        "\$(OBJDIR)", \%headerFilesToCopy) . "\n\n";
            #     warn $progname.":\n" .
            #         "Obsolete branch 2 for <$entry>.\n" .
            #         "Inform the configure maintainer about this case.\n";
            # } else {

	    # The idea is to have only paths relative to FEAT2BASEDIR.
	    # Substitute absolute path information accordingly.
	    my $file_PathUsingBasedir = $entry;
	    $file_PathUsingBasedir =~ s/^\Q$FEAT2BASEDIR\E/\$(FEAT2BASEDIR)/;
	    print MAKEFILE_HDL
		&make_dep_list(\%dependencyLists, $entry,
			       $file_PathUsingBasedir, 0, "", "o",
			       "\$(OBJDIR)", \%headerFilesToCopy) . "\n\n";
            # }
        }
    }
    undef %headerFilesToCopy;
    print MAKEFILE_HDL "\n\n";


    ##############################################################################
    # Compilation and link directives
    print MAKEFILE_HDL
        "##############################################################################\n" .
        "# Compilation and link directives\n\n" .

        "# default target: compile the FEAT2 application\n" .
        "all:\tgreeting \$(APPNAME)\n\n" .

    # debug build
        "# 'make debug' will compile without optimisation and with debug symbols\n" .
        "debug:\n" .
        "\t\@$makeInMakefile OPT=NO\n\n" .

    # all libraries
        "# Create all libraries\n" .
        "libs:\t\$(LIB)\n\n" .

    # all object files
        "# Compile all object files\n" .
        "obj:\t\$(OBJ)\n\n" .

    # Link statement for application
        "# Link statement for application\n" .
        "\$(APPNAME): | \$(OBJDIR) \$(LIB)\n" .
        "\$(APPNAME): \$(OBJ)\n" .
        "\t\@echo \"# Linking FEAT2 application <\$(APPNAME)>\"\n" .
        "\t\$(PRELD) \$(LD) \$(LDFLAGS) \$(OBJ) \$(LIBDIR) \$(LIBS) -o \$(APPNAME)\n" .
        "ifneq (\$(MESSAGE),)\n" .
        "\t\@\$(MESSAGE)\n" .
        "endif\n\n" .

    # Just link the program, without considering dependencies
    # (For cases where you just made a few changes to a code that
    #  will not harm other modules. Then, use this make target to
    #  shortcut the build.)
        "# Just link the program, without considering dependencies\n" .
        "# (For cases where you just made a few changes to a code that\n" .
        "#  will not harm other modules. Then, use this make target to\n" .
        "#  shortcut the build.)\n" .
        "link: | \$(OBJDIR)\n" .
        "\t\@echo \"# Linking FEAT2 application <\$(APPNAME)>\"\n" .
        "\t\$(PRELD) \$(LD) \$(LDFLAGS) \$(OBJ) \$(LIBDIR) \$(LIBS) -o \$(APPNAME)\n\n" .

    # Global dependencies for object files
        "# Global dependencies for object files\n" .
        "\$(OBJ): | \$(OBJDIR_LIB) \$(OBJDIR)\n" .
        "\$(OBJ): | check-or-store-settings\n\n" .

	"# Please keep in mind:\n" .
	"# GNU Make 3.80 requires that an order-only prerequisite shall not be\n" .
	"# put on the same line as a prerequisite of an implicit rule. \$< would\n" .
	"# will be set to the first order-only prerequisite. Potentially this\n" .
	"# leads to rebuilding the target every time make is invoked. Or the\n" .
	"# target can not be built at all.\n\n" .

    # Create build rule for object files from Fortran 77 source
        "# Compile statement for each object file from Fortran 77 source\n" .
        "\$(OBJF77): | \$(OBJDIR)\n" .
        "\$(OBJF77):\n" .
        "\t\$(PREF77) \$(F77) \$(CFLAGSF77) \$(MPIINC) \$(INC) -c \$< -o \$@\n\n" .

    # Create build rule for object files from Fortran 90 source
#        "# Additional global dependencies for object files from Fortran 90 sources\n" .
#        "\$(OBJF90):\n" .

    # Workaround for NEC C IA-64 Compiler, Revision 6.1 internal compiler error
#        "# Workaround:\n" .
#        "# Compiling on a NEC gateway Itanium2 server gives internal compiler errors\n" .
#        "# with NEC C IA-64 Compiler, Revision 6.1 if -O3 is used. Lowering optimisation\n" .
#        "# to -O2 helps.\n" .
#        "COMPILERVERSION := \$(shell eval \$(F90VERSION) )\n" .
#        "ifneq (,\$(findstring NEC Fortran IA-64 Compiler,\$(COMPILERVERSION)))\n" .
#        "ifneq (,\$(findstring Revision 6.1,\$(COMPILERVERSION)))\n" .
#        "\$(OBJDIR)/linearsystem.o \$(OBJDIR)/masterservice.o \$(OBJDIR)/storage.o \$(OBJDIR)/visoutput.o:\n" .
#        "\tCPPFLAGS=\"\$(CPPFLAGS)\" \\\n\$(F90CPP) \$(PREF90) \$(F90) \$(APPONLYFLAGS) \$(subst -O3,-O2,\$(CFLAGSF90)) \$(MPIINC) \$(INC) -c \$< -o \$@ \$(call MOVE_MOD_FILES)\n" .
#        "endif\n" .
#        "endif\n\n" .

	"# Create build rule for object files from Fortran 90 source\n" .
        "\$(OBJF90): | \$(OBJDIR)\n" .
        "\$(OBJF90):\n" .
        "\tCPPFLAGS=\"\$(CPPFLAGS)\" \\\n\$(F90CPP) \$(PREF90) \$(F90) \$(APPONLYFLAGS) \$(CFLAGSF90) \$(MODOPTION)\$(OBJDIR) \$(MPIINC) \$(INC) -c \$< -o \$@ \$(call MOVE_MOD_FILES)\n\n" .

    # Create separate rule for source file containing program
        "# Compile statement for source file containing program start\n" .
        "# (a separate statement is needed because it defines a program, not a module\n" .
        "#  and, hence, we should not try to move a .mod file as we do with any module.)\n" .
        "\$(OBJPRG): | \$(OBJDIR)\n" .
        "\$(OBJPRG):\n" .
        "\tCPPFLAGS=\"\$(CPPFLAGS)\" \\\n\$(F90CPP) \$(PREF90) \$(F90) \$(APPONLYFLAGS) \$(CFLAGSF90) \$(MODOPTION)\$(OBJDIR) \$(MPIINC) \$(INC) -c \$< -o \$@\n\n" .

    # Include implicit rules for files only needed for specific
    # build IDs. They are listed in $(SRCEXTRA) and are supposed
    # to be located in $(SRCDIR_ARCH).
        "# Include implicit rules for files only needed for specific\n" .
        "# build IDs. They are listed in \$(SRCEXTRA) and are\n" .
        "# supposed to be located in \$(SRCDIR_ARCH).\n" .
        "\$(OBJDIR)/%.o: | \$(OBJDIR)\n" .

    # Generic rule for *.f files out of SRCEXTRA and SRCEXTRA_APP
	"# Generic rule for *.f files out of SRCEXTRA and SRCEXTRA_APP\n" .
	"\$(patsubst %.f, \$(OBJDIR)/%.o, \$(filter %.f, \$(notdir \$(SRCEXTRA) \$(SRCEXTRA_APP)))): \$(SRCEXTRA) \$(SRCEXTRA_APP)\n" .
	"\t\$(PREF77) \$(F77) \$(APPONLYFLAGS) \$(CFLAGSF77) \$(MPIINC) \$(INC) -c \$(filter %/\$(notdir \$(basename \$\@)).f, \$(SRCEXTRA) \$(SRCEXTRA_APP)) -o \$\@\n\n" .

    # Generic rule for *.f90 files out of SRCEXTRA and SRCEXTRA_APP
	"# Generic rule for *.f90 files out of SRCEXTRA and SRCEXTRA_APP\n" .
	"# Note 1:\n" .
	"# Remember that those files are supposed to provide no Fortran module\n" .
	"# - otherwise they would be on the normal kernel file list - and as\n" .
	"# such do not try to move a .mod file upon compilation as a workaround\n" .
	"# for compilers that do not create .mod files in the object directory,\n" .
	"# in the working directory.\n" .
	"# Note 2:\n" .
	"# Fortran 90 source files listed in SRCEXTRA and SRCEXTRA_APP may try to\n" .
	"# 'use' Fortran 90 modules from the kernel. Add the complete list of object\n" .
	"# files generated from the kernel's Fortran 90 sources to the dependency\n" .
	"# list of the SRCEXTRA's and SRCEXTRA_APP's Fortran 90 source files to prevent\n" .
	"# them from being compiled prematurely, e.g. in a highly parallel make run\n" .
	"# (make -j N, with N>32 or N missing).\n" .
	"\$(patsubst %.f90, \$(OBJDIR)/%.o, \$(filter %.f90, \$(notdir \$(SRCEXTRA) \$(SRCEXTRA_APP)))): \$(SRCEXTRA) \$(SRCEXTRA_APP) \$(filter-out \$(OBJEXTRA), \$(OBJ))\n" .
	"\tCPPFLAGS=\"\$(CPPFLAGS)\" \\\n\$(F90CPP) \$(PREF90) \$(F90) \$(APPONLYFLAGS) \$(CFLAGSF90) \$(MODOPTION)\$(OBJDIR) \$(MPIINC) \$(INC) -c \$(filter %/\$(notdir \$(basename \$\@)).f90, \$(SRCEXTRA) \$(SRCEXTRA_APP)) -o \$\@\n\n" .

    # Generic rule for *.c files out of SRCEXTRA and SRCEXTRA_APP
	"# Generic rule for *.c files out of SRCEXTRA and SRCEXTRA_APP\n" .
	"\$(patsubst %.c, \$(OBJDIR)/%.o, \$(filter %.c, \$(notdir \$(SRCEXTRA) \$(SRCEXTRA_APP)))): \$(SRCEXTRA) \$(SRCEXTRA_APP)\n" .
        "\t\$(PRECC) \$(CC) \$(APPONLYFLAGS) \$(CFLAGSC) \$(MPIINC) \$(INC) -c \$(filter %/\$(notdir \$(basename \$\@)).c, \$(SRCEXTRA) \$(SRCEXTRA_APP)) -o \$\@\n\n" .

    # Generic rule for *.cc files out of SRCEXTRA and SRCEXTRA_APP
	"# Generic rule for *.cc files out of SRCEXTRA and SRCEXTRA_APP\n" .
	"\$(patsubst %.cc, \$(OBJDIR)/%.o, \$(filter %.cc, \$(notdir \$(SRCEXTRA) \$(SRCEXTRA_APP)))): \$(SRCEXTRA) \$(SRCEXTRA_APP)\n" .
	"\t\$(PRECXX) \$(CXX) \$(APPONLYFLAGS) \$(CFLAGSCXX) \$(MPIINC) \$(INC) -c \$(filter %/\$(notdir \$(basename \$\@)).cc, \$(SRCEXTRA) \$(SRCEXTRA_APP)) -o \$\@\n\n" .

    # Generic rule for *.cu files out of SRCEXTRA and SRCEXTRA_APP
	"# Generic rule for *.cu files out of SRCEXTRA and SRCEXTRA_APP\n" .
	"\$(patsubst %.cu, \$(OBJDIR)/%.o, \$(filter %.cu, \$(notdir \$(SRCEXTRA) \$(SRCEXTRA_APP)))): \$(SRCEXTRA) \$(SRCEXTRA_APP)\n" .
	"\t\$(PRECUDA) \$(CUDA) \$(APPONLYFLAGS) \$(CFLAGSCUDA) \$(INC) -c \$(filter %/\$(notdir \$(basename \$\@)).cu, \$(SRCEXTRA) \$(SRCEXTRA_APP)) -o \$\@\n\n" .

    # All files listed in $(SRCEXTRA) should be compiled, but depending on
    # their extension with a separate rule. Fortran, Fortran90, C, C++ and
    # CUDA source files have been dealt with above. Due to all object files in
    # $(OBJEXTRA) depending on all source files in $(SRCEXTRA) and
    # $(SRCEXTRA_APP), an error will get raised by GNU Make if one of the
    # source files listed in $(SRCEXTRA) or $(SRCEXTRA_APP) does not
    # exist. But it might be that e.g. some Fortran module, referenced by a
    # 'use' statement in a kernel or application source file, was neither
    # included in $(SRCLIST_KERNEL) nor $(SRCLIST_APP). Try to catch these
    # cases and raise a meaningful error message:
        "# All files listed in \$(SRCEXTRA) should be compiled, but depending on\n" .
        "# their extension with a separate rule. Fortran, Fortran90, C, C++ and\n" .
        "# CUDA source files have been dealt with above. Due to all object files in\n" .
        "# \$(OBJEXTRA) depending on all source files in \$(SRCEXTRA) and\n" .
        "# \$(SRCEXTRA_APP), an error will get raised by GNU Make if one of the\n" .
        "# source files listed in \$(SRCEXTRA) or \$(SRCEXTRA_APP) does not\n" .
        "# exist. But it might be that e.g. some Fortran module, referenced by a\n" .
        "# 'use' statement in a kernel or application source file, was neither\n" .
        "# included in \$(SRCLIST_KERNEL) nor \$(SRCLIST_APP). Try to catch these\n" .
        "# cases and raise a meaningful error message:\n" .
        "#\n" .
        "# File from SRCEXTRA and SRCEXTRA_APP that can not be found?\n" .
        "define srcextra_file_not_found\n" .
        "    echo;\n" .
        "    echo \"ERROR: <\$(filter \$*.%, \$(SRCEXTRA) \$(SRCEXTRA_APP))> not found.\";\n" .
        "    echo;\n" .
        "    echo \"<\$(filter \$*.%, \$(SRCEXTRA) \$(SRCEXTRA_APP))> is specified in\";\n" .
	"    echo \"SRCEXTRA or SRCEXTRA_APP (defined in \$(MAKEFILE_CPU_INC) or\";\n" .
        "    echo \"\$(dir \$(MAKEFILE_CPU_INC))/templates/*.mk\";\n" .
        "    echo \"and as such is to be compiled additionally for this build ID.\";\n" .
        "    echo \"It is supposed to reside in directory\";\n" .
        "    echo \"\$(SRCDIR_ARCH),\";\n" .
        "    echo \"but does not.\";\n" .
        "    echo;\n" .
        "    exit 1;\n" .
        "endef\n" .
        "# No file from SRCEXTRA or SRCEXTRA_APP? Then probably a file is missing from SRCLIST_KERNEL.\n" .
        "define kernel_file_not_on_the_list\n" .
        "    echo;\n" .
        "    echo \"ERROR: No rule to make target <\$*.o>.\";\n" .
        "    echo;\n" .
        "    echo \"You might have forgotten to add the corresponding source file to any\";\n" .
        "    echo \"of the Makefile variables SRCLIST_KERNEL, SRCLIST_ARCH, SRCLIST_APP or SRCEXTRA_APP.\";\n" .
        "    echo;\n" .
        "    exit 1\n" .
        "endef\n" .
        "\$(OBJDIR)/%.o:\n" .
        "\t\@\$(if \$(strip \$(filter \$*.%, \$(SRCEXTRA) \$(SRCEXTRA_APP))), \\\n" .
        "\t\t\$(srcextra_file_not_found), \$(kernel_file_not_on_the_list))\n" .
        "\n\n";


    ##############################################################################
    # Create, copy or evaluate header files to be included in Fortran 90 source files
    print MAKEFILE_HDL
        "##############################################################################\n" .
        "# Create, copy or evaluate header files to be included in Fortran 90 source files\n\n" .
        "# Copy some header files to object directory (but remove path information from\n" .
        "# include statements)\n" .
        "\$(OBJHEADERCOPY): | \$(OBJDIR)\n" .
        "\$(OBJHEADERCOPY):\n" .
        "\tsed -e 's|include \".*/\\([^/]*\\)\"|include \"\\1\"|' \$< > \$@\n\n" .

        "# Others need to be evaluated with cpp first before being stored there.\n" .
        "\$(OBJHEADEREVAL): | \$(OBJDIR)\n" .
        "\$(OBJHEADEREVAL): | \$(OBJHEADERCOPY)\n" .
        "\$(OBJHEADEREVAL): TMPFILE=\$(OBJDIR)/\$(notdir \$<).tmp\n" .
        "\$(OBJHEADEREVAL):\n" .
        "\t\@echo \"# Preprocessing \$<\"\n" .
        "\t\$(CPP) \$(CPPFLAGS) -I\$(OBJDIR) \\\n" .
        "\t      \$< \\\n" .
        "\t    > \$(TMPFILE)\n" .
        "\t\@echo \"# Compensating for line number changes in preprocessed \$<\"\n" .
        "\tawk -f \$(FEAT2BASEDIR)/bin/postprocess_cppoutput.awk \\\n" .
        "\t      \$(TMPFILE) \\\n" .
        "\t    > \$(OBJDIR)/\$(notdir \$<)\n" .
        "\trm -f \$(TMPFILE)\n" .
        "\n\n";


    ##############################################################################
    # Cleaning up things
    print MAKEFILE_HDL
        "##############################################################################\n" .
        "# Cleaning up things\n\n" .

    # Clean statement
        "# Clean all object files for current architecture\n" .
        "clean:\tclean-libs clean-app\n\n" .

    # clean-app statement
        "# Clean all FEAT2 object files for current architecture\n" .
        "clean-app:\n" .
        "\t\@echo \"# Removing application binary\"\n" .
        "\t-rm -f \$(APPNAME) core\n" .
        "\t\@echo \"# Removing generated source files\"\n" .
        "\t-\$(foreach file, \\\n" .
        &format_list("\t    \$(patsubst %, \$(OBJDIR)/%, ", 16, 70, SRCLIST_GENERATED, "\\\n", "\\") . "), \\\n" .
        "\t    \$(remove_file))\n" .
        "\t\@echo \"# Removing wrapped source and header files\"\n" .
        "\t-\$(foreach file, \$(OBJHEADERCOPY) \$(OBJHEADEREVAL), \$(remove_file))\n" .
        "\t-\$(foreach file, \\\n" .
        "\t    \$(patsubst %.o, %.f90, \$(OBJF90) \$(OBJPRG)) \\\n" .
        "\t    \$(patsubst %, \$(OBJDIR)/%, \$(notdir \$(filter %.f90, \$(SRCEXTRA) \$(SRCEXTRA_APP)))), \\\n" .
        "\t    \$(remove_file))\n" .
        "\t\@echo \"# Removing object files\"\n" .
        "\t-\$(foreach file, \\\n" .
        "\t    \$(OBJF77) \$(OBJF90) \$(OBJEXTRA) \$(OBJPRG), \\\n" .
        "\t    \$(remove_file))\n" .
        "\t\@echo \"# Removing module information files\"\n" .
        "\t-rm -f \$(OBJDIR)/*.\$(MODEXTENSION)\n" .
        "\t\@echo \"# Removing object directories\"\n" .
        "\t\$(foreach dir, \$(OBJDIR), \$(remove_directory))\n\n" .

    # clean-libs statement
        "# Clean all external libraries for current architecture\n" .
        "clean-libs: \$(BUILDLIB:%=clean-%)\n" .
        "\t-\$(foreach file, \\\n" .
        &format_list("\t    \$(patsubst %, \$(OBJDIR_LIB)/%, ", 16, 70, SRCLIST_GENERATED, "\\\n", "\\") . "), \\\n" .
        "\t    \$(remove_file))\n" .
        "\t-\$(foreach file, \$(LIB), \$(remove_file))\n" .
        "\t\@echo \"# Removing object directories\"\n" .
        "\t\$(foreach dir, \$(OBJDIR_LIB), \$(remove_directory))\n\n" .

    # Purge statement
        "# Clean all object files for all architectures\n" .
        "# (But be utmost restrictive by only removing files created by a (recent) FEAT2 Makefile.)\n" .
        "purge:\tpurge-libs purge-app\n" .
        "\t\@echo \"# Removing Makefile\"\n" .
        "\t-rm -f $MAKEFILE $MAKEFILE.bak\n\n" .

        "# Clean all FEAT2 object files for all architectures\n" .
        "# (But be utmost restrictive by only removing files created by a (recent) FEAT2 Makefile.)\n" .
        "purge-app: PURGEDIR = \$(dir \$(OBJDIR))\n" .
        "purge-app:\n" .
        "        # Go to the directories that contain the architecture-specific\n" .
        "        # object sub-directories and delete in those sub-directories\n" .
        "        # * all object files in those where made from FEAT2 source files.\n" .
        "        # * all module information files in those where made from FEAT2\n" .
        "        #   Fortran 90 source files.\n" .
        "\t\@echo\n" .
        "\t\@echo \"# Cleaning up in FEAT2 object directory:\"\n" .
        "\t\@echo \"# Removing wrapped source files, object files and\"\n" .
        "\t\@echo \"# module information files.\"\n" .
        "\t-\$(foreach file, \\\n" .
        "\t    \$(patsubst %.f,  \$(PURGEDIR)*-*-*-*-*-opt*/%.o, \$(notdir \$(SRCF77))) \\\n" .
        &format_list("\t    \$(patsubst %,\$(PURGEDIR)*-*-*-*-*-opt*/%, ", 20, 70,
                     "\$(notdir \$(SRCF90)) \$(notdir \$(PROGRAM_FILE)) " . SRCLIST_GENERATED .
		     " \$(filter %.f90, \$(notdir \$(SRCEXTRA)))" .
		     " \$(notdir \$(INCLUDED_FILES_TO_COPY)) \$(notdir \$(INCLUDED_FILES_TO_EVALUATE_WITH_CPP))", "\\\n", "\\") . ") \\\n" .
        "\t    \$(patsubst %.f90,\$(PURGEDIR)*-*-*-*-*-opt*/%.o, \$(notdir \$(SRCF90)) \$(notdir \$(PROGRAM_FILE))) \\\n" .
        "\t    \$(patsubst %.f,  \$(PURGEDIR)*-*-*-*-*-opt*/%.o, \$(filter %.f,   \$(notdir \$(SRCEXTRA) \$(SRCEXTRA_APP)))) \\\n" .
        "\t    \$(patsubst %.f90,\$(PURGEDIR)*-*-*-*-*-opt*/%.o, \$(filter %.f90, \$(notdir \$(SRCEXTRA) \$(SRCEXTRA_APP)))) \\\n" .
        "\t    \$(patsubst %.c,  \$(PURGEDIR)*-*-*-*-*-opt*/%.o, \$(filter %.c,   \$(notdir \$(SRCEXTRA) \$(SRCEXTRA_APP)))) \\\n" .
        "\t    \$(patsubst %.cc, \$(PURGEDIR)*-*-*-*-*-opt*/%.o, \$(filter %.cc,  \$(notdir \$(SRCEXTRA) \$(SRCEXTRA_APP)))) \\\n" .
        "\t    \$(patsubst %.cu, \$(PURGEDIR)*-*-*-*-*-opt*/%.o, \$(filter %.cu,  \$(notdir \$(SRCEXTRA) \$(SRCEXTRA_APP)))) \\\n" .
        "\t    \$(patsubst %.f90,\$(PURGEDIR)*-*-*-*-*-opt*/%.\$(MODEXTENSION), \\\n" .
        "\t\t\$(notdir \$(SRCF90)) \$(notdir \$(PROGRAM_FILE))), \\\n" .
        "\t    \$(remove_file))\n" .
        "\t\@echo \"# Removing object directories\"\n" .
        "\t\$(foreach dir, \$(PURGEDIR)*-*-*-*-*-opt*, \$(remove_directory))\n" .
        "\t\@echo \"# Removing FEAT2 log and GMV & AVS output files\"\n" .
        "\t-rm -f feastlog.* *.gmv *.inp\n" .
        "\t\@echo \"# Removing autopartitioning, profiling and core file\"\n" .
        "\t-rm -f autopart[0-4].fpart gmon.out core\n\n" .

    # purge-libs statement
        "# Clean all object files of all external libraries for all architectures\n" .
        "# (But be utmost restrictive by only removing files created by a (recent) FEAT2 Makefile.)\n" .
        "purge-libs: PURGEDIR = \$(dir \$(OBJDIR_LIB))\n" .
	"# Ensure that all libraries are removed that have possibly been compiled\n" .
        "purge-libs: \$(ALLLIB:%=purge-%)\n" .
        "        # Go to the directories that contain the architecture-specific\n" .
        "        # object sub-directories and delete in those sub-directories\n" .
        "        # * all libraries shipped with FEAT2.\n" .
        "\t\@echo \"# Removing \$(ALLLIB) libraries\"\n" .
        "\t\@echo \"# for all build IDs\"\n" .
        "\t-\$(foreach file, \\\n" .
        "\t    \$(patsubst %, \$(PURGEDIR)*-*-*-*-*-opt*/lib%.a, \$(ALLLIB)) \\\n" .
        &format_list("\t    \$(patsubst %, \$(PURGEDIR)*-*-*-*-*-opt*/%, ", 16, 70, SRCLIST_GENERATED, "\\\n", "\\") . "), \\\n" .
        "\t    \$(remove_file))\n" .
        "\t\$(foreach dir, \$(PURGEDIR)*-*-*-*-*-opt*, \$(remove_directory))\n\n";

    # shortcut to delete an object file in the current object directory
    # (useful if you do not want to remember that directory name)
    print MAKEFILE_HDL
        "# shortcut to delete an object file in the current object directory\n" .
        "# (useful if you do not want to remember that directory name)\n" .
        "delete:\n" .
        "\t\@if test -z \"\$(FILE)\"; then \\\n" .
        "\t    echo \"ERROR: No file specified to delete in directory\"; \\\n" .
        "\t    echo \"       \$(OBJDIR).\"; \\\n" .
        "\t    echo \"Usage: \$(MAKE) delete FILE=<module.o>\"; \\\n" .
        "\telse \\\n" .
        "\t    if test -f \"\$(OBJDIR)/\$(FILE)\"; then \\\n" .
        "\t\techo \"# Removing \$(OBJDIR)/\$(FILE)\"; \\\n" .
        "\t\trm -f \$(OBJDIR)/\$(FILE); \\\n" .
        "\t    else \\\n" .
        "\t\techo \"No file found that could be removed!\"; \\\n" .
        "\t    fi; \\\n" .
        "\tfi;\n\n\n\n";


    ##############################################################################
    # Libraries (AGMG, AMD, blas, coproc, inshape2d, lapack, metis, splib, umfpack)
    print MAKEFILE_HDL
        "##############################################################################\n" .
        "# Libraries (AGMG, AMD, blas, coproc, inshape2d, lapack, metis, splib, umfpack)\n\n" .

        "# A prerequisite for all libraries is that the object directory\n" .
        "# to store should exist. The pipe is to determine that we want\n" .
        "# a order-only prerequisite. Thus, no recompiling happens when\n" .
        "# the time stamp of the object directory is newer than the files\n" .
        "# within!\n" .
        "\$(LIB): | \$(OBJDIR_LIB)\n" .
        "# Check also whether compiler or compile settings changed\n" .
        "\$(LIB): | check-or-store-settings\n\n" .

    # separate rule to download third party library tarballs
	"# separate rule to download third party library tarballs\n" .
        "getlibs:\t\$(ALLLIB:%=get-%)\n\n" .

    # coproc library path settings
        "# coproc library path settings\n" .
        "\$(OBJDIR_LIB)/libcoproc.a clean-coproc get-coproc purge-coproc: \\\n" .
        "\tDIR = \$(FEAT2BASEDIR)/librariesNEW/coproc\n\n" .

    # coproc library
        "# Create coproc library\n" .
	".PHONY: \$(OBJDIR_LIB)/libcoproc.a\n" .
        "\$(OBJDIR_LIB)/libcoproc.a:\n" .
        "\t\@echo \"# Building unified coproc library\"\n" .
        "\t(cd \$(DIR) && \\\n" .
        "\t    $makeInMakefile -f Makefile.FEAT2 \$\@ \\\n" .
        "\t\tCC=\"\$(PRECC) \$(CC)\" \\\n" .
	"\t\tCUDA=\"\$(PRECUDA) \$(CUDA)\" \\\n" .
        "\t\tOPT=\"\$(OPT)\" \\\n" .
        "\t\tCFLAGSCOPROC_FROM_FEAT2=\"\$(CFLAGSCOPROC)\" \\\n" .
        "\t\tCFLAGSCUDA=\"\$(CFLAGSCUDA)\" \\\n" .
        "\t\tCFLAGSF90=\"\$(CFLAGSF90) \$(MODOPTION)\$(OBJDIR)\" \\\n" .
        "\t\tAPPONLYFLAGS=\"\$(APPONLYFLAGS)\" \\\n" .
        "\t\tARCH=\"\$(AR)\" RANLIB=\"\$(RANLIB)\" \\\n" .
        "\t\tOBJDIR=\"\$(OBJDIR_LIB)\" \\\n" .
	"\t\t";

    my $tmparray = (defined($cl{'COPROCLIST'})) ? $cl{'COPROCLIST'} : $defaults{'COPROCLIST'};
    foreach $entry ( @{ $tmparray } ) {
	print MAKEFILE_HDL "HAS_" . uc($entry) . "=\"YES\" ";
    }
    print MAKEFILE_HDL
	")\n\n" .

    # metis library path settings
        "# metis library path settings\n" .
        "\$(OBJDIR_LIB)/libmetis.a clean-metis get-metis purge-metis: \\\n" .
        "\tDIR = \$(FEAT2BASEDIR)/librariesNEW/metis-5.0\n\n" .

    # metis library
        "# Create metis library\n" .
	".PHONY: \$(OBJDIR_LIB)/libmetis.a\n" .
        "\$(OBJDIR_LIB)/libmetis.a:\n" .
        "\t\@echo \"# Building metis library\"\n" .
        "\t(cd \$(DIR) && \\\n" .
        "\t    $makeInMakefile -f Makefile.FEAT2 \$\@ \\\n" .
        "\t\tCC=\"\$(PRECC) \$(CC)\" CFLAGSC=\"\$(CFLAGSC)\" \\\n" .
        "\t\tARCH=\"\$(AR)\" RANLIB=\"\$(RANLIB)\" \\\n" .
        "\t\tOBJDIR=\"\$(OBJDIR_LIB)\")\n\n" .

    # umfpack library path settings
        "# umfpack library path settings\n" .
        "\$(OBJDIR_LIB)/libumfpack.a clean-umfpack get-umfpack purge-umfpack: \\\n" .
        "\tDIR = \$(FEAT2BASEDIR)/librariesNEW/UMFPACK\n\n" .

    # umfpack library
        "# Create umfpack library\n" .
	".PHONY: \$(OBJDIR_LIB)/libumfpack.a\n" .
        "\$(OBJDIR_LIB)/libumfpack.a:\n" .
        "\t\@echo \"# Building umfpack library\"\n" .
        "\t(cd \$(DIR) && \\\n" .
        "\t    $makeInMakefile -f Makefile.FEAT2 \$\@ \\\n" .
        "\t\tCC=\"\$(PRECC) \$(CC)\" CXXVERSION=\"\$(CXXVERSION)\" CFLAGS=\"\$(CFLAGSC)\" \\\n" .
        "\t\tARCH=\"\$(AR)\" RANLIB=\"\$(RANLIB)\" \\\n" .
        "\t\tOBJDIR=\"\$(OBJDIR_LIB)\" ID=\"\$(ID)\")\n\n" .

    # AMD library path settings
        "# AMD library path settings\n" .
        "\$(OBJDIR_LIB)/libamd.a clean-amd get-amd purge-amd: \\\n" .
        "\tDIR = \$(FEAT2BASEDIR)/librariesNEW/AMD\n\n" .

    # AMD library
        "# Create AMD library\n" .
	".PHONY: \$(OBJDIR_LIB)/libamd.a\n" .
        "\$(OBJDIR_LIB)/libamd.a:\n" .
        "\t\@echo \"# Building amd library\"\n" .
        "\t(cd \$(DIR) && \\\n" .
        "\t    $makeInMakefile -f Makefile.FEAT2 \$\@ \\\n" .
        "\t\tCC=\"\$(PRECC) \$(CC)\" CFLAGS=\"\$(CFLAGSC)\" \\\n" .
        "\t\tARCH=\"\$(AR)\" RANLIB=\"\$(RANLIB)\" \\\n" .
        "\t\tOBJDIR=\"\$(OBJDIR_LIB)\")\n\n" .

    # blas path settings
        "# blas library path settings\n" .
        "\$(OBJDIR_LIB)/libblas.a clean-blas get-blas purge-blas: \\\n" .
        "\tDIR = \$(FEAT2BASEDIR)/librariesNEW/BLAS\n\n" .

    # blas library
        "# Create blas library\n" .
	".PHONY: \$(OBJDIR_LIB)/libblas.a\n" .
        "\$(OBJDIR_LIB)/libblas.a:\n" .
        "\t\@echo \"# Building blas library\"\n" .
        "\t(cd \$(DIR) && \\\n" .
        "\t    $makeInMakefile -f Makefile.FEAT2 \$\@ \\\n" .
        "\t\tFORTRAN=\"\$(PREF77) \$(F77)\" OPTS=\"\$(CFLAGSF77)\" \\\n" .
        "\t\tARCH=\"\$(AR)\" RANLIB=\"\$(RANLIB)\" \\\n" .
        "\t\tOBJDIR=\"\$(OBJDIR_LIB)\")\n\n" .

    # lapack path settings
        "# lapack library path settings\n" .
        "\$(OBJDIR_LIB)/liblapack.a clean-lapack get-lapack purge-lapack: \\\n" .
        "\tDIR = \$(FEAT2BASEDIR)/librariesNEW/lapack-3.5.0\n\n" .

    # lapack library
        "# Create lapack library\n" .
	".PHONY: \$(OBJDIR_LIB)/liblapack.a\n" .
        "ifeq (\$(GOTOBLAS_PATCH_FOR_LAPACK),)\n" .
        "\$(OBJDIR_LIB)/liblapack.a: GOTOBLAS_PATCH_FOR_LAPACK = NOT_REQUIRED\n" .
        "endif\n" .
        "\$(OBJDIR_LIB)/liblapack.a:\n" .
        "\t\@echo \"# Building lapack library\"\n" .
        "\t(cd \$(DIR) && \\\n" .
        "\t    $makeInMakefile -f Makefile.FEAT2 \$\@ \\\n" .
	"\t\tF95=\"eval \$(PREF90) \$(F90)\" OPTS=\"\$(CFLAGSF90) \$(MODOPTION)\$(OBJDIR_LIB)\" \\\n" .
        "\t\tARCH=\"\$(AR)\" RANLIB=\"\$(RANLIB)\" GOTOBLAS_PATCH_FOR_LAPACK=\"\$(GOTOBLAS_PATCH_FOR_LAPACK)\" \\\n" .
        "\t\tOBJDIR=\"\$(OBJDIR_LIB)\")\n\n" .

    # splib path settings
        "# splib library path settings\n" .
        "\$(OBJDIR_LIB)/libsplib.a clean-splib get-splib purge-splib: \\\n" .
        "\tDIR = \$(FEAT2BASEDIR)/librariesNEW/splib\n\n" .

    # splib library
        "# Create splib library\n" .
        ".PHONY: \$(OBJDIR_LIB)/libsplib.a\n" .
        "\$(OBJDIR_LIB)/libsplib.a:\n" .
        "\t\@echo \"# Building splib library\"\n" .
        "\t(cd \$(DIR) && \\\n" .
        "\t    $makeInMakefile -f Makefile.FEAT2 \$\@ \\\n" .
        "\t\tFORTRAN=\"\$(PREF77) \$(F77)\" OPTS=\"\$(CFLAGSF77)\" \\\n" .
        "\t\tARCH=\"\$(AR)\" RANLIB=\"\$(RANLIB)\" \\\n" .
        "\t\tOBJDIR=\"\$(OBJDIR_LIB)\")\n\n" .

    # inshape2d path settings
        "# inshape2d library path settings\n" .
        "\$(OBJDIR_LIB)/libinshape2d.a clean-inshape2d get-inshape2d purge-inshape2d: \\\n" .
        "\tDIR = \$(FEAT2BASEDIR)/librariesNEW/inshape\n\n" .

    # inshape2d library
        "# Create inshape2d library\n" .
        ".PHONY: \$(OBJDIR_LIB)/libinshape2d.a\n" .
        "\$(OBJDIR_LIB)/libinshape2d.a:\n" .
        "\t\@echo \"# Building inshape2d library\"\n" .
        "\t(cd \$(DIR) && \\\n" .
        "\t    $makeInMakefile -f Makefile.FEAT2 \$\@ \\\n" .
        "\t\tARCH=\"\$(AR)\" RANLIB=\"\$(RANLIB)\" \\\n" .
        "\t\tOBJDIR=\"\$(OBJDIR_LIB)\")\n\n" .

    # AGMG path settings
        "# AGMG library path settings\n" .
        "\$(OBJDIR_LIB)/libagmg.a clean-agmg get-agmg purge-agmg: \\\n" .
        "\tDIR = \$(FEAT2BASEDIR)/librariesNEW/AGMG_3.1.2\n\n" .

    # AGMG library
        "# Create AGMG library\n" .
	".PHONY: \$(OBJDIR_LIB)/libagmg.a\n" .
        "\$(OBJDIR_LIB)/libagmg.a:\n" .
        "\t\@echo \"# Building AGMG library\"\n" .
        "\t(cd \$(DIR) && \\\n" .
        "\t    $makeInMakefile -f Makefile.FEAT2 \$\@ \\\n" .
	"\t\tFORTRAN=\"\$(PREF90) eval \$(F90)\" OPTS=\"\$(CFLAGSF90) \$(MODOPTION)\$(OBJDIR_LIB)\" \\\n" .
        "\t\tARCH=\"\$(AR)\" RANLIB=\"\$(RANLIB)\" MODEXTENSION=\"\$(MODEXTENSION)\" \\\n" .
        "\t\tOBJDIR=\"\$(OBJDIR_LIB)\")\n\n";

    # Download rule for every library
    print MAKEFILE_HDL
	"# Download rule for every library\n" .
        "\$(ALLLIB:%=get-%):\n" .
	"\t(cd \$(DIR) && \$(MAKE) -f Makefile.FEAT2 getlibs)\n\n";

    # Clean rule for every library
    print MAKEFILE_HDL
        "# Clean rule for every library\n" .
        "\$(patsubst %,clean-%,\$(filter-out coproc, \$(BUILDLIB))):\n" .
        "\t\@-( cd \$(DIR) && \\\n" .
        "\t    \$(MAKE) -f Makefile.FEAT2 OBJDIR=\"\$(OBJDIR_LIB)\" MODEXTENSION=\"\$(MODEXTENSION)\" clean )\n" .
        "clean-coproc:\n" .
        "\t\@-( cd \$(DIR) && \\\n" .
        "\t    \$(MAKE) -f Makefile.FEAT2 OBJDIR=\"\$(OBJDIR_LIB)\" MODEXTENSION=\"\$(MODEXTENSION)\" ";
    $tmparray = (defined($cl{'COPROCLIST'})) ? $cl{'COPROCLIST'} : $defaults{'COPROCLIST'};
    foreach $entry ( @{ $tmparray } ) {
	print MAKEFILE_HDL "HAS_" . uc($entry) . "=\"YES\" ";
    }
    print MAKEFILE_HDL
	"clean )\n\n";

    # Purge rule for every library
    print MAKEFILE_HDL
        "# Purge rule for every library\n" .
        "\$(ALLLIB:%=purge-%): PURGEDIR = \$(dir \$(OBJDIR_LIB))\n" .
        "\$(patsubst %,purge-%,\$(filter-out coproc, \$(ALLLIB))):\n" .
        "\t\@-( cd \$(DIR) && \\\n" .
        "\t    \$(MAKE) -f Makefile.FEAT2 OBJDIR=\"\$(PURGEDIR)*-*-*-*-*-opt*\" MODEXTENSION=\"\$(MODEXTENSION)\" purge )\n" .
        "purge-coproc:\n" .
        "\t\@-( cd \$(DIR) && \\\n" .
        "\t    \$(MAKE) -f Makefile.FEAT2 OBJDIR=\"\$(PURGEDIR)*-*-*-*-*-opt*\" MODEXTENSION=\"\$(MODEXTENSION)\" ";
    $tmparray = (defined($cl{'COPROCLIST'})) ? $cl{'COPROCLIST'} : $defaults{'COPROCLIST'};
    foreach $entry ( @{ $tmparray } ) {
	print MAKEFILE_HDL "HAS_" . uc($entry) . "=\"YES\" ";
    }
    print MAKEFILE_HDL
	"purge )\n\n" .
        "\n\n";


    ##############################################################################
    # Shortcuts
    print MAKEFILE_HDL
        "##############################################################################\n" .
        "# Shortcuts\n\n" .

    # Shortcuts for all libraries:
    # e.g. invoke 'make metis', 'make libmetis' or 'make libmetis.a' to
    #      have \$(OBJDIR_LIB)/libmetis.a' built
        "# Shortcuts for all libraries:\n" .
        "# e.g. invoke 'make umfpack', 'make libumfpack' or 'make libumfpack.a' to\n" .
        "#      have \$(OBJDIR_LIB)/libumfpack.a' built\n" .
        ".PHONY: \$(BUILDLIB) \\\n" .
        "\t\$(patsubst %, lib%, \$(BUILDLIB)) \\\n" .
        "\t\$(patsubst %, lib%.a, \$(BUILDLIB))\n" .
        "\$(BUILDLIB):\n" .
        "\t@\$(MAKE) \$(OBJDIR_LIB)/lib\$@.a\n" .
        "\$(patsubst %, lib%, \$(BUILDLIB)):\n" .
        "\t@\$(MAKE) \$(OBJDIR_LIB)/\$@.a\n" .
        "\$(patsubst %, lib%.a, \$(BUILDLIB)):\n" .
        "\t@\$(MAKE) \$(OBJDIR_LIB)/\$@\n\n" .

    # Shortcuts for all FEAT2 object files:
    # e.g. invoke 'make assembly.o' to have 'make $(OBJDIR)/assembly.o' built
        "# Shortcuts for all FEAT2 object files:\n" .
        "# e.g. invoke 'make assembly.o' to have 'make \$(OBJDIR)/assembly.o' built\n" .
        ".PHONY: \$(patsubst %.f, %.o, \$(notdir \$(SRCF77))) \\\n" .
        "\t\$(patsubst %.f90, %.o, \$(notdir \$(SRCF90) \$(notdir \$(PROGRAM_FILE)))) \\\n" .
        "\t\$(notdir \$(OBJEXTRA))\n" .
        "\$(patsubst %.f, %.o, \$(notdir \$(SRCF77))) \\\n" .
        "\$(patsubst %.f90, %.o, \$(notdir \$(SRCF90) \$(notdir \$(PROGRAM_FILE)))) \\\n" .
        "\$(notdir \$(OBJEXTRA)):\n" .
        "\t\@\$(MAKE) \$(OBJDIR)/\$\@\n\n\n\n";


    ##############################################################################
    # Targets to check whether compilers and compile settings are consistent
    # among subsequent make invocations.

    # Store compiler modification dates and compiler settings etc.
    # for current build ID.
    # This information is later on used to check whether the object files
    # in \$(DIR) need to be recompiled.
    ##############################################################################
    print MAKEFILE_HDL
        "##############################################################################\n" .
        "# Targets to check whether compilers and compile settings are consistent\n" .
        "# among subsequent make invocations.\n\n" .
    #    ".PHONY:   check-or-store-settings\n" .
    #    "check-or-store-settings: | \$(OBJDIR_LIB) \$(OBJDIR)\n" .
    #    "ifeq (\$(strip \$(MONITOR_COMPILE_ENV)),YES)\n" .
    #    "\t\@\$(foreach target, \\\n" .
    #    "\t    check-settings-objdir check-settings-objdir_lib \\\n" .
    #    "\t    store-settings-objdir store-settings-objdir_lib, \\\n" .
    #    "\t    \$(MAKE) \$(target) || exit 1; )\n" .
    #    "endif\n\n" .

        "OBJDIR_LOCKFILE     = \$(OBJDIR)/LOCK.compile-env-settings\n" .
        "OBJDIR_LIB_LOCKFILE = \$(OBJDIR_LIB)/LOCK.compile-env-settings\n\n" .

        ".PHONY:    check-or-store-settings\n" .
        "check-or-store-settings: WAITTIME = 1\n" .
        "check-or-store-settings: RETRIES  = 10\n" .
        "check-or-store-settings: | \$(OBJDIR_LIB) \$(OBJDIR)\n" .
        "ifeq (\$(strip \$(MONITOR_COMPILE_ENV)),YES)\n" .
        "\t\@trap \"rm -f \$(OBJDIR_LOCKFILE)\" 2 3 9; \\\n" .
        "\tif test -f \$(OBJDIR_LOCKFILE); then \\\n" .
        "\t    if test \$(MAKELEVEL) -lt \$(RETRIES); then \\\n" .
        "\t\techo; \\\n" .
        "\t\techo \"#\"; \\\n" .
        "\t\techo \"# Detected concurrent read/write access to those files storing compile\"; \\\n" .
        "\t\techo \"# environment settings. Waiting for the other process to finish.\"; \\\n" .
        "\t\techo \"#\"; \\\n" .
        "\t\techo \"# If you are sure that this is a false alarm, simply remove the file\"; \\\n" .
        "\t\techo \"# <\$(OBJDIR_LOCKFILE)>.\"; \\\n" .
        "\t\techo \"# Then, compilation will proceed automatically.\"; \\\n" .
        "\t\techo \"#\"; \\\n" .
        "\t\techo; \\\n" .
        "\t\tsleep \$(WAITTIME); \\\n" .
        "\t\t\$(MAKE) check-or-store-settings; \\\n" .
        "\t    else \\\n" .
        "\t\techo; \\\n" .
        "\t\techo \"#\"; \\\n" .
        "\t\techo \"# Lock for read access to those files storing compile environment\"; \\\n" .
        "\t\techo \"# has not been released within \"`expr \$(WAITTIME) \\* \$(RETRIES)`\" seconds.\"; \\\n" .
        "\t\techo \"# Giving up.\"; \\\n" .
        "\t\techo \"#\"; \\\n" .
        "\t\techo \"# In case of a false alarm please manually remove file\"; \\\n" .
        "\t\techo \"# <\$(OBJDIR_LOCKFILE)>.\"; \\\n" .
        "\t\techo \"#\"; \\\n" .
        "\t\techo; \\\n" .
        "\t\texit 1; \\\n" .
        "\t    fi; \\\n" .
        "\telse \\\n" .
        "\t    touch \$(OBJDIR_LOCKFILE); \\\n" .
        "\t    error=0; \\\n" .
        "\t    if test -s \$(OBJDIR)/\$(COMPILER_SETTINGS); then \\\n" .
        "\t\t\$(MAKE) check-settings-objdir || error=1; \\\n" .
        "\t    else \\\n" .
        "\t\t\$(MAKE) store-settings-objdir || error=1; \\\n" .
        "\t    fi; \\\n" .
        "\t    rm -f \$(OBJDIR_LOCKFILE); \\\n" .
        "\t    if test \$\${error} = 1; then \\\n" .
        "\t\texit 1; \\\n" .
        "\t    fi; \\\n" .
        "\tfi; \\\n" .
        "\ttrap - 2 3 9;\n" .
        "\t\@trap \"rm -f \$(OBJDIR_LIB_LOCKFILE)\" 2 3 9; \\\n" .
        "\tif test -f \$(OBJDIR_LIB_LOCKFILE); then \\\n" .
        "\t    if test \$(MAKELEVEL) -lt \$(RETRIES); then \\\n" .
        "\t\techo; \\\n" .
        "\t\techo \"#\"; \\\n" .
        "\t\techo \"# Detected concurrent read/write access to those files storing compile\"; \\\n" .
        "\t\techo \"# environment settings. Waiting for the other process to finish.\"; \\\n" .
        "\t\techo \"#\"; \\\n" .
        "\t\techo \"# If you are sure that this is a false alarm, simply remove the file\"; \\\n" .
        "\t\techo \"# <\$(OBJDIR_LIB_LOCKFILE)>.\"; \\\n" .
        "\t\techo \"# Then, compilation will proceed automatically.\"; \\\n" .
        "\t\techo \"#\"; \\\n" .
        "\t\techo; \\\n" .
        "\t\tsleep \$(WAITTIME); \\\n" .
        "\t\t\$(MAKE) check-or-store-settings; \\\n" .
        "\t    else \\\n" .
        "\t\techo; \\\n" .
        "\t\techo \"#\"; \\\n" .
        "\t\techo \"# Lock for read access to those files storing compile environment\"; \\\n" .
        "\t\techo \"# has not been released within \"`expr \$(WAITTIME) \\* \$(RETRIES)`\" seconds.\"; \\\n" .
        "\t\techo \"# Giving up.\"; \\\n" .
        "\t\techo \"#\"; \\\n" .
        "\t\techo \"# In case of a false alarm please manually remove file\"; \\\n" .
        "\t\techo \"# <\$(OBJDIR_LIB_LOCKFILE)>.\"; \\\n" .
        "\t\techo \"#\"; \\\n" .
        "\t\techo; \\\n" .
        "\t\texit 1; \\\n" .
        "\t    fi; \\\n" .
        "\telse \\\n" .
        "\t    touch \$(OBJDIR_LIB_LOCKFILE); \\\n" .
        "\t    error=0; \\\n" .
        "\t    if test -s \$(OBJDIR_LIB)/\$(COMPILER_SETTINGS); then \\\n" .
        "\t\t\$(MAKE) check-settings-objdir_lib || error=1; \\\n" .
        "\t    else \\\n" .
        "\t\t\$(MAKE) store-settings-objdir_lib || error=1; \\\n" .
        "\t    fi; \\\n" .
        "\t    rm -f \$(OBJDIR_LIB_LOCKFILE); \\\n" .
        "\t    if test \$\${error} = 1; then \\\n" .
        "\t\texit 1; \\\n" .
        "\t    fi; \\\n" .
        "\tfi; \\\n" .
        "\ttrap - 2 3 9;\n" .
        "endif\n\n" .


    # Check whether compiler modification dates or compiler settings for
    # current build ID have changed since last invocation of make.
    # If so, force re-compilation.
        "# Check whether compiler modification dates or compiler settings for\n" .
        "# current build ID have changed since last invocation of make.\n" .
        "# If so, force re-compilation.\n" .
        ".PHONY:    check-settings-objdir\n" .
        "check-settings-objdir: DIR = \$(OBJDIR)\n" .
        "check-settings-objdir: \$(OBJDIR)\n" .
        "        # Checking whether compiler or compiler command line settings\n" .
        "        # used to build the application have changed since last time\n" .
        "        # 'make' was run for this build ID.\n" .
        "        # What exactly is done here?\n" .
        "        # In total, 11 files are created in the current object directory.\n" .
        "        # 2 per compiler, 1 for the compiler command line settings. These\n" .
        "        # settings are compared to previously stored ones.\n" .
        "        # For every compiler the output of 'ls -lLd <absolute_path_to_compiler>'\n" .
        "        # is stored in one file. To a separate file, the output of '<compiler>\n" .
        "        # <get-version-info>' is stored. As the syntax to retrieve the compiler\n" .
        "        # version is different for most compilers, the variables F77VERSION,\n" .
        "        # F90VERSION, CCVERSION and CXXVERSION are evaluated. They are defined\n" .
        "        # in one of templates/*.mk files. These 8 files should catch\n" .
        "        # all cases where a compiler has been updated, swapped for another and\n" .
        "        # similar. In general, it is not recommended to mix object files created\n" .
        "        # by different compiler or compiler versions.\n" .
        "        # Compiler command line settings are stored as well. This is done to\n" .
        "        # catch altered preprocessor macros: '-DFOO -DBAR' is used the first\n" .
        "        # time an application is compiled while for the second compilation\n" .
        "        # settings have been changed to '-DBAZ'. Ordinary Makefile don't detect\n" .
        "        # this despite the change possibly having a big impact on which code\n" .
        "        # is compiled. The same holds true for different kind of optimisation\n" .
        "        # flags. The mechanism ensures that all object files have been compiled\n" .
        "        # with the very same settings when it comes to linking. The settings\n" .
        "        # stored are:\n" .
        "        # CFLAGSF77     = [...]\n" .
        "        # CFLAGSF90     = [...]\n" .
        "        # CFLAGSC       = [...]\n" .
        "        # CFLAGSCOPROC  = [...]\n" .
        "        # CFLAGSCXX     = [...]\n" .
        "        # CFLAGSCUDA    = [...]\n" .
        "        # APPONLYFLAGS  = [...]\n" .
        "        # INC           = [...]\n" .
        "        # The output is similar to the corresponding lines of 'make id' output.\n" .
        "        # Path information, however, needs to be removed from these settings.\n" .
        "        # Otherwise, it would not be possible to share libraries among FEAT2\n" .
        "        # applications as the settings above often contain absolute paths to\n" .
        "        # object directories which would lead to conflicts, e.g.:\n" .
        "        # CFLAGSF90    = [...] -moddir=/home/foo/nobackup/feat2obj/benchmark/apps_poisson/object\n" .
        "        # CFLAGSF90    = [...] -moddir=/home/foo/nobackup/feat2obj/benchmark/apps_stokes/object\n" .
        "\t\@+\\\n" .
        "\tLC_ALL=C; \\\n" .
        "\tadditionalflags=\"APPONLYFLAGS  = \$(APPONLYFLAGS)\"; \\\n" .
        "\tmessage=\"\"; \\\n" .
        "\tCOMPILERNAME=\"F77\"; COMPILER=\"\$(PREF77) \$(F77)\"; \\\n" .
        "\tCOMPILERVERSION=\"\$(F77VERSION)\"; \\\n" .
        "\tFILE=\"\$(DIR)/\$(FILE_F77_INFO).version\"; \$(version-info-compiler-foo); \\\n" .
        "\tFILE=\"\$(DIR)/\$(FILE_F77_INFO).ls\";      \$(ls-lLd-for-compiler-foo); \\\n" .
        "\tCOMPILERNAME=\"F90\"; COMPILER=\"\$(PREF90) \$(F90)\"; \\\n" .
        "\tCOMPILERVERSION=\"\$(F90VERSION)\"; \\\n" .
        "\tFILE=\"\$(DIR)/\$(FILE_F90_INFO).version\"; \$(version-info-compiler-foo); \\\n" .
        "\tFILE=\"\$(DIR)/\$(FILE_F90_INFO).ls\";      \$(ls-lLd-for-compiler-foo); \\\n" .
        "\tCOMPILERNAME=\"C\"; COMPILER=\"\$(PRECC) \$(CC)\"; \\\n" .
        "\tCOMPILERVERSION=\"\$(CCVERSION)\"; \\\n" .
        "\tFILE=\"\$(DIR)/\$(FILE_CC_INFO).version\";  \$(version-info-compiler-foo); \\\n" .
        "\tFILE=\"\$(DIR)/\$(FILE_CC_INFO).ls\";       \$(ls-lLd-for-compiler-foo); \\\n" .
        "\tCOMPILERNAME=\"C++\"; COMPILER=\"\$(PRECXX) \$(CXX)\"; \\\n" .
        "\tCOMPILERVERSION=\"\$(CXXVERSION)\"; \\\n" .
        "\tFILE=\"\$(DIR)/\$(FILE_CXX_INFO).version\"; \$(version-info-compiler-foo); \\\n" .
        "\tFILE=\"\$(DIR)/\$(FILE_CXX_INFO).ls\";      \$(ls-lLd-for-compiler-foo); \\\n" .
        "\tCOMPILERNAME=\"CUDA\"; COMPILER=\"\$(PRECUDA) \$(CUDA)\"; \\\n" .
        "\tCOMPILERVERSION=\"\$(CUDAVERSION)\"; \\\n" .
        "\tFILE=\"\$(DIR)/\$(FILE_CUDA_INFO).version\"; \$(version-info-compiler-foo); \\\n" .
        "\tFILE=\"\$(DIR)/\$(FILE_CUDA_INFO).ls\";      \$(ls-lLd-for-compiler-foo); \\\n" .
        "\tif test -s \$(DIR)/\$(COMPILER_SETTINGS); then \\\n" .
        "\t    recompile=no; \\\n" .
        "\t    (echo 'CFLAGSF77     =' \$(CFLAGSF77); \\\n" .
        "\t     echo 'CFLAGSF90     =' \$(CFLAGSF90); \\\n" .
        "\t     echo 'CFLAGSC       =' \$(CFLAGSC); \\\n" .
        "\t     echo 'CFLAGSCOPROC  =' \$(CFLAGSCOPROC); \\\n" .
        "\t     echo 'CFLAGSCXX     =' \$(CFLAGSCXX); \\\n" .
        "\t     echo 'CFLAGSCUDA    =' \$(CFLAGSCUDA); \\\n" .
        "\t     echo \$\${additionalflags}; \\\n" .
        "\t     echo 'INC           =' \$(INC); ) | \\\n" .
        "\t\tsed -e \"s^-DENABLE_SERIAL_BUILD[ ]*^^g; \\\n" .
        "\t\t\ts^\$(OBJDIR)^<path information intentionally removed by make>^g; \\\n" .
        "\t\t\ts^\$(OBJDIR_LIB)^<path information intentionally removed by make>^g;\" | \\\n" .
        "\t\tdiff -q -w \$(DIR)/\$(COMPILER_SETTINGS) -  || recompile=yes; \\\n" .
        "\t    if test \$\${recompile} = yes; then \\\n" .
        "\t\techo; \\\n" .
        "\t\techo \"#######################################################################\"; \\\n" .
        "\t\techo \"# It seems this application's source code has been compiled before -\"; \\\n" .
        "\t\techo \"# or at least one of the self-compiled libraries the application uses\"; \\\n" .
        "\t\techo \"# - because object files from a previous compilation still linger.\"; \\\n" .
        "\t\techo \"# Either you did compile it before or the person from which you\"; \\\n" .
        "\t\techo \"# copied the source code did. The problem is that this time a\"; \\\n" .
        "\t\techo \"# different compiler or compiler version (or even an entirely\"; \\\n" .
        "\t\techo \"# different operating system) than before is being used or that\"; \\\n" .
        "\t\techo \"# compiler options were passed to the compiler that differ from those\"; \\\n" .
        "\t\techo \"# used before.\"; \\\n" .
        "\t\techo \"#\"; \\\n" .
        "\t\techo \"# As a result, you would have mixed potentially incompatible object\"; \\\n" .
        "\t\techo \"# files in the final build step of linking your application. It could\"; \\\n" .
        "\t\techo \"# have worked, but just as well even have failed - at compile or,\"; \\\n" .
        "\t\techo \"# even worse, (sometimes) at run time - in unpredictable, unexpected,\"; \\\n" .
        "\t\techo \"# very subtle ways.\"; \\\n" .
        "\t\techo \"#\"; \\\n" .
        "\t\techo \"# Which is why the Featflow2 build system intercepted compilation and\"; \\\n" .
        "\t\techo \"# presents you this error message. To resolve the issue, do a clean\"; \\\n" .
        "\t\techo \"# build.\"; \\\n" .
        "\t\techo \"#\"; \\\n" .
        "\t\toverwrittenmakevars=\"`echo \$(MAKEFLAGS) | awk '/^.* -- / { sub(/^.* -- /, \"\"); print \$0}'`\"; \\\n" .
        "\t\techo \"#     % \$(MAKE) \$\${overwrittenmakevars} clean; \$(MAKE) \$\${overwrittenmakevars}\"; \\\n" .
        "\t\techo \"#\"; \\\n" .
        "\t\techo \"# ---------------------------------------------------------------------\"; \\\n" .
        "\t\techo \"#\"; \\\n" .
        "\t\techo \"# Technical details on the conflicts found:\"; \\\n" .
        "\t\techo \"#\"; \\\n" .
        "\t\techo \"# The following output is raw 'diff' output of the previous vs. current\"; \\\n" .
        "\t\techo \"# compiler settings:\"; \\\n" .
        "\t\techo \"#\"; \\\n" .
        "\t\t(echo 'CFLAGSF77     =' \$(CFLAGSF77); \\\n" .
        "\t\t echo 'CFLAGSF90     =' \$(CFLAGSF90); \\\n" .
        "\t\t echo 'CFLAGSC       =' \$(CFLAGSC); \\\n" .
        "\t\t echo 'CFLAGSCOPROC  =' \$(CFLAGSCOPROC); \\\n" .
        "\t\t echo 'CFLAGSCXX     =' \$(CFLAGSCXX); \\\n" .
        "\t\t echo 'CFLAGSCUDA    =' \$(CFLAGSCUDA); \\\n" .
        "\t\t echo \$\${additionalflags}; \\\n" .
        "\t\t echo 'INC           =' \$(INC); ) | \\\n" .
        "\t\t    sed -e \"s^-DENABLE_SERIAL_BUILD[ ]*^^g; \\\n" .
        "\t\t\t    s^\$(OBJDIR)^<path information intentionally removed by make>^g; \\\n" .
        "\t\t\t    s^\$(OBJDIR_LIB)^<path information intentionally removed by make>^g;\" | \\\n" .
        "\t\t    diff -w \$(DIR)/\$(COMPILER_SETTINGS) -; \\\n" .
        "\t\tif test -n \"\$\${message}\"; then \\\n" .
        "\t\t    echo \"#\"; \\\n" .
        "\t\t    echo \"#\"; \\\n" .
        "\t\t    echo \"# Additionally holds:\"; \\\n" .
        "\t\t    echo \$\${message} | LC_ALL=C perl -pe 's/NEWLINE /\\n/g; s/NEWLINE//g;'; \\\n" .
        "\t\t    message=\"\"; \\\n" .
        "\t\tfi; \\\n" .
        "\t\techo \"#\";  \\\n" .
        "\t\techo \"#\";  \\\n" .
        "\t\techo \"# Once again: This FEAT2 application SHOULD BE RECOMPILED.\"; \\\n" .
        "\t\techo \"# Please issue at least a\"; \\\n" .
        "\t\techo \"#     % \$(MAKE) \$\${overwrittenmakevars} clean-app; \$(MAKE) \$\${overwrittenmakevars} obj\"; \\\n" .
        "\t\techo \"# or if you prefer tabula rasa\"; \\\n" .
        "\t\techo \"#     % \$(MAKE) \$\${overwrittenmakevars} clean; \$(MAKE) \$\${overwrittenmakevars}\"; \\\n" .
        "\t\techo \"#\";  \\\n" .
        "\t\techo \"# (Note: If you believe this is a false positive result and know what\"; \\\n" .
        "\t\techo \"#        you are doing you can deactivate this object files\"; \\\n" .
        "\t\techo \"#        compatibility check - at your own risk - by compiling with\"; \\\n" .
        "\t\techo \"#        'MONITOR_COMPILE_ENV=NO'.)\"; \\\n" .
        "\t\techo \"#######################################################################\"; \\\n" .
        "\t\trm -f \$(OBJDIR_LOCKFILE); \\\n" .
        "\t\texit 1; \\\n" .
        "\t    fi; \\\n" .
        "\tfi; \\\n" .
        "\tif test -n \"\$\${message}\"; then \\\n" .
        "\t    echo \$\${message} | LC_ALL=C perl -pe 's/NEWLINE /\\n/g; s/NEWLINE//g;'; \\\n" .
        "\t    rm -f \$(OBJDIR_LOCKFILE); \\\n" .
        "\t    exit 1; \\\n" .
        "\tfi;\n\n" .

        ".PHONY:    check-settings-objdir_lib\n" .
        "check-settings-objdir_lib: DIR = \$(OBJDIR_LIB)\n" .
        "check-settings-objdir_lib: \$(OBJDIR_LIB)\n" .
        "ifneq (\$(OBJDIR_LIB), \$(OBJDIR))\n" .
        "        # Checking whether compiler or compiler command line settings\n" .
        "        # used to build the libraries have changed since last time\n" .
        "        # 'make' was run for this build ID.\n" .
        "        # What exactly is done here? See comment in target check-settings-objdir.\n" .
        "\t\@+\\\n" .
        "\tLC_ALL=C; \\\n" .
        "\tadditionalflags=\"\"; \\\n" .
        "\tmessage=\"\"; \\\n" .
        "\tCOMPILERNAME=\"F77\"; COMPILER=\"\$(PREF77) \$(F77)\"; \\\n" .
        "\tCOMPILERVERSION=\"\$(F77VERSION)\"; \\\n" .
        "\tFILE=\"\$(DIR)/\$(FILE_F77_INFO).version\"; \$(version-info-compiler-foo); \\\n" .
        "\tCOMPILERNAME=\"F90\"; COMPILER=\"\$(PREF90) \$(F90)\"; \\\n" .
        "\tCOMPILERVERSION=\"\$(F90VERSION)\"; \\\n" .
        "\tFILE=\"\$(DIR)/\$(FILE_F90_INFO).version\"; \$(version-info-compiler-foo); \\\n" .
        "\tCOMPILERNAME=\"C\"; COMPILER=\"\$(PRECC) \$(CC)\"; \\\n" .
        "\tCOMPILERVERSION=\"\$(CCVERSION)\"; \\\n" .
        "\tFILE=\"\$(DIR)/\$(FILE_CC_INFO).version\";  \$(version-info-compiler-foo); \\\n" .
        "\tCOMPILERNAME=\"C++\"; COMPILER=\"\$(PRECXX) \$(CXX)\"; \\\n" .
        "\tCOMPILERVERSION=\"\$(CXXVERSION)\"; \\\n" .
        "\tFILE=\"\$(DIR)/\$(FILE_CXX_INFO).version\"; \$(version-info-compiler-foo); \\\n" .
        "\tCOMPILERNAME=\"CUDA\"; COMPILER=\"\$(PRECUDA) \$(CUDA)\"; \\\n" .
        "\tCOMPILERVERSION=\"\$(CUDAVERSION)\"; \\\n" .
        "\tFILE=\"\$(DIR)/\$(FILE_CUDA_INFO).version\"; \$(version-info-compiler-foo); \\\n" .
        "\tif test -s \$(DIR)/\$(COMPILER_SETTINGS); then \\\n" .
        "\t    recompile=no; \\\n" .
        "\t    (echo 'CFLAGSF77     =' \$(CFLAGSF77); \\\n" .
        "\t     echo 'CFLAGSF90     =' \$(CFLAGSF90); \\\n" .
        "\t     echo 'CFLAGSC       =' \$(CFLAGSC); \\\n" .
        "\t     echo 'CFLAGSCOPROC  =' \$(CFLAGSCOPROC); \\\n" .
        "\t     echo 'CFLAGSCXX     =' \$(CFLAGSCXX); \\\n" .
        "\t     echo 'CFLAGSCUDA    =' \$(CFLAGSCUDA); \\\n" .
        "\t     echo \$\${additionalflags}; \\\n" .
        "\t     echo 'INC           =' \$(INC); ) | \\\n" .
        "\t\tsed -e \"s^-DENABLE_SERIAL_BUILD[ ]*^^g; \\\n" .
        "\t\t\ts^\$(OBJDIR)^<path information intentionally removed by make>^g; \\\n" .
        "\t\t\ts^\$(OBJDIR_LIB)^<path information intentionally removed by make>^g;\" | \\\n" .
        "\t\tdiff -q -w \$(DIR)/\$(COMPILER_SETTINGS) -  || recompile=yes; \\\n" .
        "\t    if test \$\${recompile} = yes; then \\\n" .
        "\t\techo; \\\n" .
        "\t\techo \"#######################################################################\"; \\\n" .
        "\t\techo \"# It seems (at least) one of the libraries this application uses and\"; \\\n" .
        "\t\techo \"# that are about to be compiled along with the application has been\"; \\\n" .
        "\t\techo \"# compiled before, because object files from a previous compilation\"; \\\n" .
        "\t\techo \"# still linger. Either you did compile it before or the person from\"; \\\n" .
        "\t\techo \"# which you copied the source code did. The problem is that this time\"; \\\n" .
        "\t\techo \"# a different compiler or compiler version (or even an entirely\"; \\\n" .
        "\t\techo \"# different operating system) than before is being used or that\"; \\\n" .
        "\t\techo \"# compiler options were passed to the compiler that differ from those\"; \\\n" .
        "\t\techo \"# used before.\"; \\\n" .
        "\t\techo \"#\"; \\\n" .
        "\t\techo \"# As a result, you would have mixed potentially incompatible object\"; \\\n" .
        "\t\techo \"# files in the final build step of linking your application. It could\"; \\\n" .
        "\t\techo \"# have worked, but just as well even have failed - at compile or,\"; \\\n" .
        "\t\techo \"# even worse, (sometimes) at run time - in unpredictable, unexpected,\"; \\\n" .
        "\t\techo \"# very subtle ways.\"; \\\n" .
        "\t\techo \"#\"; \\\n" .
        "\t\techo \"# Which is why the Featflow2 build system intercepted compilation and\"; \\\n" .
        "\t\techo \"# presents you this error message. To resolve the issue, do a clean\"; \\\n" .
        "\t\techo \"# build.\"; \\\n" .
        "\t\techo \"#\"; \\\n" .
        "\t\toverwrittenmakevars=\"`echo \$(MAKEFLAGS) | awk '/^.* -- / { sub(/^.* -- /, \"\"); print \$0}'`\"; \\\n" .
        "\t\techo \"#     % \$(MAKE) \$\${overwrittenmakevars} clean-libs; \$(MAKE) \$\${overwrittenmakevars} libs\"; \\\n" .
        "\t\techo \"#\"; \\\n" .
        "\t\techo \"# ---------------------------------------------------------------------\"; \\\n" .
        "\t\techo \"#\"; \\\n" .
        "\t\techo \"# Technical details on the conflicts found:\"; \\\n" .
        "\t\techo \"#\"; \\\n" .
        "\t\techo \"# The following output is raw 'diff' output of the previous vs. current\"; \\\n" .
        "\t\techo \"# compiler settings:\"; \\\n" .
        "\t\techo \"#\"; \\\n" .
        "\t\t(echo 'CFLAGSF77     =' \$(CFLAGSF77); \\\n" .
        "\t\t echo 'CFLAGSF90     =' \$(CFLAGSF90); \\\n" .
        "\t\t echo 'CFLAGSC       =' \$(CFLAGSC); \\\n" .
        "\t\t echo 'CFLAGSCOPROC  =' \$(CFLAGSCOPROC); \\\n" .
        "\t\t echo 'CFLAGSCXX     =' \$(CFLAGSCXX); \\\n" .
        "\t\t echo 'CFLAGSCUDA    =' \$(CFLAGSCUDA); \\\n" .
        "\t\t echo \$\${additionalflags}; \\\n" .
        "\t\t echo 'INC           =' \$(INC); ) | \\\n" .
        "\t\t    sed -e \"s^-DENABLE_SERIAL_BUILD[ ]*^^g; \\\n" .
        "\t\t\t    s^\$(OBJDIR)^<path information intentionally removed by make>^g; \\\n" .
        "\t\t\t    s^\$(OBJDIR_LIB)^<path information intentionally removed by make>^g;\" | \\\n" .
        "\t\t    diff -w \$(DIR)/\$(COMPILER_SETTINGS) -; \\\n" .
        "\t\tif test -n \"\$\${message}\"; then \\\n" .
        "\t\t    echo \"#\"; \\\n" .
        "\t\t    echo \"#\"; \\\n" .
        "\t\t    echo \"# Additionally holds:\"; \\\n" .
        "\t\t    echo \$\${message} | LC_ALL=C perl -pe 's/NEWLINE /\\n/g; s/NEWLINE//g;'; \\\n" .
        "\t\t    message=\"\"; \\\n" .
        "\t\tfi; \\\n" .
        "\t\techo \"#\";  \\\n" .
        "\t\techo \"#\";  \\\n" .
        "\t\techo \"# Once again: The libraries this FEAT2 application relies on SHOULD BE\"; \\\n" .
        "\t\techo \"# RECOMPILED. Please issue at least a\"; \\\n" .
        "\t\techo \"#     % \$(MAKE) \$\${overwrittenmakevars} clean-libs; \$(MAKE) \$\${overwrittenmakevars} libs\"; \\\n" .
        "\t\techo \"# or if you prefer tabula rasa\"; \\\n" .
        "\t\techo \"#     % \$(MAKE) \$\${overwrittenmakevars} clean; \$(MAKE) \$\${overwrittenmakevars}\"; \\\n" .
        "\t\techo \"#\";  \\\n" .
        "\t\techo \"# (Note: If you believe this is a false positive result and know what\"; \\\n" .
        "\t\techo \"#        you are doing you can deactivate this object files\"; \\\n" .
        "\t\techo \"#        compatibility check - at your own risk - by compiling with\"; \\\n" .
        "\t\techo \"#        'MONITOR_COMPILE_ENV=NO'.)\"; \\\n" .
        "\t\techo \"#######################################################################\"; \\\n" .
        "\t\trm -f \$(OBJDIR_LIB_LOCKFILE); \\\n" .
        "\t\texit 1; \\\n" .
        "\t    fi; \\\n" .
        "\tfi; \\\n" .
        "\tif test -n \"\$\${message}\"; then \\\n" .
        "\t    echo \$\${message} | LC_ALL=C perl -pe 's/NEWLINE /\\n/g; s/NEWLINE//g;'; \\\n" .
        "\t    rm -f \$(OBJDIR_LOCKFILE); \\\n" .
        "\t    exit 1; \\\n" .
        "\tfi;\n" .
        "endif\n\n" .

        "# Function to check whether the version string of program <foo>,\n" .
        "# obtainable via variable \${FOOVERSION}, differs from the\n" .
        "# information stored in \${FILE}.\n" .
        "#\n" .
        "# When parallel compiling several applications that share the same\n" .
        "# object directory for libraries, it can happen that make process A\n" .
        "# starts to create \${FILE} (so \${FILE} being empty, but existing)\n" .
        "# while make process B tries already to check settings inside.\n" .
        "# So, we do not check with 'test -f', but 'test -s'.\n" .
        "define version-info-compiler-foo\n" .
        "    recompile=no; \\\n" .
        "    if test -s \$\${FILE}; then \\\n" .
        "\tif test -n \"\$\${COMPILERVERSION}\"; then \\\n" .
        "\t    eval \$\${COMPILERVERSION} | \\\n" .
        "\t    diff -w \$\${FILE} - > /dev/null || \\\n" .
        "\t    recompile=yes; \\\n" .
        "\telse \\\n" .
        "\t    echo; echo \"Error: \$\${COMPILER} not found.\"; echo; \\\n" .
        "\t    rm -f \$(OBJDIR_LOCKFILE); exit 1; \\\n" .
        "\tfi; \\\n" .
        "\tif test \$\${recompile} = yes; then \\\n" .
        "\t    message=`echo \$\${message}; echo \"#NEWLINE\"`; \\\n" .
        "\t    message=`echo \$\${message}; echo \"# Version information of \$\${COMPILERNAME} compiler has changed:NEWLINE\"`; \\\n" .
        "\t    message=`echo \$\${message}; echo \"#  previously: \\`cat \$\${FILE}\\`NEWLINE\"`; \\\n" .
        "\t    message=`echo \$\${message}; echo \"#  currently : \\`eval \$\${COMPILERVERSION}\\`NEWLINE\"`; \\\n" .
        "\t    message=`echo \$\${message}; echo \"#  (command used to determine this: \$\${COMPILERVERSION})NEWLINE\"`; \\\n" .
        "\tfi; \\\n" .
        "    fi\n" .
        "endef\n\n\n" .

        "# Function to check whether the output of 'ls -lLd <foo>' differs\n" .
        "# from the information stored in \${FILE}.\n" .
        "#\n" .
        "# (When parallel compiling several applications that share the same\n" .
        "#  object directory for libraries, it can happen that make process A\n" .
        "#  starts to create \${FILE} (so \${FILE} being empty, but existing)\n" .
        "#  while make process B tries already to check settings inside.\n" .
        "#  So, we do not check with 'test -f', but 'test -s'.)\n" .
        "define ls-lLd-for-compiler-foo\n" .
        "    LC_ALL=C; \\\n" .
        "    recompile=no; \\\n" .
        "    if test -s \$\${FILE}; then \\\n" .
        "\tcompilerpath=`which \$\${COMPILER} 2> /dev/null`; \\\n" .
        "\tif test -n \"\$\${compilerpath}\"; then \\\n" .
        "\t    ls -lLd \$\${compilerpath} | \\\n" .
        "\t    diff -w \$\${FILE} - > /dev/null || \\\n" .
        "\t    recompile=yes; \\\n" .
        "\telse \\\n" .
        "\t    echo; echo \"Error: \$\${COMPILER} not found.\"; echo; \\\n" .
        "\t    rm -f \$(OBJDIR_LOCKFILE) \$(OBJDIR_LIB_LOCKFILE); \\\n" .
        "\t    exit 1; \\\n" .
        "\tfi; \\\n" .
        "\tif test \$\${recompile} = yes; then \\\n" .
        "\t    message=`echo \$\${message}; echo \"#NEWLINE\"`; \\\n" .
        "\t    message=`echo \$\${message}; echo \"# File information of \$\${COMPILERNAME} compiler has changed:NEWLINE\"`; \\\n" .
        "\t    message=`echo \$\${message}; echo \"#  previously: \\`cat \$\${FILE}\\`NEWLINE\"`; \\\n" .
        "\t    message=`echo \$\${message}; echo \"#  currently : \\`ls -lLd \$\${compilerpath}\\`NEWLINE\"`; \\\n" .
        "\t    message=`echo \$\${message}; echo \"#  (command used to determine this: ls -lLd \$\${compilerpath})NEWLINE\"`; \\\n" .
        "\tfi; \\\n" .
        "    fi\n" .
        "endef\n\n\n" .

    # Store compiler modification dates and compiler settings etc.
    # for current build ID.
    # This information is later on used to check whether the object files
    # in $(DIR) need to be recompiled.
        "# Store compiler modification dates and compiler settings etc.\n" .
        "# for current build ID.\n" .
        "# This information is later on used to check whether the object files\n" .
        "# in \$(DIR) need to be recompiled.\n" .
        ".PHONY:    store-settings-objdir\n" .
        "store-settings-objdir: DIR = \$(OBJDIR)\n" .
        "store-settings-objdir: \$(OBJDIR) #| check-settings-objdir\n" .
        "\t\@+additionalflags=\"APPONLYFLAGS  = \$(APPONLYFLAGS)\"; \\\n" .
	"\techo \"# Storing current compiler and compiler command line settings\"; \\\n" .
	"\techo \"# used to compile the application for subsequent 'make' calls\"; \\\n" .
        "\techo \"# to detect future changes and force automatic recompilation...\"; \\\n" .
        "\t\$(store-settings)\n\n" .

        ".PHONY:    store-settings-objdir_lib\n" .
        "store-settings-objdir_lib: DIR = \$(OBJDIR_LIB)\n" .
        "store-settings-objdir_lib: \$(OBJDIR_LIB) #| check-settings-objdir_lib\n" .
        "ifneq (\$(OBJDIR_LIB), \$(OBJDIR))\n" .
        "\t\@+additionalflags=\"\"; \\\n" .
	"\techo \"# Storing current compiler and compiler command line settings\"; \\\n" .
	"\techo \"# used to compile the libraries for subsequent 'make' calls\"; \\\n" .
        "\techo \"# to detect future changes and force automatic recompilation...\"; \\\n" .

        "\t\$(store-settings)\n" .
        "endif\n\n" .

        "# What exactly is done here?\n" .
        "# In total, 11 files are created in the current object directory.\n" .
        "# 2 per compiler, 1 for the compiler command line settings.\n" .
        "# For every compiler the output of 'ls -lLd <absolute_path_to_compiler>'\n" .
        "# is stored in one file. To a separate file, the output of '<compiler>\n" .
        "# <get-version-info>' is stored. As the syntax to retrieve the compiler\n" .
        "# version is different for most compilers, the variables F77VERSION,\n" .
        "# F90VERSION, CCVERSION and CXXVERSION are evaluated. They are defined\n" .
        "# in one of kernel/arch/templates/*.mk files. These 8 files should catch\n" .
        "# all cases where a compiler has been updated, swapped for another and\n" .
        "# similar. In general, it is not recommended to mix object files created\n" .
        "# by different compiler or compiler versions.\n" .
        "# Compiler command line settings are stored as well. This is done to\n" .
        "# catch altered preprocessor macros: '-DFOO -DBAR' is used the first\n" .
        "# time an application is compiled while for the second compilation\n" .
        "# settings have been changed to '-DBAZ'. Ordinary Makefile don't detect\n" .
        "# this despite the change possibly having a big impact on which code\n" .
        "# is compiled. The same holds true for different kind of optimisation\n" .
        "# flags. The mechanism ensures that all object files have been compiled\n" .
        "# with the very same settings when it comes to linking. The settings\n" .
        "# stored are:\n" .
        "# CFLAGSF77     = [...]\n" .
        "# CFLAGSF90     = [...]\n" .
        "# CFLAGSC       = [...]\n" .
        "# CFLAGSCOPROC  = [...]\n" .
        "# CFLAGSCXX     = [...]\n" .
        "# CFLAGSCUDA    = [...]\n" .
        "# APPONLYFLAGS  = [...]\n" .
        "# INC           = [...]\n" .
        "# The output is similar to the corresponding lines of 'make id' output.\n" .
        "# Path information, however, needs to be removed from these settings.\n" .
        "# Otherwise, it would not be possible to share libraries among FEAT2\n" .
        "# applications as the settings above often contain absolute paths to\n" .
        "# object directories which would lead to conflicts, e.g.:\n" .
        "# CFLAGSF90    = [...] -moddir=/home/foo/nobackup/feastobj/fb2/src_disk/object\n" .
        "# CFLAGSF90    = [...] -moddir=/home/foo/nobackup/feastobj/fb2/src_poisson/object\n" .
        "define store-settings\n" .
        "    LC_ALL=C; \\\n" .
        "    if test -n \"\$(F77)\"; then \\\n" .
        "\t\$(F77VERSION) > \"\$(DIR)/\$(FILE_F77_INFO).version\"; \\\n" .
        "\tcompilerpath=\`which 2>/dev/null \$(F77)\`; \\\n" .
        "\tif test -f \"\$\${compilerpath}\" -o -L \"\$\${compilerpath}\"; then \\\n" .
        "\t    ls -lLd \$\${compilerpath} > \"\$(DIR)/\$(FILE_F77_INFO).ls\"; \\\n" .
        "\telse \\\n" .
        "\t    echo; echo \"Error: F77 compiler not found.\"; echo; \\\n" .
        "\t    rm -f \$(OBJDIR_LOCKFILE) \$(OBJDIR_LIB_LOCKFILE); \\\n" .
        "\t    exit 1; \\\n" .
        "\tfi; \\\n" .
        "    else \\\n" .
        "\techo; echo \"Error: F77 compiler not set.\"; echo; \\\n" .
        "\trm -f \$(OBJDIR_LOCKFILE) \$(OBJDIR_LIB_LOCKFILE); \\\n" .
        "\texit 1; \\\n" .
        "    fi; \\\n" .
        "    if test -n \"\$(F90)\"; then \\\n" .
        "\t\$(F90VERSION) > \"\$(DIR)/\$(FILE_F90_INFO).version\"; \\\n" .
        "\tcompilerpath=\`which 2>/dev/null \$(F90)\`; \\\n" .
        "\tif test -f \"\$\${compilerpath}\" -o -L \"\$\${compilerpath}\"; then \\\n" .
        "\t    ls -lLd \$\${compilerpath} > \"\$(DIR)/\$(FILE_F90_INFO).ls\"; \\\n" .
        "\telse \\\n" .
        "\t    echo; echo \"Error: F90 compiler not found.\"; echo; \\\n" .
        "\t    rm -f \$(OBJDIR_LOCKFILE) \$(OBJDIR_LIB_LOCKFILE); \\\n" .
        "\t    exit 1; \\\n" .
        "\tfi; \\\n" .
        "    else \\\n" .
        "\techo; echo \"Error: F90 compiler not set.\"; echo; \\\n" .
        "\trm -f \$(OBJDIR_LOCKFILE) \$(OBJDIR_LIB_LOCKFILE); \\\n" .
        "\texit 1; \\\n" .
        "    fi; \\\n" .
        "    if test -n \"\$(CC)\"; then \\\n" .
        "\t\$(CCVERSION) > \"\$(DIR)/\$(FILE_CC_INFO).version\"; \\\n" .
        "\tcompilerpath=\`which 2>/dev/null \$(CC)\`; \\\n" .
        "\tif test -f \"\$\${compilerpath}\" -o -L \"\$\${compilerpath}\"; then \\\n" .
        "\t    ls -lLd \$\${compilerpath} > \"\$(DIR)/\$(FILE_CC_INFO).ls\"; \\\n" .
        "\telse \\\n" .
        "\t    echo; echo \"Error: C compiler not found.\"; echo; \\\n" .
        "\t    rm -f \$(OBJDIR_LOCKFILE) \$(OBJDIR_LIB_LOCKFILE); \\\n" .
        "\t    exit 1; \\\n" .
        "\tfi; \\\n" .
        "    else \\\n" .
        "\techo; echo \"Error: C compiler not set.\"; echo; \\\n" .
        "\trm -f \$(OBJDIR_LOCKFILE) \$(OBJDIR_LIB_LOCKFILE); \\\n" .
        "\texit 1; \\\n" .
        "    fi; \\\n" .
        "    if test -n \"\$(CXX)\"; then \\\n" .
        "\t\$(CXXVERSION) > \"\$(DIR)/\$(FILE_CXX_INFO).version\"; \\\n" .
        "\tcompilerpath=\`which 2>/dev/null \$(CXX)\`; \\\n" .
        "\tif test -f \"\$\${compilerpath}\" -o -L \"\$\${compilerpath}\"; then \\\n" .
        "\t    ls -lLd \$\${compilerpath} > \"\$(DIR)/\$(FILE_CXX_INFO).ls\"; \\\n" .
        "\telse \\\n" .
        "\t    echo; echo \"Error: C++ compiler not found.\"; echo; \\\n" .
        "\t    rm -f \$(OBJDIR_LOCKFILE) \$(OBJDIR_LIB_LOCKFILE); \\\n" .
        "\t    exit 1; \\\n" .
        "\tfi; \\\n" .
        "    else \\\n" .
        "\techo; echo \"Error: C++ compiler not set.\"; echo; \\\n" .
        "\trm -f \$(OBJDIR_LOCKFILE) \$(OBJDIR_LIB_LOCKFILE); \\\n" .
        "\texit 1; \\\n" .
        "    fi; \\\n" .
        "    if test -n \"\$(CUDA)\"; then \\\n" .
        "\t\$(CUDAVERSION) > \"\$(DIR)/\$(FILE_CUDA_INFO).version\"; \\\n" .
        "\tcompilerpath=\`which 2>/dev/null \$(CUDA)\`; \\\n" .
        "\tif test -f \"\$\${compilerpath}\" -o -L \"\$\${compilerpath}\"; then \\\n" .
        "\t    ls -lLd \$\${compilerpath} > \"\$(DIR)/\$(FILE_CUDA_INFO).ls\"; \\\n" .
        "\telse \\\n" .
        "\t    echo; echo \"Error: CUDA compiler not found.\"; echo; \\\n" .
        "\t    rm -f \$(OBJDIR_LOCKFILE) \$(OBJDIR_LIB_LOCKFILE); \\\n" .
        "\t    exit 1; \\\n" .
        "\tfi; \\\n" .
        "    fi; \\\n" .
        "    (echo 'CFLAGSF77     =' \$(CFLAGSF77); \\\n" .
        "     echo 'CFLAGSF90     =' \$(CFLAGSF90); \\\n" .
        "     echo 'CFLAGSC       =' \$(CFLAGSC); \\\n" .
        "     echo 'CFLAGSCOPROC  =' \$(CFLAGSCOPROC); \\\n" .
        "     echo 'CFLAGSCXX     =' \$(CFLAGSCXX); \\\n" .
        "     echo 'CFLAGSCUDA    =' \$(CFLAGSCUDA); \\\n" .
        "     echo \$\${additionalflags}; \\\n" .
        "     echo 'INC           =' \$(INC); ) | \\\n" .
        "        sed -e \"s^-DENABLE_SERIAL_BUILD[ ]*^^g; \\\n" .
        "\t\ts^\$(OBJDIR)^<path information intentionally removed by make>^g; \\\n" .
        "\t\ts^\$(OBJDIR_LIB)^<path information intentionally removed by make>^g;\" \\\n" .
        "        > \$(DIR)/\$(COMPILER_SETTINGS); \\\n" .
        "    echo \"# Done.\"\n" .
        "endef\n\n" .

    # For slow file systems ensure that a directory to be created
    # actually has appeared before continuing.
        "# For slow file systems ensure that a directory to be created\n" .
        "# actually has appeared before continuing.\n" .
        "define wait-for-directory-to-appear\n" .
        "    echo; echo \"# Waiting till object directory <\$\${DIR}> appears...\"; \\\n" .
        "    while ! test -d \$\${DIR}; do sleep 1; done; \\\n" .
        "    echo \"# Object directory <\$\${DIR}> available. Continuing compilation...\"\n" .
        "\n" .
        "endef\n\n\n\n";


    ##############################################################################
    # Auxiliary targets
    print MAKEFILE_HDL
        "##############################################################################\n" .
        "# Auxiliary targets\n\n" .

    # Greeting
        "# Greeting\n" .
        ".PHONY: greeting\n" .
        "greeting:\n" .
        "\t\@echo \"# Building FEAT2.0 application <\$(APPNAME)>\"\n\n";

    # Test whether given ID (possibly hard-coded in top section or given
    # on command line) is valid
    print MAKEFILE_HDL
        "# Test whether given ID (possibly hard-coded in top section or given\n" .
        "# on command line) is valid\n" .
        ".PHONY: verify-id\n" .
        "verify-id:\n" .
        "ifneq (\$(strip \$(FORCE_ID)),YES)\n" .
        "ifeq (,\$(findstring \$(REALID_SHORT), \$(ID)))\n" .
        "\t\@echo; \\\n" .
        "\t echo '*** Error: Build ID \$(ID)'; \\\n" .
        "\t echo '***        is *not* valid for current host!'; \\\n" .
        "\t echo '***        \$(FEAT2BASEDIR)/bin/guess_id reported a host of type \$(REALID_SHORT).'; \\\n" .
        "\t echo '***        Cowardly refusing compilation.'; \\\n" .
        "\t echo;\n" .
	"\t\@exit 1;\n" .
        "endif\n" .
        "endif\n\n";

    print MAKEFILE_HDL
    # Create object directories
        "# Create object directories\n" .
        ".PHONY: \$(OBJDIR)\n" .
        "\$(OBJDIR):      | verify-id\n" .
        "ifneq (\$(MESSAGE),)\n" .
        "\t\@\$(MESSAGE)\n" .
        "endif\n" .
        "\t\@test -d \$(OBJDIR) || (rm -f \$(OBJDIR); mkdir -p \$(OBJDIR))\n" .
        "#\t\@DIR=\$(OBJDIR); \$(wait-for-directory-to-appear)\n\n" .
        "ifneq (\$(OBJDIR_LIB), \$(OBJDIR))\n" .
        ".PHONY: \$(OBJDIR_LIB)\n" .
        "\$(OBJDIR_LIB):  | verify-id \$(OBJDIR)\n" .
        "ifneq (\$(MESSAGE),)\n" .
        "\t\@\$(MESSAGE)\n" .
        "endif\n" .
        "\t\@test -d \$(OBJDIR_LIB) || (rm -f \$(OBJDIR_LIB); mkdir -p \$(OBJDIR_LIB))\n" .
        "#\t\@DIR=\$(OBJDIR_LIB); \$(wait-for-directory-to-appear)\n" .
        "endif\n\n" .

    # aliases for global targets .id / .idonly
        "# aliases for global target .id & .idonly\n" .
        "# show current build ID and all compile settings applied\n" .
        ".PHONY:\tid\n" .
        "id:\t.id\n\n" .
        "# show current build ID\n" .
        ".PHONY:\tidonly\n" .
        "idonly:   .idonly\n\n" .

    # print a list of all valid build IDs for current host
        "# print a list of all valid build IDs for current host\n" .
        ".PHONY:\tlistids list.ids list-ids\n" .
        "listids:\tlist-ids\n" .
        "list.ids:\tlist-ids\n" .
        "list-ids:\n" .
        "\t\@echo \"The following are valid (possibly partial) build IDs for current host:\"\n" .
        "# It would be a lot nicer if we could distribute the following perl\n" .
        "# command over several lines, but this breaks with GNU Make 3.81\n" .
        "# (though it works with GNU Make 3.80).\n" .
# orig  "\t\@perl -ne 'if (m/^ifeq \\(\\\$\$\\(call match,\\\$\$\\(ID\\),(.*)\\),yes\\)\\s*\$\$/) {   my \$\$string = \$\$1; if (\$\$string =~ m/^\$(ID)/) { print \"* \$\$string (default)\\n\"; } elsif (\$\$string =~ m/^\$(REALID)/) { print \"* \$\$string\\n\"; }   }' \\\n" .
	"\t\@LC_ALL=C perl -ne '(my \$\$id_1st3tokens = \"\$(REALID)\") =~ s/^([\\w\\.]+-[\\w\\.]+-[\\w\\.]+)-.*/\$\$1/; if (m/^ifeq \\(\\\$\$\\(call match,\\\$\$\\(ID\\),([^-]+-[^-]+-[^-]+)(-.*)\\),yes\\)\\s*\$\$/) { my \$\$completematch = \$\$1 . \$\$2; my \$\$match_1st3tokens = \$\$1; if (\$\$completematch =~ m/\$(REALID)/) { print \"* \$\$completematch (default)\\n\"; } elsif (\$\$id_1st3tokens =~ m/\$\$match_1st3tokens/) { print \"* \$\$completematch\\n\"; } }' \\\n" .
        "\t    \$(MAKEFILE_CPU_INC) | sort;\n" .
        "\t\@echo;\n" .
        "\t\@echo \"Default build ID for current host: \$(REALID)\";\n" .
	"ifneq (\$(ID), \$(REALID))\n" .
        "\t\@echo \"Forced build ID for current host: \$(ID)\";\n" .
	"endif\n\n" .


    # print a list of all valid build IDs
        "# print a list of all valid build IDs\n" .
        ".PHONY:\tlistallids list.all.ids list-all-ids\n" .
        "listallids:\tlist-all-ids\n" .
        "list.all.ids:\tlist-all-ids\n" .
        "list-all-ids:\n" .
        "\t\@echo \"The following are all valid (possibly partial) build IDs:\"\n" .
        "# It would be a lot nicer if we could distribute the following perl\n" .
        "# command over several lines, but this breaks with GNU Make 3.81\n" .
        "# (though it works with GNU Make 3.80).\n" .
        "\t\@LC_ALL=C perl -ne 'if (m/^ifeq \\(\\\$\$\\(call match,\\\$\$\\(ID\\),(.*)\\),yes\\)\\s*\$\$/) {   my \$\$string = \$\$1; if (\$\$string =~ m/^\$(REALID)/) { print \"* \$\$string (default)\\n\"; } else { print \"* \$\$string\\n\"; }   }' \\\n" .
        "\t    \$(MAKEFILE_CPU_INC) | sort;\n" .
        "\t\@echo;\n" .
        "\t\@echo \"Default build ID for current host: \$(REALID)\";\n" .
	"ifneq (\$(ID), \$(REALID))\n" .
        "\t\@echo \"Forced build ID for current host: \$(ID)\";\n" .
	"endif\n\n" .


    # create tag file for emacs users
	"# create tag file for emacs users\n" .
	".PHONY: tags\n" .
        "tags: \$(SRCF77) \$(SRCF90) \$(SRCEXTRA) \$(SRCEXTRA_APP)\n" .
        "\trm -f TAGS\n" .
        "\tctags -e --langmap=c++:+.cu --totals=yes \$(filter %.c %.cc %.cu %.f %.f90,\$^)\n\n" .


    # print help message
        "# print a help screen\n" .
        "help:\n" .
        "\t\@echo \"Usage: make [targets...]\"\n" .
        "\t\@echo \"\"\n" .
        "\t\@echo \"where targets include:\"\n" .
        "\t\@echo \"\"\n" .
        "\t\@echo \"  help           display this help\"\n" .
        "\t\@echo \"  all            compile application (default)\"\n" .
        "\t\@echo \"  debug          compile application without optimisation flags,\"\n" .
        "\t\@echo \"                   include debugging symbols\"\n" .
        "\t\@echo \"  getlibs        download all third party libraries currently missing\"\n" .
        "\t\@echo \"  libs           compile all libraries specified in variable BUILDLIB\"\n" .
        "\t\@echo \"                   (currently: \$(BUILDLIB))\"\n" .
        "\t\@echo \"  clean          remove all object files and libraries\"\n" .
        "\t\@echo \"  clean-app      remove only FEAT2 object files\"\n" .
        "\t\@echo \"  clean-libs     remove libraries and the object files they are built from\"\n" .
        "\t\@echo \"  purge          remove all object files and libraries for all build IDs\"\n" .
        "\t\@echo \"  purge-libs     remove libraries and the object files they are built from\"\n" .
        "\t\@echo \"                   for all build IDs\"\n" .
        "\t\@echo \"\"\n" .
        "\t\@echo \"Additional auxiliary targets include:\"\n" .
        "\t\@echo \"  idonly         show current build ID\"\n" .
        "\t\@echo \"  id             show current build ID and all compile settings\"\n" .
        "\t\@echo \"                   that would be applied during compilation\"\n" .
        "\t\@echo \"  list-ids       print a list of valid build IDs for current host\"\n" .
        "\t\@echo \"  list-all-ids   print a list of all valid build IDs\"\n" .
        "\t\@echo \"  <library>      compile only <library>, where <library> is one of\"\n" .
        "\t\@echo \"                   'agmg' - aggregation-based algebraic multigrid metho \"\n" .
        "\t\@echo \"                   'amd' - approximate minimum degree ordering\"\n" .
        "\t\@echo \"                   'blas' - basic linear algebra subprograms\"\n" .
        "\t\@echo \"                   'coproc' - co-processor support\"\n" .
        "\t\@echo \"                   'inshape2d' - NURBS-curves and surfaces \"\n" .
        "\t\@echo \"                   'lapack' - linear algebra package\"\n" .
        "\t\@echo \"                   'metis' - graph partitioning and fill-reduction matrix ordering \"\n" .
        "\t\@echo \"                   'splib' iterative methods and preconditioners\"\n" .
        "\t\@echo \"                   'umfpack' - unsymmetric multifrontal sparse LU factorization\"\n" .
        "\t\@echo \"  <object file>  compile <object file>, where <object file> is one of FEAT2's\"\n" .
        "\t\@echo \"                   object files. (The object directory can be omitted). Those\"\n" .
        "\t\@echo \"                   modules <object file> depends on will be built if necessary\"\n" .
        "\t\@echo \"  link           force re-linking (do not bother whether any module needs \"\n" .
        "\t\@echo \"                   recompilation due to dependencies and/or time stamps)\"\n" .
        "\t\@echo \"  delete FILE=<object file>\"\n" .
        "\t\@echo \"                 removes <object file> from current object directory;\"\n" .
        "\t\@echo \"                   no need to remember or know the name of that directory\"\n" .
        "\t\@echo \"\"\n" .
        "\t\@echo \"Makefile variables that you might consider overwriting on the command line include:\"\n" .
	"\t\@echo \"  AGMG=<YES|NO>\"\n" .
        "\t\@echo \"                 whether to add AGMG support to the application\"\n" .
        "\t\@echo \"  APPNAME=<string>\"\n" .
        "\t\@echo \"                 application name\"\n" .
	"\t\@echo \"  MODE=<PARALLEL|SERIAL> (deprecated, use MPI=<YES|NO>)\"\n" .
        "\t\@echo \"                 whether to build parallel or serial version of application\"\n" .
	"\t\@echo \"  MONITOR_COMPILE_ENV=<NO|YES>\"\n" .
        "\t\@echo \"                 whether or not $make should check path and modification dates\"\n" .
        "\t\@echo \"                   of compilers and compiler settings across multiple\"\n" .
        "\t\@echo \"                   compilation attempts\"\n" .
	"\t\@echo \"  MPI=<YES|NO>\"\n" .
        "\t\@echo \"                 whether to build a MPI or serial version of the application\"\n" .
	"\t\@echo \"  MPIWRAPPERS=<NO|YES>\"\n" .
        "\t\@echo \"                 whether or not to use MPI wrapper commands for compilation\"\n" .
        "\t\@echo \"  OPENMP=<YES|NO>\"\n" .
        "\t\@echo \"                 whether to add OpenMP support to the application\"\n" .
	"\t\@echo \"  OPT=<NO|YES|EXPENSIVE|NATIVE|NATIVE-EXPENSIVE>\"\n" .
        "\t\@echo \"                 whether to compile application without, with normal optimisation\"\n" .
        "\t\@echo \"                   or expensive optimisation flags and optionally auto-tuned for the\"\n" .
        "\t\@echo \"                   architecture of the build host. 'make OPT=NO' is equivalent to\"\n" .
        "\t\@echo \"                   'make debug'\"\n" .
	"\t\@echo \"  RELINK_ALWAYS=<NO|YES>\"\n" .
        "\t\@echo \"                 whether or not $make should relink an application every time it\"\n" .
        "\t\@echo \"                   is invoked regardless whether a source file has changed\"\n" .
        "\t\@echo \"\"\n" .
        "\n\n";

    # phony statements
    # For explanation see section 4.6 of GNU Make Manual,
    # http://www.gnu.org/software/make/manual/make.html#Phony-Targets
    print MAKEFILE_HDL
        "# For explanation see section 4.6 of GNU Make Manual,\n" .
        "# http://www.gnu.org/software/make/manual/make.html#Phony-Targets\n" .
        ".PHONY: all clean clean-app clean-libs debug default delete \\\n" .
        "\thelp libs link purge purge-libs\n\n" .
        "# Relink binary every time make is invoked?\n" .
        "ifeq (\$(strip \$(RELINK_ALWAYS)),YES)\n" .
        ".PHONY: \$(APPNAME)\n" .
        "endif\n\n";

    print MAKEFILE_HDL
    # Phony targets for all shortcuts
        "# Phony targets for all shortcuts\n" .
        ".PHONY: \$(BUILDLIB:%=clean-%) \$(BUILDLIB:%=purge-%)\n";

    close(MAKEFILE_HDL);
}



# Function: Creates "Meta" Makefile for benchmark, i.e. creates the Makefile
#           for the regression benchmark directory.
# Note: Main reason why this Makefile is dynamically created and not static
#       is that it needs to *always* return correct values for 'make idonly'.
#       Previous implementations with a static Makefile only reported correct
#       build IDs in case default build IDs were used.
sub create_feastBenchmarkMakefile {
    my $entry;

    print "creating $MAKEFILE.\n";
    open(MAKEFILE_HDL, ">" , $MAKEFILE) or die "$progname: ERROR: Cannot open file <$MAKEFILE> for writing: $!\n";
    print MAKEFILE_HDL
        "#!/usr/bin/env make\n" .
        "\n" .
	"########################################################################\n" .
	"#                                                                      #\n" .
	"#                   FINITE ELEMENT ANALYSIS TOOLS 2                    #\n" .
	"#                                                                      #\n" .
	"# Authors: M. Koester, M. Moeller, S. Turek, S. Buijssen               #\n" .
	"#                                                                      #\n" .
	"#                                                                      #\n" .
	"# Contact: Applied Mathematics, TU Dortmund University                 #\n" .
	"#          Vogelpothsweg 87, 44227 Dortmund                            #\n" .
	"#          Germany                                                     #\n" .
	"#                                                                      #\n" .
	"# Web:     http://www.featflow.de/en/software/featflow2.html           #\n" .
	"#          mailto:featflow\@featflow.de                                 #\n" .
	"#                                                                      #\n" .
	"########################################################################\n" .
        "#                                                                      #\n" .
        "# Makefile for FEAT2 regression benchmark                              #\n" .
        "# (auto-created by ./configure                                         #\n" .
        "#                                                                      #\n" .
        "########################################################################\n" .
        "\n" .
	"# Some variables\n\n";

    if (defined($cl{'ID'})) {
	print MAKEFILE_HDL
	    "# Fix a particular build ID, do not use the default one\n" .
	    "# (There are Makefile rules that will verify that the given build ID\n" .
	    "#  matches the architecture, cpu and operating system at make runtime.)\n" .
	    "ID                 := $cl{'ID'}\n\n";
    }

    print MAKEFILE_HDL
        "# Basename of all FEAT2 benchmark applications\n" .
        "APPBASE  = feat2benchmark\n" .
        "\n" .
        "# List of all applications to compile\n" .
        "APPS     = \$(patsubst kernel_%, \$(APPBASE)-%, \$(filter kernel_%, \$(SRCDIRS))) \\\n" .
        "\t   \$(patsubst apps_%,   \$(APPBASE)-%, \$(filter apps_%,   \$(SRCDIRS))) \\\n" .
        "\t   \$(patsubst area51_%, \$(APPBASE)-%, \$(filter area51_%, \$(SRCDIRS)))\n" .
        "\n" .
        "# List of all *.fbconf files (containing benchmark test IDs)\n" .
        "FBCONF   = \$(wildcard *.fbconf)\n" .
        "\n" .
        "# List of all *.fbdef files (containing benchmark test definitions)\n" .
        "FBDEF    = \$(wildcard tests/*.fbdef)\n" .
        "\n" .
        "# Path to this FEAT2 installation\n" .
        "FEAT2BASEDIR = ..\n" .
        "\n";

    $entry = (defined($cl{'BINARY'})) ? $cl{'BINARY'} : $defaults{'BINARY'};
    print MAKEFILE_HDL
        "# Binary type?\n" .
        "BINARY = $entry\n\n";

    $entry = (defined($cl{'INTSIZE'})) ? $cl{'INTSIZE'} : $defaults{'INTSIZE'};
    print MAKEFILE_HDL
        "# Size of integers?\n" .
        "INTSIZE = $entry\n\n";

    print MAKEFILE_HDL
	"# Name of log base directory\n" .
	"LOG_BASE_DIR = logs\n" .
	"\n" .
        "# Location of Makefile.buildID.inc\n" .
        "MAKEFILE_BUILDID_INC  = \$(FEAT2BASEDIR)/" . $MAKEFILE_BUILDID_INC . "\n" .
	"\n" .
        "# Location of Makefile.cpu.inc\n" .
        "MAKEFILE_CPU_INC      = \$(FEAT2BASEDIR)/" . $MAKEFILE_CPU_INC . "\n" .
        "\n";


    $entry = (defined($cl{'MPI'})) ? $cl{'MPI'} : $defaults{'MPI'};
    print MAKEFILE_HDL
        "# Create test suite to execute binaries with MPI support?\n" .
        "MPI = $entry\n\n";

    print MAKEFILE_HDL
        "# Name of FEAT2 benchmark control script\n" .
        "SCRIPT   = runtests\n" .
        "\n" .
        "# Fail-safe source directory (for 'compile-libs', 'idonly')\n" .
        "SRCDIR   = \$(firstword \$(SRCDIRS))\n" .
        "\n" .
        "# List of all application's source directories\n" .
        "SRCDIRS  = \$(patsubst %/, %, \$(dir \$(wildcard \\\n" .
        "\t\t\t\t\tkernel_*/$MAKEFILE \\\n" .
        "\t\t\t\t\tapps_*/$MAKEFILE \\\n" .
        "\t\t\t\t\tarea51_*/$MAKEFILE)))\n" .
        "\n" .
        "# All possible test IDs\n" .
        "TESTIDS  = \$(shell grep -i \"^testid\" \$(FBDEF) | cut -d= -f 2 | sed -e 's/ //g')\n" .
        "\n" .
        "# All possible test sets\n" .
        "TESTSETS = \$(FBCONF:%.fbconf=%)\n" .
        "\n" .
        "# Some targets only safely work if not called directly, but recursively\n" .
        "# from this Makefile\n" .
        "ifneq (\$(MAKELEVEL),0)\n" .
        "SUBMAKE = \"YES\"\n" .
        "endif\n" .
        "\n" .
        "\n" .
        "##############################################################################\n" .
        "# Import a default build ID setting in case no build ID has been set yet.\n" .
        "include \$(MAKEFILE_BUILDID_INC)\n\n" .
        "\n\n" .

        "##############################################################################\n" .
        "# The targets\n" .
        "\n" .
        "\n" .
        "##############################################################################\n" .
        "# Default target\n" .
        ".PHONY:\tall\n" .
        "all:\thelp\n" .
        "\n" .
        "\n" .

    ##############################################################################
    # Compiling
        "##############################################################################\n" .
        "# Compiling\n" .
        "\n" .
        "# Rules to compile every FEAT2 benchmark application\n" .
        "# (Ensure that the third-party libraries blas, lapack, metis, umfpack are\n" .
        "#  completely compiled *before* trying to compile any FEAT2 benchmark\n" .
        "#  application. For serial make it does not matter, but parallel make\n" .
        "#  would otherwise cause nothing but trouble as the libraries' object files\n" .
        "#  and the resulting archives are shared among all FEAT2 benchmark applications\n" .
        "#  in the same object directory. Within each FEAT2 benchmark application\n" .
        "#  subfolder a sub-make of a parallel make process would try to compile\n" .
        "#  the library to the same object file.)\n" .
        ".PHONY:\tbenchmark compile compile-libs compile-apps compile-META libs\n" .
        "compile:\tbenchmark\n" .
        "benchmark:\n" .
        "\t\@\$(MAKE) compile-libs\n" .
        "\t\@\$(MAKE) compile-apps\n" .
        "\n" .
        "libs:\tcompile-libs\n" .
        "compile-libs:\n" .
        "\t\@\$(MAKE) -C\$(SRCDIR) libs\n" .
        "\n" .
        "# Generic rule to build a specific library only\n" .
        ".PHONY:\tagmg amd blas coproc lapack libagmg.a libamd.a libblas.a libcoproc.a \\\n" .
        "\tliblapack.a libmetis.a libsplib.a libumfpack.a metis splib umfpack\n" .
        "agmg amd blas coproc lapack libagmg.a libamd.a libblas.a libcoproc.a \\\n" .
        "liblapack.a libmetis.a libsplib.a libumfpack.a metis splib umfpack:\n" .
        "\t\@\$(MAKE) -C\$(SRCDIR) \$\@\n" .
        "\n" .
        "compile-apps:\t\$(foreach APP, \$(APPS), \$(APP) )\n" .
        "\n" .
        "# Compile a single FEAT2 benchmark application\n" .
        "# (Tricky part is reconstructing source directory name from application name.)\n" .
        "# (Make apps phony targets otherwise switching build ID does not necessarily\n" .
        "#  lead to a re-compilation)\n" .
        ".PHONY:\t\$(APPS)\n" .
        "\$(APPS): compile-libs\n" .
        "\t\@\$(MAKE) APPNAME=\$\@ \\\n" .
        "\t\t SRCDIR=\$(filter \$(\@:\$(APPBASE)-%=kernel_%) \\\n" .
        "\t\t\t\t \$(\@:\$(APPBASE)-%=apps_%) \\\n" .
        "\t\t\t\t \$(\@:\$(APPBASE)-%=area51_%), \$(SRCDIRS)) compile-META\n" .
        "\n" .
        "# Compile a FEAT2 benchmark application\n" .
        "compile-META:\n" .
        "\t\@echo \"# Compiling FEAT2 benchmark application \$(APP)...\"\n" .
        "\t\@( \$(MAKE) -C\$(SRCDIR) APPNAME=../\$(APPNAME) )\n" .
        "\t\@echo \"# FEAT2 benchmark application \$(APPNAME) successfully compiled.\"\n" .
        "\n" .
        "\n" .
        "# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\n" .
        "\n" .
        "# Compile all FEAT2 benchmark applications forcing no optimisation\n" .
        "# (to speed up things) and with per build ID unique application\n" .
        "# names. This way, we can check on all our test platforms whether the\n" .
        "# code still compiles before contributing new revisions to CVS. The\n" .
        "# unique names allow for parallel compilation (in the same directory!).\n" .
        ".PHONY:\ttest-compile test-compile-apps \$(APPS:%=test-compile-%)\n" .
        "test-compile:\tOPT=NO\n" .
        "test-compile:\n" .
        "#\t\@\$(MAKE) compile-libs\n" .
        "\t\@\$(MAKE) test-compile-apps\n" .
        "\n" .
        "test-compile-apps:\t\$(foreach APP, \$(APPS), test-compile-\$(APP) )\n" .
        "\n" .
        "# Compile a single FEAT2 benchmark application\n" .
        "# (Tricky part is reconstructing source directory name from application name.)\n" .
        "\$(APPS:%=test-compile-%):\n" .
        "\t\@\$(MAKE) APPNAME=\$(\@:test-compile-%=\$(ID)-%) \\\n" .
        "\t\t SRCDIR=\$(filter \$(\@:test-compile-\$(APPBASE)-%=kernel_%) \\\n" .
        "\t\t\t\t \$(\@:test-compile-\$(APPBASE)-%=apps_%) \\\n" .
        "\t\t\t\t \$(\@:test-compile-\$(APPBASE)-%=area51_%), \$(SRCDIRS)) compile-META\n" .
        "\n" .
        "\n" .

     ##############################################################################
     # Creating control scripts (for all tests, daily tests, single tests, in short
     # for every *.fbconf file found in the current directory)
        "##############################################################################\n" .
        "# Creating control scripts (for all tests, daily tests, single tests, in short\n" .
        "# for every *.fbconf file found in the current directory)\n" .
        "\n" .

        "# Dynamic targets: all test IDs\n" .
	"TEMPORARY_RUN_SCRIPT=_tmp_.fbconf\n" .
	".PHONY: clear-temporary-run-script\n" .
	"clear-temporary-run-script:\n" .
	"\t\@-rm -f \$(TEMPORARY_RUN_SCRIPT)\n\n" .

	".PHONY: \$(TESTIDS)\n" .
	"\$(TESTIDS): | clear-temporary-run-script\n" .
        "\$(TESTIDS):\n" .
	"        # By means of the dependency-only target clear-temporary-run-script and\n" .
	"        # the append operator '>>' it becomes feasible to specify multiple test\n" .
	"        # IDs subsequently on the command line - just as is the case with the\n" .
	"        # schedule scripts for queueing systems bin/lido_schedule_tests and\n" .
	"        # bin/nec_schedule_tests. Example:\n" .
	"        #  make AUTOPART0020 AUTOPART0021 BC0001 BC0003 NAVSTO-SOL11-0002 run\n" .
        "\t\@echo \$\@ >> \$(TEMPORARY_RUN_SCRIPT)\n" .
        "\t\@\$(MAKE) TESTCASES=\$(TEMPORARY_RUN_SCRIPT) create-script\n\n" .

        "# Create script which contains all the necessary information to run\n" .
        "# and validate all the test cases contained in a accordingly named\n" .
        "# *.fbconf file.\n" .
        ".PHONY:\t\$(TESTSETS) create-script\n" .
        "\$(TESTSETS):\n" .
        "\t\@\$(MAKE) TESTCASES=\$\@.fbconf create-script\n" .
        "\n" .
        "# Create a sh script which contains all the necessary information to run\n" .
        "# and validate all the test cases contained in tests/\$(TESTCASES).\n" .
	".PHONY: create-script\n" .
	"create-script:\n" .
        "\t\@echo \"# Creating script to perform test whose IDs are coded in <\$(TESTCASES)>\"\n" .
        "\t\@\$(MAKE) create-script-header\n" .
        "\t\@\$(MAKE) create-script-body\n" .
	"\n" .
	".PHONY: create-script-header\n" .
	"create-script-header:  COMPILERVERSION=\n" .
	"create-script-header:  DEBUGGER=0\n" .
	"create-script-header:  KEEPGOING=0\n" .
	"create-script-header:  MPIENV=\n" .
	"create-script-header:  OVERWRITE_LOG_DIRECTORY=\n" .
	"create-script-header:  SUPPRESSOUTPUT=1\n" .
	"create-script-header:	include/runtests.template\n" .
	"        # Include script template, applying defaults settings or overriding\n" .
	"        # them with command line given settings:\n" .
	"        # If SUPPRESSOUTPUT is specified on command line, its value is used,\n" .
	"        # otherwise SUPPRESSOUTPUT keeps default value defined in this Makefile\n" .
	"        # target's variable definition section.\n" .
	"        # The same mechanism applies to DEBUGGER and MPIENV.\n" .
	"\t\@cat include/runtests.template | \\\n" .
        "\t\tsed -e \"s/^COMPILERVERSION=<SET_VIA_MAKEFILE>/COMPILERVERSION=\$(COMPILERVERSION)/; \\\n" .
        "\t\t\ts/^DEBUGGER=<SET_VIA_MAKEFILE>/DEBUGGER=\$(DEBUGGER)/; \\\n" .
        "\t\t\ts/^KEEPGOING=<SET_VIA_MAKEFILE>/KEEPGOING=\$(KEEPGOING)/; \\\n" .
        "\t\t\ts/^MPIENV=<SET_VIA_MAKEFILE>/MPIENV=\$(MPIENV)/; \\\n" .
        "\t\t\ts/^SUPPRESSOUTPUT=<SET_VIA_MAKEFILE>/SUPPRESSOUTPUT=\$(SUPPRESSOUTPUT)/;\" > \$(SCRIPT)\n".
	"\n" .
	"        # Determine build ID\n" .
        "\t\@echo \"BUILDID=\$(LIBID)\" >> \$(SCRIPT);\n" .
        "\t\@echo >> \$(SCRIPT);\n" .
	"\n" .
	"        # Applications are named according the scheme:\n" .
	"        #   <APPL_BASENAME>-<application>\n" .
        "        # where <application> is both found \n" .
        "        # * in {kernel,apps,area51}_<application> and \n" .
        "        # * as value of the keyword 'appl' in a *.fbdef file in subdirectory 'tests'.\n" .
	"        #\n" .
	"        # Define <APPL_BASENAME>\n" .
        "\t\@(echo \"APPL_BASENAME=\"\$(APPBASE); echo) >> \$(SCRIPT)\n" .
	"\n" .
	".PHONY: create-script-body\n" .
	"create-script-body:\n" .
	"        # Create detailed instructions for each test in \$(TESTCASES)\n" .
        "\t\@ID=\$(LIBID) LOG_BASE_DIRECTORY=\$(LOG_BASE_DIR) MPI=\$(MPI) OVERWRITE_LOG_DIRECTORY=\$(OVERWRITE_LOG_DIRECTORY) include/create_script.pl \$(TESTCASES) >> \$(SCRIPT)\n" .
	"\n" .
	"        # Call footer function\n" .
        "\t\@( echo; echo fb_footer; echo; ) >> \$(SCRIPT)\n" .
	"\n" .
	"        # Give script executable permissions\n" .
        "\t\@chmod a+x \$(SCRIPT)\n" .
        "\t\@echo \"# Script named <\$(SCRIPT)> has been created.\"\n" .
        "\n" .
        "\n" .
        "##############################################################################\n" .
        "# Start FEAT2 benchmark application\n" .
        "\n" .
        ".PHONY:\trun\n" .
        "run:\n" .
	"\t\@-rm -f \$(TEMPORARY_RUN_SCRIPT)\n" .
        "\t\@./\$(SCRIPT)\n" .
        "\n" .
        "\n" .

     ##############################################################################
     # Cleaning up things
        "##############################################################################\n" .
        "# Cleaning up things\n" .
        "\n" .
        "# Clean up FEAT2 output and auxiliary files for the FEAT2 benchmark,\n" .
        "# clean up all FEAT2 benchmark applications, libraries and object files\n" .
        "# for current build ID.\n" .
        ".PHONY:\tclean\n" .
        "clean:\n" .
        "ifneq (\$(APPS),)\n" .
        "\t-rm -f \$(APPS)\n" .
        "endif\n" .
        "\t-rm -f \$(SCRIPT)\n" .
        "ifneq (\$(SRCDIRS),)\n" .
        "         # the following removes binaries created by test-compile (simultaneous \n" .
        "         # compilation in one checkout with several build IDs) \n" .
        "\t-rm -f \$(patsubst kernel_%, \$(ID)-\$(APPBASE)-%, \$(filter kernel_%, \$(SRCDIRS))) \\\n" .
        "\t       \$(patsubst apps_%,   \$(ID)-\$(APPBASE)-%, \$(filter apps_%,   \$(SRCDIRS))) \\\n" .
        "\t       \$(patsubst area51_%, \$(ID)-\$(APPBASE)-%, \$(filter area51_%, \$(SRCDIRS)))\n" .
        "endif\n" .
        "ifneq (\$(SRCDIR),)\n" .
        "ifeq \"\$(origin SRCDIR)\" \"command line\"\n" .
        "\t\@\$(MAKE) -C\$(SRCDIR) \$\@\n" .
        "else\n" .
	"\t\@\$(MAKE) -C\$(SRCDIR) clean-libs\n" .
        "\t\@\$(foreach dir, \$(SRCDIRS), ( \$(MAKE) -C\$(dir) clean-app ); )\n" .
        "endif\n" .
        "endif\n\n" .
        "# Clean up all FEAT2 object files for all applications for current architecture\n" .
        ".PHONY:\tclean-apps clean-app clean-libs purge\n" .
        "clean-apps: clean-app\n\n" .
        "# Clean up targets for all applications for current architecture\n" .
        "clean-app:\n" .
        "ifneq (\$(SRCDIR),)\n" .
        "ifeq \"\$(origin SRCDIR)\" \"command line\"\n" .
        "\t\@\$(MAKE) -C\$(SRCDIR) \$\@\n" .
        "else\n" .
        "\t\@\$(foreach dir, \$(SRCDIRS), ( \$(MAKE) -C\$(dir) \$\@ ); )\n" .
        "endif\n" .
        "endif\n\n" .
        "clean-libs:\n" .
        "ifneq (\$(SRCDIR),)\n" .
        "ifeq \"\$(origin SRCDIR)\" \"command line\"\n" .
        "\t\@\$(MAKE) -C\$(SRCDIR) \$\@\n" .
        "else\n" .
	"\t\@\$(MAKE) -C\$(SRCDIR) clean-libs\n" .
        "endif\n" .
        "endif\n\n" .
        "# Clean up FEAT2 output and auxiliary files for the FEAT2 benchmark,\n" .
        "# clean up all FEAT2 benchmark applications, libraries and object files\n" .
        "# for all build IDs.\n" .
        "purge:\tclean\n" .
        "ifneq (\$(SRCDIR),)\n" .
        "\t\@\$(MAKE) -C\$(SRCDIR) purge-libs\n" .
        "endif\n" .
        "ifneq (\$(SRCDIRS),)\n" .
        "\t\@\$(foreach dir, \$(SRCDIRS), ( \$(MAKE) -C\$(dir) purge-app ); )\n" .
        "\t\@-\$(foreach dir, \$(SRCDIRS), rm \$(dir)/$MAKEFILE \$(dir)/$MAKEFILE.bak; )\n" .
        "endif\n" .
        "\trm -f $MAKEFILE $MAKEFILE.bak\n" .
        "\n\n\n" .


    ##############################################################################
    # Auxiliary targets
        "##############################################################################\n" .
        "# Auxiliary targets\n\n" .

    # easter eggs
        "# easter egg support for common typos\n" .
        ".PHONY:\truin\n" .
        "ruin:\n" .
        "\t\@echo \"make ruin? Well, that's appalling of you to ask for!\"\n" .
        "\t\@echo \"I am dismayed!\"\n" .
        "\t\@echo\n" .
        "\t\@echo \"It took years to develop FEAT2 and to come up with its\"\n" .
        "\t\@echo \"current state. Now, you are deliberately asking for dis-\"\n" .
        "\t\@echo \"ruptive actions to be undertaken to turn your working copy\"\n" .
        "\t\@echo \"of FEAT2 into a state of partial or complete disrepair.\"\n" .
        "\t\@echo\n" .
        "\t\@echo \"I'm not going to support 'make ruin'! Bye.     :-)\"\n" .
        "\t\@echo\n" .
        "\t\@exit 1\n\n" .
        ".PHONY:\tdi iid idolny urn rnu comple complie copmile copmpile compiel .typo\n" .
        "di:       .typo\n" .
        "iid:      .typo\n" .
        "idolny:   .typo\n" .
        "urn:      .typo\n" .
        "rnu:      .typo\n" .
        "comple:   .typo\n" .
        "complie:  .typo\n" .
        "copmile:  .typo\n" .
        "copmpile: .typo\n" .
        "compiel:  .typo\n" .
        ".typo:\n" .
        "\t\@echo \"What?\"\n" .
        "\t\@exit 1\n" .
        "\n\n" .

    # id
        "# show current build ID and all compile settings applied.\n" .
        "# These two targets are merely aliases for global target .id & .idonly\n" .
        ".PHONY:\tid\n" .
        "id:\n" .
        "\t\@\$(foreach dir, \$(SRCDIRS), \\\n" .
        "\t\tprintf \"# ===\"; \\\n" .
        "\t\tlength=`echo \${dir} | wc -c`; i=\$\${length}; \\\n" .
        "\t\twhile [ \$\${i} -ge 0 ]; do printf \"=\"; i=`expr \$\${i} - 1`; done; \\\n" .
        "\t\tprintf \"===\\n\"; \\\n" .
        "\t\tprintf \"# === %s ===\\n\" \${dir}; \\\n" .
        "\t\tprintf \"# ===\"; \\\n" .
        "\t\ti=\$\${length}; \\\n" .
        "\t\twhile [ \$\${i} -ge 0 ]; do printf \"=\"; i=`expr \$\${i} - 1`; done; \\\n" .
        "\t\tprintf \"===\\n\"; \\\n" .
        "\t\tmake --no-print-directory -C '\${dir}' id; \\\n" .
        "\t\techo; echo; )\n" .
        "\n\n" .

    # idonly
        "# aliases for global target .idonly\n" .
        "# show current build ID\n" .
        ".PHONY:\tidonly\n" .
        "idonly:   .idonly\n\n" .


    # print a list of all valid build IDs for current host
        "# print a list of all valid build IDs for current host\n" .
        ".PHONY:\tlistids list.ids list-ids\n" .
        "listids:\tlist-ids\n" .
        "list.ids:\tlist-ids\n" .
        "list-ids:\n" .
        "\t\@echo \"The following are valid build IDs for current host:\"\n" .
        "# It would be a lot nicer if we could distribute the following perl\n" .
        "# command over several lines, but this breaks with GNU Make 3.81\n" .
        "# (though it works with GNU Make 3.80).\n" .
# orig  "\t\@perl -ne 'if (m/^ifeq \\(\\\$\$\\(call match,\\\$\$\\(ID\\),(.*)\\),yes\\)\\s*\$\$/) {   my \$\$string = \$\$1; if (\$\$string =~ m/^\$(ID)/) { print \"* \$\$string (default)\\n\"; } elsif (\$\$string =~ m/^\$(REALID)/) { print \"* \$\$string\\n\"; }   }' \\\n" .
	"\t\@LC_ALL=C perl -ne '(my \$\$id_1st3tokens = \"\$(ID)\") =~ s/^([\\w\\.]+-[\\w\\.]+-[\\w\\.]+)-.*/\$\$1/; if (m/^ifeq \\(\\\$\$\\(call match,\\\$\$\\(ID\\),([^-]+-[^-]+-[^-]+)(-.*)\\),yes\\)\\s*\$\$/) { my \$\$completematch = \$\$1 . \$\$2; my \$\$match_1st3tokens = \$\$1; if (\$\$completematch =~ m/\$(ID)/) { print \"* \$\$completematch (default)\\n\"; } elsif (\$\$id_1st3tokens =~ m/\$\$match_1st3tokens/) { print \"* \$\$completematch\\n\"; } }' \\\n" .
        "\t    \$(MAKEFILE_CPU_INC) | sort;\n" .
        "\t\@echo;\n" .
        "\t\@echo \"Default build ID for current host: \$(REALID)\";\n" .
	"ifneq (\$(ID), \$(REALID))\n" .
        "\t\@echo \"Forced build ID for current host: \$(ID)\";\n" .
	"endif\n\n" .


    # print a list of all valid build IDs
        "# print a list of all valid build IDs\n" .
        ".PHONY:\tlistallids list.all.ids list-all-ids\n" .
        "listallids:\tlist-all-ids\n" .
        "list.all.ids:\tlist-all-ids\n" .
        "list-all-ids:\n" .
        "\t\@echo \"The following are all valid build IDs:\"\n" .
        "# It would be a lot nicer if we could distribute the following perl\n" .
        "# command over several lines, but this breaks with GNU Make 3.81\n" .
        "# (though it works with GNU Make 3.80).\n" .
        "\t\@LC_ALL=C perl -ne 'if (m/^ifeq \\(\\\$\$\\(call match,\\\$\$\\(ID\\),(.*)\\),yes\\)\\s*\$\$/) {   my \$\$string = \$\$1; if (\$\$string =~ m/^\$(ID)/) { print \"* \$\$string (default)\\n\"; } else { print \"* \$\$string\\n\"; }   }' \\\n" .
        "\t    \$(MAKEFILE_CPU_INC) | sort;\n" .
        "\t\@echo;\n" .
        "\t\@echo \"Default build ID for current host: \$(REALID)\";\n" .
	"ifneq (\$(ID), \$(REALID))\n" .
        "\t\@echo \"Forced build ID for current host: \$(ID)\";\n" .
	"endif\n\n" .


    # Support a query for the log directory setting to have exactly one
    # position in the benchmark system where the log directory is stored.
        "# Support a query for the log directory setting to have exactly one\n" .
        "# position in the benchmark system where the log directory is stored.\n" .
        ".PHONY:	printbaselogdir print.base.log.dir print-base-log-dir\n" .
        "printbaselogdir:	print-base-log-dir\n" .
        "print.base.log.dir:	print-base-log-dir\n" .
        "print-base-log-dir:\n" .
        "\t\@echo \$(LOG_BASE_DIR)\n\n" .


    # print help message
        "# print a help screen\n" .
        ".PHONY:\thelp\n" .
        "help:\n" .
        "\t\@echo \"Usage: make [targets...]\"\n" .
        "\t\@echo\n" .
        "\t\@echo \"where targets include:\"\n" .
        "\t\@echo\n" .
        "\t\@echo \"  help           display this help\"\n" .
        "\t\@echo \"  clean          remove FEAT2 output and auxiliary files for all benchmark\"\n" .
        "\t\@echo \"                 applications.\"\n" .
        "\t\@echo\n" .
        "\t\@echo \"  benchmark      compile all benchmark applications\"\n" .
        "\t\@echo \"  test-compile   compile all benchmark applications without optimisation\"\n" .
        "\t\@echo \"                 and with per build ID unique application names\"\n" .
        "\t\@echo \"                 (Purpose: quick check whether code still compiles before\"\n" .
        "\t\@echo \"                  contributing new revisions. Test compilation can be done\"\n" .
        "\t\@echo \"                  in parallel (!) on all test build IDs.)\"\n" .
        "\t\@echo \"  run            run benchmark application\"\n" .
        "\t\@echo\n" .
        "\t\@echo \"Generic targets:\"\n" .
        "\t\@echo \"  \$(APPBASE)-<application>\"\n" .
        "\t\@echo \"                 compile a single benchmark application only.\"\n" .
        "\t\@echo \"                   For the current FEAT2 installation valid targets are:\"\n" .
        "\t\@echo \$(APPS) | fold -s -w 60 | sed 's/ /, /g; s/^/                   /;'\n" .
        "\t\@echo \"                 compile a single benchmark application only. Valid targets\"\n" .
        "\t\@echo \"  <name>         create script to run all tests defined in file <name>.fbconf.\"\n" .
        "\t\@echo \"                   For the current FEAT2 installation <name> can be any of:\"\n" .
        "\t\@echo \$(TESTSETS) | fold -s -w 50 | sed 's/ /, /g; s/^/                   /;'\n" .
        "\t\@echo\n" .
        "\t\@echo \"Additional auxiliary targets include:\"\n" .
        "\t\@echo \"  idonly         show current build ID\"\n" .
        "\t\@echo \"  id             show current build ID and all compile settings applied\"\n" .
        "\t\@echo \"  list.ids\"\n" .
        "\t\@echo \"  list-ids\"\n" .
        "\t\@echo \"  listids        print a list of valid build IDs for current host\"\n" .
        "\t\@echo \"  list.all.ids\"\n" .
        "\t\@echo \"  list-all-ids\"\n" .
        "\t\@echo \"  listallids     print a list of all valid build IDs\"\n" .
        "\t\@echo\n" .
        "\n";

    close(MAKEFILE_HDL);

#    die "\n$progname: ERROR:\n".
#        "Creation of regression benchmark Makefile is currently unsupported.\n";
}



# Function: Concatenates the arguments to a path
sub concat_filename {
    my (@args) = (@_);
    my $i = 0;
    my $result = "";

    # Strip off empty arguments from argument list
    for (my $i = 0; $i <= $#args; $i++) {
        if ($args[$i] =~ m/^\s*$/) {
            splice(@args, $i, 1);
            $i--;
        }
    }

    # Concatenate the remaining arguments
    $result = $args[0];
    for (my $i = 1; $i <= $#args; $i++) {
        $result = File::Spec->catfile($result, $args[$i]);
    }

    return $result;
}



# Function which prints the parsed command line options to screen
sub debug_command_line_options {
    my $string = "";

    my $colwidth = 0;
    foreach my $entry ('AGMG', 'APPNAME', 'APPONLYFLAGS', 'AR', 'BINARY', 'BUILDLIB', 'CC', 'CFLAGSC',
		       'CFLAGSCOPROC', 'CFLAGSCXX', 'CFLAGSF77', 'CFLAGSF90', 'CFLAGSCUDA',
		       'COPROCLIST', 'CPP', 'CUDA', 'CXX', 'F77', 'F90', 'FORCE_ID',
		       'HEADER_FILES_TO_COPY', 'ID', 'INC',
                       'INTSIZE', 'LD', 'LDFLAGS', 'LIBDIR', 'LIBS', 'MODEXTENSION',
                       'MOVEMOD', 'MPI', 'MPIINC', 'MPILIBDIR', 'MPILIBS', 'MPIWRAPPERS', 'OPENMP',
                       'OPT', 'RANLIB', 'RELINK_ALWAYS', 'SRCEXTRA', 'SRCEXTRA_APP', 'SRCLIST_APP', 'WARN') {
	$colwidth = &max(length($entry), $colwidth);
    }
    $colwidth++;

    foreach my $entry ('AGMG', 'APPNAME', 'APPONLYFLAGS', 'AR', 'BINARY', 'BUILDLIB', 'CC', 'CFLAGSC',
		       'CFLAGSCOPROC', 'CFLAGSCXX', 'CFLAGSF77', 'CFLAGSF90', 'CFLAGSCUDA',
		       'COPROCLIST', 'CPP', 'CUDA', 'CXX', 'F77', 'F90', 'FORCE_ID',
		       'HEADER_FILES_TO_COPY', 'ID', 'INC',
                       'INTSIZE', 'LD', 'LDFLAGS', 'LIBDIR', 'LIBS', 'MODEXTENSION',
                       'MOVEMOD', 'MPI', 'MPIINC', 'MPILIBDIR', 'MPILIBS', 'MPIWRAPPERS', 'OPENMP',
                       'OPT', 'RANLIB', 'RELINK_ALWAYS', 'SRCEXTRA', 'SRCEXTRA_APP', 'SRCLIST_APP', 'WARN') {
	# Determine type of variable: scalar or array
	if (ref($cl{$entry}) eq "") {
	    # current token is a scalar value, print if not empty
	    next unless (defined($cl{$entry}));

	    $string .= $entry . " "x($colwidth-length($entry)) . "= " . $cl{$entry} . "\n";
	} elsif (ref($cl{$entry}) eq "ARRAY") {
	    # current token is an array, print if at least one entry

	    # $cl{'...'} has been passed as an array to GetOptions()
	    # and as such is always defined. But is does not necessarily have
	    # entries: unset => #entries=-1; set, but empty => #entries=0
	    # So, don't test with perl function defined(). Test whether set.
	    next unless ($#{ $cl{$entry} } > -1);

	    $string .= $entry . " "x($colwidth-length($entry)) . "= " . join(' ', @{ $cl{$entry} }) . "\n";
	}
    }

    if ($string ne "") {
	print "These Makefile variables have been explicitly overridden by command line\n" .
	      "options. Their values will take precedence over the default settings made\n" .
	      "in kernel/arch/Makefile.inc and the template files kernel/arch/templates/*.mk:\n" .
	      $string . "\n";
    }

    return;
}



# Function which splits up a given file list over several lines,
# with word wrap at column $max and an indent of $indent spaces.
# Returns that string.
sub format_list {
    my ($target, $indent, $max, $filelist, $firstseparator, $separator) = (@_);
    my $line      = $target;
    my $string    = "";
    my $entriesInCurrLine = 0;
    my $DepsTotal = 0;

    foreach my $entry (split(/\s+/, $filelist)) {
        # Ignore empty list entries
        next if ($entry =~ m/^\s*$/);

        # The first entry sometimes should start a new line
        # Use value of $firstseparator for this.
        if ($DepsTotal == 0) {
            $line .= $firstseparator;
            if ($firstseparator =~ m/\n/) {
                $string .= $line;
                $entriesInCurrLine = 0;
                $line = (" " x ($indent-1));
            }
        }

        # Add entry to current line if maximum column number
        # has not been reached yet
        if (length($line . $entry) < $max  ||  $entriesInCurrLine == 0) {
            $line .= " " unless ($line eq "");
            $line .= $entry;
            $entriesInCurrLine++;
        } else {
            $line   .= " " . $separator . "\n";
            $string .= $line;
            $line    = (" " x ($indent)) . $entry;
            $entriesInCurrLine = 1;
        }
        $DepsTotal++;
    }
    $string .= $line;

    return $string;
}



# Function: Determine build ID (do not check yet whether it's valid)
sub get_buildID {
    # Skip this test for a benchmark application configure run
    # as then this test has already been performed by a directly
    # preceding call of this script)
    if (defined($cachedtests{'build-id'})) {
        # sub-configure calls when configuring regression benchmark
        # applications can skip the test as it has already been
        # performed earlier.
        print "using given build ID... ";
        print $cachedtests{'build-id'} . " (cached)\n";
        $buildID = $cachedtests{'build-id'};

    } else {
	# Otherwise take default build id from MAKEFILE_INC for guessed platform
	print "retrieving default build ID... ";

	# Pass along the desired execution mode of the application.
	# If set to parallel mode, the build ID contains an additional 6th token
	# naming the MPI library.
	my $mpi = (defined($cl{'MPI'})) ? $cl{'MPI'} : $defaults{'MPI'};

	# Use '--no-print-directory' to ensure that when this configure script
	# is run from a Makefile, make will not print lines like
	# make[?]: Entering directory `<some dirs>/feast/feast/<some other dirs>'
	# See section 5.6.4 of GNU Make Manual,
	# http://www.gnu.org/software/make/manual/html_mono/make.html#IDX250
	my $command = "cd \"" . &dirname(&concat_filename($FEAT2BASEDIR, $MAKEFILE_BUILDID_INC)) .
                      "\" && $make --no-print-directory -f " . &basename($MAKEFILE_BUILDID_INC) .
                      " MPI=$mpi FEAT2BASEDIR=. .idonly";
	$buildID = `$command`;
	chomp($buildID);
	$defaultBuildID = $buildID;

        # Use build id string from command line if specified or environment
        if (defined($cl{'ID'}) && $cl{'ID'} !~ m/^\s*$/) {
            print "done\nusing given build ID... ";
            $buildID = $cl{'ID'};
        } elsif (defined($ENV{ID})) {
            print "done\nusing given build ID... ";
            $cl{'ID'} = $ENV{ID};
            $buildID  = $ENV{ID};
        }

        print $buildID . "\n";
    }

    return $buildID;
}



# Function: Determine build ID for libraries (do not check yet whether it's valid)
sub get_buildID_lib {
    my $string = $buildID;
    $string =~ s/^([^-]+-[^-]+-[^-]+-[^-]+-[^-]+)(-[^-]+|)$/$1/;
    return $string;
}



# Function which parses a given file for Fortran 90-style 'use' statements,
# Fortran 90-style 'include' and CPP-style '#include' statements.
# Returns a list of all modules and include files that given file depends on.
sub get_dependency {
    my ($file) = (@_);
    my @dependencies = ();
    my $line = "";
    my $aux;

#    open (INFILE, "<:utf8", $file) or die "$progname: Cannot open file <$file> for reading: $!\n";
    open (INFILE, "<", $file) or
	die "\n$progname: ERROR:\n".
	    "Cannot open file <$file> for reading: $!\n";

    # Loop through file line by line
    LINE: while (defined($line = <INFILE>)) {
        # Remove comments
        $line =~ s/\!.*$//;
        $line =~ s/^[Cc].*$//;

        # Parse for "use foobar" statements
        # and add the module to the list (with keyword prefix 'module:')
        if ($line =~ m/^\s*use\s+(\w+)/i) {
            $aux = $1;
            # Check whether current module  is already on the list
            push @dependencies, "module:$1"
                unless (join(' ', @dependencies) =~ m/\bmodule:$aux\b/);
        }

        # Parse for C Preprocessor and Fortran includes:
        # i.e. parse for "include '...'", "include "..."" and  "include <...>"
        # and add the include file to the list (with keyword prefix 'include:')
        if ($line =~ m/^[#\s]*include\s+['"](\S+)['"]/) { #" (comment only to fix syntax highlighting)
            $aux = $1;

            # Check whether current include file is already on the list
            push @dependencies, "include:$aux"
                unless ((join(' ', @dependencies) =~ m/\binclude:$aux\b/) or
                        (DO_NOT_INCLUDE =~ m/\b$aux\b/));
        }

        next LINE;
    }
    close(INFILE);

    return @dependencies;
}



# Function which determines the base directory of the FEAT2 installation
# from the string given as argument (which is supposed to be the invocation
# path of this script).
sub get_feast_basedir() {
    my ($string) = (@_);

    my $path = &dirname($string);

    # FEAT2 base dir is one directory higher than the directory bin/
    # where this script should be located.
    $path .= "/..";

    # Strip 'bin/..' at the end of the string
#    $path =~ s/bin\/\.\.$//;

    # Remove any occurrences of './' and trailing slashes
#    $path = File::Spec->canonpath($path);

    # If path now empty, set to current path
#    $path = "." if ($path =~ m/^$/);

    $path = &abs_path($path);

    return $path;
}



# Function: Shell program 'basename' rewritten in Perl
sub get_filename {
    my ($filename) = (@_);

    $filename =~ s/^.*\/([^\/]+)\s*$/$1/;
    return $filename;
}



# Function: Finds file containing the Fortran 90 PROGRAM keyword among source files.
sub get_programsourcefile {
    if (defined($cl{'PROGRAMFILE'})) {
	return $cl{'PROGRAMFILE'};
    } else {
	# If no program source file is given on the command line, try to dynamically
	# determine it: Parse all application-specific source files.
	if ($defaults{'PROGRAMFILE'} ne "DETERMINED_ON_DEMAND_IF_UNSET") {
	    # Either the default value is set to some proper value
	    # (in particular not equal to DETERMINED_ON_DEMAND_IF_UNSET !) and we can
	    # just return that or we did already run this function earlier and determined
	    # the program source file in which case we can simply return the previous result.
	    return $defaults{'PROGRAMFILE'};
	} else {
	    print "WARNING: program source file not given on command line.\n" .
		  "         Trying to compensate, check result in configuration summary below.\n";
	    print "determining presumed (!) program source file... ";
	    my $line = "";
	    my @programfiles = ();
	    # Get rid of setting "DETERMINED_ON_DEMAND_IF_UNSET"
	    undef $defaults{'PROGRAMFILE'};
	    foreach my $file ( &get_sourcefilelist() ) {
		open (INFILE, "<", $file) or
		    die "\n$progname: ERROR:\n".
		        "Cannot open file <$file> for reading: $!\n";

		# Loop through file line by line
	        LINE: while (defined($line = <INFILE>)) {
		  # Remove comments
		  $line =~ s/\!.*$//;
		  $line =~ s/^[Cc].*$//;

		  # Parse for "program foobar" statements
		  # and add the module to the list
		  if ($line =~ m/^\s*program\s+\w+/i) {
		      push @programfiles, $file;
		  }
		}
		close (INFILE);

		# Ensure there is only *one* program source file
		if ($#programfiles > 0) {
		    die "\n\n$progname: ERROR:\n".
			"You did not specify the program source file with the\n" .
			"--programfile command line option. Additionally, while trying\n" .
			"to dynamically determine the program source file from the list\n" .
			"of application-specific source files, multiple files matched:\n" .
			&format_list("  ", 2, 75,
				     "<" . join("> <", @programfiles), "", "") . ">\n" .
			"There can be only one source file with the PROGRAM keyword!\n" .
			"I refuse to create <" . $MAKEFILE . ">.\n\n" .
			"Please specify the appropriate one explicitly with the\n" .
			"--programfile command line option.\n";
		} else {
		    $defaults{'PROGRAMFILE'} = $programfiles[0];
		}
	    }
	    print "done\n";
	    return $defaults{'PROGRAMFILE'};
	}
    }
    # Return an empty string, just to meet the interface. Code should never come here, though.
    return "";
}



# Function: Returns source file list
sub get_sourcefilelist {
    # $cl{'SRCLIST_APP'} has been passed as an array to GetOptions()
    # and as such is always defined. But is does not necessarily have
    # entries. So, don't test with perl function defined() whether it is
    # set. Instead test whether it contains one or more entries.
    # (Remember that Perl starts counting from zero, like C does.)
    if ($#{ $cl{'SRCLIST_APP'} } >= 0) {
        # Remove duplicate entries from application source file list
        my @tmplist = ();
        $oldEntry = "";
        foreach my $entry (sort @{ $cl{'SRCLIST_APP'} }) {
            # Exclude empty list members
            if ($entry) {
                # We have a sorted list of source files. Checking
                # whether two subsequent files have identical names
                # excludes duplicate entries.
                if ($entry ne $oldEntry) {
                    push @tmplist, $entry;
                    $oldEntry = $entry;
                }
            }
        }
	return @tmplist;
    } else {
	# If no app source list given on the command line, try to dynamically
	# determine a list: Use all source files in a generic src subdirectory
	# for a FEAT2 application.
	if (${ $defaults{'SRCLIST_APP'} }[0] ne "DETERMINED_ON_DEMAND_IF_UNSET") {
	    # Either the default value is set to some proper value
	    # (in particular not equal to DETERMINED_ON_DEMAND_IF_UNSET !) and we can
	    # just return that or we did already run this function earlier and determined
	    # the list in which case we can simply return the previous result.
	    return @{ $defaults{'SRCLIST_APP'} };
	} else {
	    print "WARNING: application-specific source files not given on command line.\n" .
		  "         Trying to compensate, check result in configuration summary below.\n";
	    print "creating a list of presumed (!) application source files... ";
	    if (opendir SRCDIR, SRCDIR_APP) {
		my $files = 0;
		# Get rid of setting "DETERMINED_ON_DEMAND_IF_UNSET"
		undef $defaults{'SRCLIST_APP'};
		map { $files++; push @{ $defaults{'SRCLIST_APP'} }, SRCDIR_APP . "/$_" }
			sort grep { /.+\.f90$/ && ! /^\./ } readdir SRCDIR;
		closedir SRCDIR;
		# SRCLIST_APP still empty?
		if ($files == 0) {
		    die "\n\n$progname: ERROR:\n".
			"You did not specify a list of application-specific source file\n" .
			"with the --srclist_app command line option. Additionally, the\n" .
			"subdirectory <" . SRCDIR_APP . ">, searched by default for " .
			"application-specific\n" .
			"source files in such a case, does not contain any *.f90 file.\n" .
			"I refuse to create <" . $MAKEFILE . ">.\n\n" .
			"Please specify the list of application-specific source files with\n" .
			"the --srclist_app command line option.\n";
		}
		print "done\n";
		return @{ $defaults{'SRCLIST_APP'} };
	    } else {
		die "\n\n$progname: ERROR:\n".
		    "You did not specify a list of application-specific source files\n" .
		    "with the --srclist_app command line option. Additionally, the\n" .
		    "subdirectory <" . SRCDIR_APP . ">, searched by default for " .
		    "application-specific\n" .
		    "source files in such a case, does not exist.\n" .
		    "I refuse to create <" . $MAKEFILE . ">.\n\n" .
		    "Please specify the list of application-specific source files with\n" .
		    "the --srclist_app command line option.\n";
	    }
	}
    }
    # Return an empty array, just to meet the interface. Code should never come here, though.
    return @{[]};
}



# Function: Returns extra source file list
sub get_extrasourcefilelist {
    # $cl{'SRCEXTRA_APP'} has been passed as an array to GetOptions()
    # and as such is always defined. But is does not necessarily have
    # entries. So, don't test with perl function defined() whether it is
    # set. Instead test whether it contains one or more entries.
    # (Remember that Perl starts counting from zero, like C does.)
    if ($#{ $cl{'SRCEXTRA_APP'} } >= 0) {
        # Remove duplicate entries from application source file list
        my @tmplist = ();
        $oldEntry = "";
        foreach my $entry (sort @{ $cl{'SRCEXTRA_APP'} }) {
            # Exclude empty list members
            if ($entry) {
                # We have a sorted list of source files. Checking
                # whether two subsequent files have identical names
                # excludes duplicate entries.
                if ($entry ne $oldEntry) {
                    push @tmplist, $entry;
                    $oldEntry = $entry;
                }
            }
        }
	return @tmplist;
    }
    # Return an empty array
    return @{[]};
}



# Function: Build list of valid build IDs from MAKEFILE_INC
sub get_validIDs {
    my $filename = &concat_filename($FEAT2BASEDIR, $MAKEFILE_CPU_INC);

    open(FILE, "<" , $filename) or
	die "\n$progname: ERROR:\n".
            INITIAL_MESSAGE .
            "Cannot open file <$filename> for reading: $!\n\n" .
            "Make sure the path to Makefile.inc is set correctly in\n" .
            "$progname and that you do not invoke this script from\n" .
            "the directory feast/bin, but from one of the application\n" .
            "directories.\n";
    while (<FILE>) {
        if (m/^ifeq \(\$\(call match,\$\(ID\),(.*)\),yes\)\s*$/) {
            push @valid_id, $1;
        }
    }
    close(FILE);
}



# Determine version of this script
# (from the SVN ID in the header of this script or
#  from the hard-coded VERSION constant)
sub get_version {
    my $version = "";
    my $additional = "";

    # Open this script for reading
    open(FILE, "<", $0);
    if (! eof(FILE)) {
        while (<FILE>) {
            if (m/^# \$Id: configure (\d+) /) {
                $version = "revision " . $1;
                last;
            }
        }
    }
    close(FILE);

    # Fall back to hard-coded version number if version number unset
    $version = "v" . VERSION if ($version eq "");

    return $version;
}



# Function which verifies that a given build ID is valid.
# In fact, it just checks whether the given id has a section in MAKEFILE_INC.
# Return values are TRUE (1) or FALSE (0) for valid or not.
sub id_is_valid {
    # Get valid IDs from MAKEFILE_INC
    &get_validIDs();

    my ($id) = (@_);
    foreach my $entry (@valid_id) {
	return 1 if ($id =~ m/$entry/);
    }
    return 0;
}



# Function which prints a complete list of valid build IDs to screen.
sub list_all_ids {
    # Get valid IDs from MAKEFILE_INC
    &get_validIDs();

    print "\n$progname " . &get_version() . ":\n" .
          "Valid build IDs match against the following regular expressions:\n";
    foreach my $entry (sort @valid_id) {
        if ($entry eq $defaultBuildID) {
            print "* $entry (default)\n";
        } else {
            print "* $entry\n";
        }
    }
    if (-1 == $#valid_id) {
	print "     (none)\n\n" .
	      "This is not supposed to happen. There has probably been some syntax change\n" .
	      "in the file <" . $MAKEFILE_CPU_INC . ">.\n" .
	      "Please adapt function list_all_ids() and/or get_validIDs() in $0 to it.\n";
    } else {
	print "\n" .
              "Use any of these build IDs as argument for the --id option.\n" .
              "The current build ID for " . &hostname() . " is:\n" .
              " " x ((66 - length($buildID))/2) . $buildID;
	print " (enforced)" if ($buildID ne $defaultBuildID);
	print "\n\n";
    }
    exit 0;
}



# Function which outputs all all application's proprietary source files
sub list_app_modules {
    my @list;

    print "\nList of all application's proprietary source files:\n";
    foreach ( &get_sourcefilelist() ) {
        push @list, &concat_filename($SRCDIR_APP, $_);
    }

    print foreach (join("\n", @list)) . "\n";
    exit 0;
}



# Function which prints a list of valid build IDs for the current host to screen.
sub list_ids {
    # Get valid IDs from MAKEFILE_INC
    &get_validIDs();

    my $id_1st3tokens = $defaultBuildID;
    $id_1st3tokens =~ s/^([^-]+-[^-]+-[^-]+).*$/$1/;

    print "\n$progname " . &get_version() . ":\n" .
          "Valid build IDs (for $id_1st3tokens hosts) match\n" .
          "against the following regular expressions:\n";
    foreach my $complete_matching_rule (sort @valid_id) {
	# $entry is a matching rule for a build ID. Even in the first three tokens
	# of $entry wildcards may have been used. In order to have an arbitrarily
	# given or set build ID with prefix "pc-coreduo-cygwin_nt5.1" result in
	# the following matches
	#     pc-coreduo-cygwin_nt.*-.*-blas.*
	#     pc-coreduo-cygwin_nt.*-g95-.*
	# (note the "nt5.1" in the prefix and the "nt.*" in the matches which is
	#  exactly the opposite of what we would like to have)
	# extract the first three tokens of $entry and try to match the first tokens
	# of the current build ID against them. In case of matches, print the complete
	# matching rule, i.e. the complete $entry.
	my $match_1st3tokens = $complete_matching_rule;
	$match_1st3tokens =~ s/([^-]+-[^-]+-[^-]+)(-.*)$/$1/;

	if ($id_1st3tokens =~ m/$match_1st3tokens/) {
            if ($complete_matching_rule eq $buildID) {
                print "* $complete_matching_rule (default)\n";
            } else {
                print "* $complete_matching_rule\n";
            }
	}
    }
    if (-1 == $#valid_id) {
	print "     (none)\n\n" .
	      "This is not supposed to happen. There has probably been some syntax change\n" .
	      "in the file <" . $MAKEFILE_CPU_INC . ">.\n" .
	      "Please adapt function list_ids() and/or get_validIDs() in $0 to it.\n";
    } else {
	print "\n" .
	      "Use any of these build IDs as argument for the --id option.\n" .
	      "The current build ID for " . &hostname() . " is:\n" .
	      " " x ((66 - length($buildID))/2) . $buildID;
	print " (enforced)" if ($buildID ne $defaultBuildID);
	print "\n\n";
    }
    exit 0;
}



# Function which outputs all FEAT2 kernel files the application is built from
sub list_kernel_modules {
    my @list;

    print "\nList of all FEAT2 kernel files the application is built from:\n";
    foreach (split(/\s+/, SRCLIST_KERNEL)) {
        push @list, &concat_filename($FEAT2BASEDIR, $SRCDIR_KERNEL, $_);
    }
    (my $dir = File::Spec->catdir($FEAT2BASEDIR, $SRCDIR_ARCH)) =~ s/\$\(ID\)/$buildID/;
    foreach (split(/\s+/, SRCLIST_ARCH)) {
        s/ID/$buildID/;
        push @list, &concat_filename($dir, $_);
    }

    print foreach (join("\n", @list)) . "\n";
    exit 0;
}



# Function which gets the name of a Fortran 77/90 source file or a header file and
# returns the dependency list for a Makefile statement.
sub make_dep_list {
    my ($dependencyListsHashRef,                        # is output variable
	$fileToParse, $parsedFile_PathInMakeSyntax,
        $parsedFile_changeExtensionForMakeTarget,       # boolean variable
        $parsedFile_ExtensionForMakeTarget,             # if previous variable is true, this holds the new extension
        $moduleFiles_extension,                         # file extension of Fortran~90 module object files, typically: "o"
        $objectdir, $headerFilesToCopyHashRef) = (@_);
    my $depstring  = "";
    my $objstring  = "";
    my $aux        = "";
    my @deps       = ();
    my $appstring  = "";

    # Strip off any path information
    $aux = get_filename($fileToParse);

    # Get a list of modules and include files
    # (modules are marked with prefix 'module:',
    #  include files with prefix 'include:')
    @deps = &get_dependency($fileToParse) if ($aux =~ m/\.(f90|f|h|inc)$/);

    # Store dependencies for later re-use
#    ${ $dependencyListsHashRef }{$fileToParse} = \@deps;
    ${ $dependencyListsHashRef }{$aux} = \@deps;

    # Construct name of object file from source file name
    $aux =~ s/\.[^\.]+$/.\Q$parsedFile_ExtensionForMakeTarget\E/ if ($parsedFile_changeExtensionForMakeTarget);
    $objstring = &concat_filename($objectdir, $aux) . ": ";

    # Create the list of depending files
    $depstring = "$parsedFile_PathInMakeSyntax ";

    # Add must-includes to list
    foreach $aux (split('\s+', MUST_INCLUDE)) {
        push @deps, "mustinclude:" . $aux;
    }

    foreach $aux (@deps) {
        # Module?
        if ($aux =~ m/^module:(.+)$/) {
	    $appstring = "$objectdir/$1.$moduleFiles_extension ";
	    # Append only if not already in list
	    if ($depstring !~ m/\Q$appstring\E/) {
		$depstring .= $appstring;
	    }
        }
        # Include file
        elsif ($aux =~ m/^include:(.+)$/) {
	    my $match = $1;
	    $appstring = "$objectdir/" . &basename($match) . " ";
	    # Append only if not already in list
	    if ($depstring !~ m/\Q$appstring\E/) {
		$depstring .= $appstring;

		# Add included file (adding relevant path info) to global list
		# of included files (in order to have them evaluated by cpp
		# on make invocation and then stored into object directory).
		# The approach differs depending on whether we have absolute
		# or relative base paths.
		# Absolute path case?
		if ($FEAT2BASEDIR =~ m/^\//) {
		    $aux = &abs_path(&concat_filename(&dirname($fileToParse), $match));
		} else {
		    $aux = &concat_filename(&dirname($fileToParse), $match);
		    # Cut off leading './', if any
		    $aux =~ s/^\.\///;
		}

		# Add to the list if not already on the list or in 'forbidden' lists
		my $auxBasename = &basename($aux);
		unless ((DO_NOT_INCLUDE          =~ m/\Q$auxBasename\E/) or
			($HEADER_FILES_TO_COPY   =~ m/\Q$auxBasename\E/) or
			defined(${ $headerFilesToCopyHashRef }{$auxBasename})) {
		    # Ensure first that the current file exists.
		    if (! -e $aux) {
			my $str =
			    "<$match> which got automatically expanded to\n" .
			    "<$aux>.\n";
			if ($match eq $aux) {
			    $str =
				"<$match>.\n";
			}
			die "\n\n$progname: ERROR:\n".
			    "File <$fileToParse> contains a reference to\n" .
			    $str .
			    "But no such file exists!\n\n" .
			    "(Hint: Most likely, you forgot to add the (relative) path to the file in the\n" .
			    "       Fortran 90 include statement.)\n";
		    }

		    # Strategy:
		    # * No file with this name seen yet. Store URI, inode and md5 sum of
		    #   file content
		    # * File with same URI already present:
		    #   skip file
		    # * File with different URI already present: compare inode and - if
		    #   inode is different - md5 sum of its content with stored
		    #   values. If both differ throw an error. Because even header files
		    #   are copied or preprocessed and stored into a single object
		    #   directory. So, having different files with the same name is not
		    #   feasible.
		    if (defined($headerfiles{$auxBasename})) {
			# Already seen a file with this name.
			# Compare URI. If identical, no need to throw an error. Skip file.
			if ($aux ne $headerfiles{$auxBasename}->{'URI'}) {
			    # URIs differ. Possibly because of "../" in URI.
			    # Compare inodes.
			    my $auxInode = stat($aux)->ino;
			    if ($auxInode ne $headerfiles{$auxBasename}->{'inode'}) {
				# URIs and inodes differ. Possibly, the second file
				# has identical content in which case it is still feasible
				# to specify it. Maybet the second file is a symbolic link
				# or lies on a different file system for strange reasons.
				#
				# Compute sum of current file content
				open(HEADERFILE, "<", $aux) or
				    die "\n$progname: ERROR:\n".
				    "Cannot open header file <$aux> for reading: $!\n";
				my $auxData = do { local $/; <HEADERFILE> };
				close(HEADERFILE);
				my $auxMD5 = md5($auxData);
				if ($auxMD5 ne $headerfiles{$auxBasename}->{'md5'}) {
				    die "\n\n$progname: ERROR:\n".
					"File <$fileToParse> contains a reference to\n" .
					"<$aux>, but source file\n" .
					"<" . $headerfiles{$auxBasename}->{'referer'} . "> parsed earlier\n" .
					"already contained a reference to a file with the same name,\n" .
					"but a different URI: <" . $headerfiles{$auxBasename}->{'URI'} . ">.\n" .
					"Additionally, the inode and md5sum of these files differ.\n" .
					"Given that all header files are copied to the same object directory\n" .
					"this file name collision is not feasible. Please rename either file.\n";
				} # different md5sum
			    } # different idnoe
			} # different URI
		    } else {
			# Parse this file for dependencies
			push @deps, &get_dependency($aux);

			# Store URI
			$headerfiles{$auxBasename}->{'URI'}   = $aux;
			# Store inode
			$headerfiles{$auxBasename}->{'inode'} = stat($aux)->ino;
			# Compute and md5 sum of file content
			open(HEADERFILE, "<", $aux) or
			    die "\n$progname: ERROR:\n".
			    "Cannot open header file <$aux> for reading: $!\n";
			my $auxData = do { local $/; <HEADERFILE> };
			close(HEADERFILE);
			my $auxMD5 = md5($auxData);
			$headerfiles{$auxBasename}->{'md5'} = $auxMD5;
			# Store first file that references this header file
			$headerfiles{$auxBasename}->{'referer'} = $fileToParse;
		    } # file seen before
#                push @headerfiles, $aux;
		} # not on exclude nor copy list
	    }
        }
        # Files that must be included
        elsif ($aux =~ m/^mustinclude:(.+)$/) {
	    $appstring = "$1 ";
	    # Append only if not already in list
	    if ($depstring !~ m/\Q$appstring\E/) {
		$depstring .= $appstring;
	    }
        }
    }

    return &format_list($objstring, 8, 70, $depstring, "\\\n", "\\");
}


# Function: Returns maximum of two numbers
sub max() {
    my ($a, $b) = (@_);

    die "$0: Function 'max' takes exactly 2 arguments, not " . ($#_ + 1) . ".\n" if ($#_ != 1);
    $a > $b ? return $a : return $b;
}


# Function: Print statistics about Makefile for a FEAT2 application created just now
sub print_statistics_about_feastAppMakefile {
    my $srclist_app = $_[0];
    my $srcextra_app = $_[1];
    my $string = "";

    print "\n$MAKEFILE successfully generated by $progname !\n\n";
    print "Configuration:\n";
    print "  Application name                 : " .
	( (defined($cl{'APPNAME'})) ? $cl{'APPNAME'} : $defaults{'APPNAME'} ) . "\n";
    print "  Application program file         : <" .
	&get_programsourcefile() . ">\n";

    print &format_list("  Application's source files       :", 37, 75,
		       "<" . join("> <", @{$srclist_app}), "", "") . ">\n";

    if ($#{$cl{'SRCEXTRA_APP'}} >= 0) {
	print &format_list("  Application's extra source files :", 37, 75,
			   "<" . join("> <", @{$srcextra_app}), "", "") . ">\n";
    }

    $string = (defined($cl{'RELINK_ALWAYS'})) ? $cl{'RELINK_ALWAYS'} : $defaults{'RELINK_ALWAYS'};
    print "  Application binary               : will be " .
	( ($string eq "YES") ? "relinked every time make is invoked" : "linked only when missing" ) . "\n";

    $string = (defined($cl{'AGMG'})) ? $cl{'AGMG'} : $defaults{'AGMG'};
    print "  AGMG support                     : " .
        ( ($string eq "YES") ? "yes" : "no" ) . "\n";

    print "  Application binary type          : ";
    $string = (defined($cl{'BINARY'})) ? $cl{'BINARY'} : $defaults{'BINARY'};
    if ($string eq "STD") {
        print "use system environment\n";
    } elsif ($string eq "32") {
        print "force 32-bit code generation\n";
    } else {
        print "force 64-bit code generation\n";
    }

    $string = $objdir;
    # Replace the symbolic names $(HOME) and $(ID), used in the Makefile,
    # with something that works on the command line: ~ and build ID.
    $string =~ s/\$\(HOME\)/~/;
    $string =~ s/\$\(ID\)/$buildID/;
    # In case of a serial build, remove any given 6th token
    if (((defined($cl{'MPI'})) ? $cl{'MPI'} : $defaults{'MPI'}) ne "YES") {
	$string =~ s/^([^-]+-[^-]+-[^-]+-[^-]+-[^-]+)(-[^-]+|)$/$1/;
    }
    $string .= "-opt" . ((defined($cl{'OPT'})) ? $cl{'OPT'} : $defaults{'OPT'});
    print "  Object files go to               : <$string>,\n";
    # Replace the symbolic names $(HOME) and $(ID), used in the Makefile,
    # with something that works on the command line: ~ and build ID.
    $string = $objdir_lib;
    $string =~ s/\$\(HOME\)/~/;
    $string =~ s/\$\(LIBID\)/$buildID_lib/;
    $string .= "-opt" . ((defined($cl{'OPT'})) ? $cl{'OPT'} : $defaults{'OPT'});
    print "                                     <$string>\n";

    print "  Optimisation level               : ";
    $string = (defined($cl{'OPT'})) ? $cl{'OPT'} : $defaults{'OPT'};
    if ($string eq "NATIVE-EXPENSIVE") {
        print "expensive optimisations with automatic tuning for build host\n";
    } elsif ($string eq "NATIVE") {
        print "full optimisation with automatic tuning for build host\n";
    } elsif ($string eq "EXPENSIVE") {
        print "expensive optimisations\n";
    } elsif ($string eq "YES") {
        print "full optimisation\n";
    } else {
        print "no optimisation\n";
    }

    $string = (defined($cl{'INTSIZE'})) ? $cl{'INTSIZE'} : $defaults{'INTSIZE'};
    print "  Integer size                     : " .
        ( ($string eq "STD") ? "standard" : "large integers" ) . "\n";

    $string = (defined($cl{'MONITOR_COMPILE_ENV'})) ? $cl{'MONITOR_COMPILE_ENV'} : $defaults{'MONITOR_COMPILE_ENV'};
    print "  Detect changes in compile env    : " .
	( ($string eq "YES") ? "enabled" : "disabled" ) . "\n";

    $string = (defined($cl{'OPENMP'})) ? $cl{'OPENMP'} : $defaults{'OPENMP'};
    print "  OpenMP support                   : " .
        ( ($string eq "YES") ? "yes" : "no" ) . "\n";

    $string = (defined($cl{'MPI'})) ? $cl{'MPI'} : $defaults{'MPI'};
    print "  MPI support                      : " .
        ( ($string eq "YES") ? "yes" : "no" ) . "\n";

    $string = (defined($cl{'MPIWRAPPERS'})) ? $cl{'MPIWRAPPERS'} : $defaults{'MPIWRAPPERS'};
    print "  Use MPI wrapper commands         : " .
	( ($string eq "YES") ? "enabled" : "disabled" ) . "\n";

    if ($#{$cl{'COPROCLIST'}} >= 0) {
	print &format_list("  Coprocessor(s)                   :", 37, 100,
			   join(' ', @{$cl{'COPROCLIST'}}), "", "") . "\n";
    }

    print "\n\n";

}



# Function which shows valid options and IDs to this script
sub show_help {
    my $counter = 0;
    print
        "Usage: $progname [options]\n" .
        "Default settings are taken from Makefile.inc based on a guessed host id.\n" .
        "Options specified here will override these settings.\n" .
        "Configuration:\n" .
        "--------------\n" .
	"--[no-]agmg         Create Makefile for application with/without AGMG support\n" .
        "                    (default: " . lc($defaults{'AGMG'}) . ").\n" .
        "--appname=<file>    Set application name to <file> (default: " . $defaults{'APPNAME'} . ")\n" .
        "--apponlyflags=<string>\n" .
        "                    Additional preprocessor and compiler flags used only\n" .
        "                    for application's source files.\n" .
        "                    Typically, the switch is used for preprocessor flags\n" .
        "                    that make only sense for a specific application.\n" .
        "                    Interferences with other applications defining the\n" .
        "                    same preprocessor directives are prevented. Third-\n" .
        "                    party libraries can still be used across different\n" .
        "                    applications as they are compiled without flags in\n" .
        "                    <string>.\n" .
        "--ar=<file>         Path and options for creating archives\n" .
	"--binary=<string>   Allows to set the default binary.\n" .
	"                    <string> can be one of the following:\n" .
	"                    --binary=32 : Generate code for 32-bit environment.\n" .
	"                    --binary=64 : Generate code for 64-bit environment.\n" .
        "--buildlib=<string> Specify libraries to build\n" .
        "                    (like: agmg amd blas coproc inshape2d lapack metis splib umfpack)\n" .
        "--cc=<file>         C compiler\n" .
        "--cflagsc=<string>  Set C compiler flags to <string>\n" .
        "--cflagscoproc=<string>\n" .
	"                    Set C compiler flags for coproc library to <string>,\n" .
	"                    requires --coproclist=<target>\n" .
        "--cflagscuda=<string>\n" .
	"                    Set CUDA compiler flags to <string>\n" .
        "--cflagscxx=<string>\n" .
	"                    Set C++ compiler flags to <string>\n" .
        "--cflagsf77=<string>\n" .
	"                    Set Fortran 77 compiler flags to <string>\n" .
        "--cflagsf90=<string>\n" .
	"                    Set Fortran 90 compiler flags to <string>\n" .
	"--coproclist=<string>\n" .
	"                    Identifier for coprocessor support.\n" .
	"                    Valid IDs are: cpu, opengl, cuda10, cuda11, cuda12,\n" .
	"                    cuda13, cuda20, cuda21, cuda30, cuda35. Note that the cpu identifier\n" .
	"                    must always be set if coprocessor support is requested.\n" .
        "--cpp=<file>        C preprocessor\n" .
        "--cuda=<file>       CUDA compiler\n" .
        "--cxx=<file>        C++ compiler\n" .
        "--debug             Show settings stored into Makefile which will\n" .
        "                    override defaults from Makefile.inc.\n" .
        "                    This flag is *not* an alias for --no-opt nor does\n" .
        "                    it result in a Makefile that creates code with\n" .
        "                    debugging symbols!\n\n" .
        "--f77=<file>        Fortran 77 compiler\n" .
        "--f90=<file>        Fortran 90 compiler\n" .
        "--force-id          A build ID is accepted even if the system verify fails\n" .
        "--header-files-to-copy=<string>\n" .
        "                    (Comma-separated) List of header files that should be\n" .
        "                    copied to the object directory, not evaluated with cpp\n" .
        "                    first" .
        "--id=<string>       Configure for build ID <string>.\n" .
        "                    For a list of already set up configurations for current\n" .
        "                    host invoke '$progname --list-ids'.\n" .
        "                    For a complete list invoke '$progname --list-all-ids'\n" .
        "--inc=<dir>         F77/F90/C/C++ header files in <dir>\n" .
        "--int-size=<string>\n" .
        "                    Allows to set the default integer size to support large\n" .
        "                    arrays with > 4 GB size. <string> can be one of the following:\n" .
        "                    --int-size=std   : Standard integer size.\n" .
        "                                       Defaults to 32 bit integers.\n" .
        "                    --int-size=large : Large integers.\n" .
        "                                       Defaults to 64 bit integers.\n" .
        "                                       Allows arrays with > 4GB in size.\n" .
        "--ld=<file>         Linker\n" .
        "--ldflags=<string>  Set linker flags to <string>\n" .
        "--libdir=<dir>      Object code libraries in DIR\n" .
        "--libs=ARG          Libraries to include in build\n" .
        "--make=<file>       Set make program to <file>\n" .
        "--makefile=<file>   Name of makefile to create\n" .
        "--mode=<string>     (deprecated, use MPI=YES/NO)\n" .
        "                    where <string> is one of PARALLEL or SERAIL.\n" .
        "                    Create Makefile for a parallel or serial application\n" .
        "                    (default: " . lc($defaults{'MODE'}) . ").\n" .
        "--modextension=<string>\n" .
        "                    Specify <string> as extension used by the Fortran 90\n" .
        "                    compiler for module information files\n" .
        "--[no-]monitor-compile-env\n" .
        "                    Monitor modification dates of all compilers and\n" .
        "                    compile settings for changes in subsequent\n" .
        "                    compilations. In case of discrepancies, recompile\n" .
        "                    application (default: " .
	lc($defaults{'MONITOR_COMPILE_ENV'}) . ").\n" .
        "--movemod=<string>  If the Fortran 90 compiler fails to store module\n" .
        "                    information files in \$(OBJDIR) and fills up the\n" .
        "                    working directory instead, use --movemod=YES to\n" .
        "                    have the Makefile compensate for this annoyance.\n" .
        "--[no-]mpi          Create Makefile for application with/without MPI support\n" .
        "                    (default: " . lc($defaults{'MPI'}) . ").\n" .
        "--mpiinc=<string>   Include directive for MPI header files\n" .
        "--mpilibdir=<string>\n" .
	"                    Extension for the linker search path to find MPI\n" .
	"                    libraries\n" .
        "--mpilibs=<string>  Linker commands specifying MPI libraries to link against\n" .
        "--[no-]mpiwrappers  Controls whether or not to use MPI wrappers for\n" .
        "                    compiling and linking (default: " .
	lc($defaults{'MPIWRAPPERS'}) . ").\n" .
        "--objdir-lib-prefix=<dir>\n" .
	"                    Prepend <dir> to paths of libraries' object files.\n" .
	"                    Typically all libraries can be shared among all FEAT2\n" .
	"                    applications as they have no dependency on the FEAT2\n" .
	"                    kernel or a FEAT2 application and have always identical\n" .
	"                    compile settings. In particular when compiling the\n" .
	"                    the regression benchmark it makes a big difference\n" .
	"                    having to compile libraries only once (default: ../..).\n" .
        "--objdir-prefix=<dir>\n" .
	"                    Prepend <dir> to paths of an application's object files.\n" .
	"                    (default: none)\n" .
        "--[no-]openmp       Create Makefile for application with/without OpenMP support\n" .
        "                    (default: " . lc($defaults{'OPENMP'}) . ").\n" .
        "--[no-]opt,--opt=expensive,--opt=native,--opt=native-expensive\n" .
        "                    Controls whether to use no (but including debugging\n" .
        "                    symbols), good or expensive compiler optimisation.\n" .
        "                    Keyword native indicates the automatic optimisation\n" .
        "                    for the build host should be enabled if this feature\n" .
        "                    is supported by the compiler." .
        "                    (default: " . lc($defaults{'OPT'}) . ").\n" .
	"--precc=<file>      Command to prepand to the C compiler\n" .
	"--precxx=<file>     Command to prepand to the C++ compiler\n" .
	"--precuda=<file>    Command to prepand to the Cuda compiler\n" .
	"--pref77=<file>     Command to prepand to the Fortran 77 compiler\n" .
	"--pref90=<file>     Command to prepand to the Fortran 90 compiler\n" .
	"--preld=<file>      Command to prepand to the Linker\n" .
        "--programfile=<file>\n" .
	"                    Set application's program file to <file>\n" .
	"                    (Reason: Parsing to build a minimal list of required \n" .
	"                     source files needs a starting point. Being explicit\n" .
	"                     avoids problems with less tidy users.)\n" .
        "--ranlib=<file>     Path and options to create index for archives\n" .
        "--regression-benchmark\n" .
        "                    Create Makefile for FEAT2 regression benchmark and\n" .
        "                    fork configure calls for all benchmark applications,\n" .
        "                    i.e. all directories starting with 'src_'\n" .
        "--[no-]relink-always\n" .
        "                    Whether or not to relink the application every time\n" .
        "                    make is invoked (default: " .
	lc($defaults{'RELINK_ALWAYS'}) . ").\n" .
        "                    Be careful with --no-relink-always:\n" .
        "                    When developing on multiple platforms, your\n" .
        "                    application might not be relinked if no source file\n" .
        "                    has changed since you changed platform!\n" .
        "--srcextra=<string>\n" .
	"                    Set extra source files (other than Fortran) to <string>\n" .
        "--srcextra_app=<string>\n" .
	"                    Set application's extra source files (other than Fortran) to <string>\n" .
        "--srclist_app=<string>\n" .
	"                    Set application's source files to <string>\n" .
        "--suppressflags=<string>\n" .
        "                    Remove all (comma-separated) strings in <string> from C,\n" .
        "                    Fortran 77/90 compiler and linker settings, i.e.\n" .
        "                    from CFLAGSF77, CFLAGSF90, CFLAGSC, CFLAGSCOPROC, \n" .
	"                    CFLAGSCXX and LDFLAGS.\n" .
        "                    If your application does not compile or run properly\n" .
        "                    because of a specific compiler option that ought not\n" .
        "                    be removed globally, you can inhibit its usage for\n" .
        "                    your application by adding the exact string to <string>.\n" .
	"--warn=<string>     Compile code with warnings <string> enabled.\n" .
        "Options which cause $progname to print only information without a\n" .
        "Makefile being created:\n" .
        "--help              Print this message\n" .
        "--list-all-ids      Print a list of all valid build IDs. Use any\n" .
        "                    of them as ARCH argument for --id option\n" .
        "--list-app-modules  Print application's proprietary source files\n" .
        "--list-ids          Print a list of valid build IDs for current\n" .
        "                    host. Use any of the items as ARCH argument for --id\n" .
        "                    option.\n" .
        "--list-kernel-modules\n" .
        "                    Print all FEAT2 kernel files the application is\n" .
        "                    built from\n" .
        "--version           Show version information\n";
    exit 0;
}



# Function which shows this script's version
sub show_version {
    print $progname . " " . &get_version() . "\n";
    print "Written by Sven H.M. Buijssen.\n";

    exit 0;
}



# Function to have a Unix-portable which within perl
# (inspired from File::Which 0.05)
sub which {
    my ($exec) = @_;

    return undef unless $exec;

    my $all = wantarray;
    my @results = ();
    my @path_ext = ('');

    my @path = File::Spec->path();
    unshift @path, File::Spec->curdir;

    for my $base (map { &concat_filename($_, $exec) } @path) {
        for my $ext (@path_ext) {
            my $file = $base.$ext;

            if ((-x $file)      # executable, normal case
                and !-d _)      # and we don't want dirs to pass (as they are -x)
            {
                return $file unless $all;
                push @results, $file;       # Make list to return later
            }
        }
    }

    if ($all) {
        return @results;
    } else {
        return undef;
    }
}



# Function to catch interrupt signals;
# sole argument is signal name.
sub signal_handler {
    my ($sig) = @_;

    print STDERR "\n*** Caught signal $sig, aborting.\n";

    # Figure out whether this configure instance is a child of another
    # configure process, i.e. configuring a single benchmark application as
    # part of configuring the benchmark itself.
    if (scalar keys(%cachedtests) > 0) {
	# Unfortunately, we do not only need to kill the parent, but in most
	# cases even the grand parent and the great grand parent, as the
	# benchmark Perl configure script invokes per benchmark application a
	# shell configure script with per-application settings which in turn
	# calls the Perl configure script. So, determine the process
	# hierarchy.
	my %ppid = ();
	my %cmd = ();
	my $i = 0;
	open(PSEF_PIPE, "ps -ef|")
	    or warn "$progname: Cannot determine process hierarchy and hence not kill grand parent pid.\n";
	<PSEF_PIPE>;
	while (<PSEF_PIPE>) {
	    chomp();
	    my @psefField = split(' ', $_, 8);
	    my $pid     = $psefField[1];
	    $ppid{$pid} = $psefField[2];
	    $cmd{$pid}  = $psefField[7];
	}
	close(PSEF_PIPE);

	my $thisppid = getppid();
	my $msgPrefixShown = 0;
	foreach my $pid ($ppid{$ppid{$thisppid}}, $ppid{$thisppid}, $thisppid) {
	    if ($cmd{$pid} =~ m/\/configure\b/) {
		if (kill(0, $pid)) {   # Check if pid still exists
		    unless ($msgPrefixShown) {
			print "*** Terminating parent configures (PIDs $pid";
		    } else {
			print ", $pid";
		    }
		    $msgPrefixShown++;
		    kill 9, $pid;
		}
	    }
	}
	print ").\n";
    }
    exit 1;
}
