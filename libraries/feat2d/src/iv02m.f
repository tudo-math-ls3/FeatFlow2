C --------------------------------------------------------------------------
C  *** IVD02M ***
C
C Purpose: Calculate ILU(s) matrix, single precision
C
C Parameters: see IXD01M
C The resulting ILU matrix will be in DOUBLE PRECISION !
C ==========================================================================

      SUBROUTINE IVD02M (VA,KCOL,KLD,NEQ,NS,OMEGA,LU,LLU,LLUJ,
     *                   LUPTR,MNEED)
C
C Allgemeine Definitionen
C
      IMPLICIT NONE
      
C Parameters
      DOUBLE PRECISION OMEGA
      REAL VA
      INTEGER KCOL, KLD, NEQ, NS, MNEED
      INTEGER LU, LLU, LLUJ, LUPTR

C local variables
      INTEGER LVA, NA1

C Common-Block-Variables
      INTEGER NNARR, IER, ICHECK, NWORK, IWORK, IWMAX, L, M, MT, MKEYB,
     *        MTERM, MERR, MPROT, MSYS, MTRC, KWORK, IRECL8
      DOUBLE PRECISION DWORK
      REAL VWORK
      
      PARAMETER (NNARR=299)
      DIMENSION VWORK(1),KWORK(1)
      COMMON /ERRCTL/ IER,ICHECK
      COMMON          NWORK,IWORK,IWMAX,L(NNARR),DWORK(1)
      COMMON /OUTPUT/ M,MT,MKEYB,MTERM,MERR,MPROT,MSYS,MTRC,IRECL8
      EQUIVALENCE (DWORK(1),VWORK(1),KWORK(1))
      SAVE /ERRCTL/,/OUTPUT/
      
C special definitions

      DIMENSION VA(*),KCOL(*),KLD(*)

C We use the double precision routine for calculating the matrix.
C Therefore it's necessary to convert our system matrix temporarily
C to double precision.

C Reserve the memory needed

      NA1 = KLD(NEQ+1)-1
      CALL ZNEW (NA1,-2,LVA,'LVA   ')
      
C Copy the (single precision) matrix

      CALL LCP2 (VA,VWORK(L(LVA)),NA1)
      
C Change the type, convert the matrix to double

      CALL ZCTYPE(1,LVA,'LVA   ')

C Calculate the (M)ILU(k) matrix. The resulting matrix is double 
C precision!

      CALL IVD01M (DWORK(L(LVA)),KCOL,KLD,NEQ,NS,OMEGA,
     *             LU,LLU,LLUJ,LUPTR,MNEED)
      
C Release temporary space for double precision system matrix

      CALL ZDISP (0,LVA,'LVA   ')

C Calculation finished.
      
99999 END

C ---------------------------------------------------------------------
C *** IV22M *** 
C
C Purpose: Smoothing with ILU(s), precomputed matrix
C          Single precision system matrix, double precision ILU matrix,
C          generated by IVD01M
C
C Parameters: see IV21M
C --------------------------------------------------------------------------

      SUBROUTINE IV22M (VA,KCOL,KLD,KLU,KLLU,KLUJ,KLUP,DX,DB,DD,
     *                  NEQ,NIT,RLXSM)
C
C Allgemeine Definitionen
C

      IMPLICIT NONE

C Parameters
      REAL VA
      DOUBLE PRECISION DX, DB, DD, RLXSM
      INTEGER KCOL, KLD, KLU, KLLU, KLUJ, KLUP, NEQ, NIT
      
C local Variables
      
      INTEGER I   
      
C Common-Block-Variables
      INTEGER NNARR, IER, ICHECK, NWORK, IWORK, IWMAX, L, M, MT, MKEYB,
     *        MTERM, MERR, MPROT, MSYS, MTRC, KWORK, IRECL8
      DOUBLE PRECISION DWORK
      REAL VWORK
      
      PARAMETER (NNARR=299)
      DIMENSION VWORK(1),KWORK(1)
      COMMON /ERRCTL/ IER,ICHECK
      COMMON          NWORK,IWORK,IWMAX,L(NNARR),DWORK(1)
      COMMON /OUTPUT/ M,MT,MKEYB,MTERM,MERR,MPROT,MSYS,MTRC,IRECL8
      EQUIVALENCE (DWORK(1),VWORK(1),KWORK(1))
      SAVE /ERRCTL/,/OUTPUT/
      
C Special definitions

      DIMENSION VA(*),KCOL(*),KLD(*),DX(NEQ),DD(NEQ),DB(NEQ)
      DIMENSION KLU(*)

C perform NIT smoothing steps to DX.
C           dx = dx + M*(b-Ax)

      DO I = 1,NIT

C       *** dd = b-Ax = -DA*dx+db

        CALL LCP1 (DB,DD,NEQ)
        CALL LAX37 (VA,KCOL,KLD,NEQ,DX,DD,-1D0,1D0)

C Use ILU preconditioning of the defect vector for smoothing.
C Therefore solve Uy=dd, Ldb=y with the SPLIB routine LUSOLT:

         CALL LUSOLT (NEQ,DD,KLU(KLLU),KLU(KLUJ),KLU(KLUP))

C Now relaxate the preconditioned defect vector by RLXSM=omega and add
C it to the solution, this completes the smoothing
C   dx = dx + omega*dd

        CALL LLC1 (DD,DX,NEQ,RLXSM,1D0)

      END DO

      END


************************************************************************
*                                                                      *
* IV22MD                                                               *
*                                                                      *
* Purpose: Smoothing with ILU(s), SPLIB's MSR matrix format            *
*          Direct smoothing, smoothing matrix is computed before and   *
*          destroyed after the smoothing automatically.                *
*          x_(n+1) = x_n + Omega*M*(b-Ax)                              *
*          Single precision version, double precision ILU matrix.      *
*                                                                      *
* Parameters: See IV21MD                                               *
*                                                                      *
*                                                                      *
************************************************************************

      SUBROUTINE IV22MD (VA,KCOL,KLD,IFIL,OMEGA,DX,DB,DD,
     *                   NEQ,NIT,RLXSM)

C Parameters

      REAL VA(*)
      DOUBLE PRECISION DX(NEQ),DB(NEQ),DD(NEQ),RLXSM,OMEGA
      INTEGER KCOL(*),KLD(*),NEQ,NIT

C Common blocks

      INTEGER IER,ICHECK,NWORK,IWORK,IWMAX,L
      INTEGER M,MT,MKEYB,MTERM,MERR,MPROT,MSYS,MTRC,IRECL8
      INTEGER NNARR,KWORK
      REAL VWORK
      DOUBLE PRECISION DWORK
      
      PARAMETER (NNARR=299)
      
      DIMENSION VWORK(1),KWORK(1)
      COMMON /ERRCTL/ IER,ICHECK
      COMMON          NWORK,IWORK,IWMAX,L(NNARR),DWORK(1)
      COMMON /OUTPUT/ M,MT,MKEYB,MTERM,MERR,MPROT,MSYS,MTRC,IRECL8
      EQUIVALENCE (DWORK(1),VWORK(1),KWORK(1))
      SAVE /ERRCTL/,/OUTPUT/

C local variables

      INTEGER LU

C Calculate ILU(s) matrix

C      print *,'Calculating ILU for ',NEQ,' equations...'
      CALL IVD02M (VA,KCOL,KLD,NEQ,IFIL,OMEGA,LU,LLU,LLUJ,
     *             LUPTR,MNEED)

C Perform smoothing

C      print *,'Smoothing...'
      CALL IV22M (VA,KCOL,KLD,KWORK(L(LU)),LLU,LLUJ,LUPTR,DX,DB,DD,
     *            NEQ,NIT,RLXSM)


C finally destroy ILU matrix again

C      print *,'Destroying ILU...'
      CALL ZDISP (0,LU,'ILkTMP')

      END
