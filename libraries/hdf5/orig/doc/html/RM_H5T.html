<html>
<head><title>
HDF5/H5T API Specification
</title>

<!-- #BeginLibraryItem "/ed_libs/styles_RM.lbi" -->

<!--
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
  * Copyright by the Board of Trustees of the University of Illinois.         *
  * All rights reserved.                                                      *
  *                                                                           *
  * This file is part of HDF5.  The full HDF5 copyright notice, including     *
  * terms governing use, modification, and redistribution, is contained in    *
  * the files COPYING and Copyright.html.  COPYING can be found at the root   *
  * of the source code distribution tree; Copyright.html can be found at the  *
  * root level of an installed copy of the electronic HDF5 document set and   *
  * is linked from the top-level documents page.  It can also be found at     *
  * http://hdf.ncsa.uiuc.edu/HDF5/doc/Copyright.html.  If you do not have     *
  * access to either file, you may request a copy from hdfhelp@ncsa.uiuc.edu. *
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 -->

<link href="ed_styles/RMelect.css" rel="stylesheet" type="text/css">
<!-- #EndLibraryItem -->

</head>

<body bgcolor="#FFFFFF">
<!-- HEADER RIGHT " " -->


<!-- #BeginLibraryItem "/ed_libs/NavBar_RM.lbi" -->
<hr>
<center>
<table border=0 width=98%>
<tr><td valign=top align=left>
<a href="index.html">HDF5 documents and links</a>&nbsp;<br>
<a href="H5.intro.html">Introduction to HDF5</a>&nbsp;<br>
<a href="http://hdf.ncsa.uiuc.edu/HDF5/doc/UG/index.html">HDF5 User Guide</a>&nbsp;<br>
<!--
<a href="Glossary.html">Glossary</a><br>
-->
</td>
<td valign=top align=right>
And in this document, the 
<a href="RM_H5Front.html">HDF5 Reference Manual</a>&nbsp;&nbsp;<br>
<a href="RM_H5.html">H5</a>&nbsp;&nbsp;
<a href="RM_H5A.html">H5A</a>&nbsp;&nbsp;
<a href="RM_H5D.html">H5D</a>&nbsp;&nbsp;
<a href="RM_H5E.html">H5E</a>&nbsp;&nbsp;
<a href="RM_H5F.html">H5F</a>&nbsp;&nbsp;
<a href="RM_H5G.html">H5G</a>&nbsp;&nbsp;
<a href="RM_H5I.html">H5I</a>&nbsp;&nbsp;
<a href="RM_H5P.html">H5P</a>&nbsp;&nbsp;<br>
<a href="RM_H5R.html">H5R</a>&nbsp;&nbsp;
<a href="RM_H5S.html">H5S</a>&nbsp;&nbsp;
<a href="RM_H5T.html">H5T</a>&nbsp;&nbsp;
<a href="RM_H5Z.html">H5Z</a>&nbsp;&nbsp;
<a href="Tools.html">Tools</a>&nbsp;&nbsp;
<a href="PredefDTypes.html">Datatypes</a>&nbsp;&nbsp;
</td></tr>
<tr><td colspan="2" align="right">
<i><small>(<a href="http://hdf.ncsa.uiuc.edu/HDF5/doc/PSandPDF/">PDF</a>
of complete manual formatted as print volume)&nbsp;&nbsp;&nbsp;</small></i>
</td></tr>
</table>
</center>
<hr>
<!-- #EndLibraryItem --><center>
<h1>H5T: Datatype Interface</h1>
</center>

<h2>Datatype Object API Functions</h2>

These functions create and manipulate the datatype which describes elements
of a dataset.


<p>
<strong>The C Interfaces:</strong>

<table border=0>
<tr><td valign=top>
<i>General Datatype Operations</i>
    <li><a href="#Datatype-Create">H5Tcreate</a>
    <li><a href="#Datatype-Open">H5Topen</a>
    <li><a href="#Datatype-Commit">H5Tcommit</a>
    <li><a href="#Datatype-Committed">H5Tcommitted</a>
    <li><a href="#Datatype-Copy">H5Tcopy</a>
    <li><a href="#Datatype-Equal">H5Tequal</a>
    <li><a href="#Datatype-Lock">H5Tlock</a>
    <li><a href="#Datatype-GetClass">H5Tget_class</a>
    <li><a href="#Datatype-GetSize">H5Tget_size</a>
    <li><a href="#Datatype-GetSuper">H5Tget_super</a>
    <li><a href="#Datatype-GetNativeType">H5Tget_native_type</a>
    <li><a href="#Datatype-DetectClass">H5Tdetect_class</a>
    <li><a href="#Datatype-Close">H5Tclose</a>
<br><br>
<i>Conversion Functions</i>
    <li><a href="#Datatype-Convert">H5Tconvert</a>
    <li><a href="#Datatype-Find">H5Tfind</a>
    <li><a href="#Datatype-SetOverflow">H5Tset_overflow</a>
    <li><a href="#Datatype-GetOverflow">H5Tget_overflow</a>
    <li><a href="#Datatype-Register">H5Tregister</a>
    <li><a href="#Datatype-Unregister">H5Tunregister</a>
</td><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td><td valign=top>
<i>Atomic Datatype Properties</i>
  <table><tr><td valign=top>
    <li><a href="#Datatype-SetSize">H5Tset_size</a>
    <li><a href="#Datatype-GetOrder">H5Tget_order</a>
    <li><a href="#Datatype-SetOrder">H5Tset_order</a>
    <li><a href="#Datatype-GetPrecision">H5Tget_precision</a>
    <li><a href="#Datatype-SetPrecision">H5Tset_precision</a>
    <li><a href="#Datatype-GetOffset">H5Tget_offset</a>
    <li><a href="#Datatype-SetOffset">H5Tset_offset</a>
    <li><a href="#Datatype-GetPad">H5Tget_pad</a>
    <li><a href="#Datatype-SetPad">H5Tset_pad</a>
    <li><a href="#Datatype-GetSign">H5Tget_sign</a>
    <li><a href="#Datatype-SetSign">H5Tset_sign</a>
  </td><td valign=top>
    <li><a href="#Datatype-GetFields">H5Tget_fields</a>
    <li><a href="#Datatype-SetFields">H5Tset_fields</a>
    <li><a href="#Datatype-GetEbias">H5Tget_ebias</a>
    <li><a href="#Datatype-SetEbias">H5Tset_ebias</a>
    <li><a href="#Datatype-GetNorm">H5Tget_norm</a>
    <li><a href="#Datatype-SetNorm">H5Tset_norm</a>
    <li><a href="#Datatype-GetInpad">H5Tget_inpad</a>
    <li><a href="#Datatype-SetInpad">H5Tset_inpad</a>
    <li><a href="#Datatype-GetCset">H5Tget_cset</a>
    <li><a href="#Datatype-SetCset">H5Tset_cset</a>
    <li><a href="#Datatype-GetStrpad">H5Tget_strpad</a>
    <li><a href="#Datatype-SetStrpad">H5Tset_strpad</a>
  </td></tr></table>
<br>
<i>Enumeration Datatypes</i>
    <li><a href="#Datatype-EnumCreate">H5Tenum_create</a>
    <li><a href="#Datatype-EnumInsert">H5Tenum_insert</a>
    <li><a href="#Datatype-EnumNameOf">H5Tenum_nameof</a>
    <li><a href="#Datatype-EnumValueOf">H5Tenum_valueof</a>
    <li><a href="#Datatype-GetMemberValue">H5Tget_member_value</a>
    <li><a href="#Datatype-GetNmembers">H5Tget_nmembers</a>
    <li><a href="#Datatype-GetMemberName">H5Tget_member_name</a>
    <li><a href="#Datatype-GetMemberIndex">H5Tget_member_index</a>
</td><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td><td valign=top>
<i>Compound Datatype Properties</i>
    <li><a href="#Datatype-GetNmembers">H5Tget_nmembers</a>
    <li><a href="#Datatype-GetMemberClass">H5Tget_member_class</a>
    <li><a href="#Datatype-GetMemberName">H5Tget_member_name</a>
    <li><a href="#Datatype-GetMemberIndex">H5Tget_member_index</a>
    <li><a href="#Datatype-GetMemberOffset">H5Tget_member_offset</a>
    <li><a href="#Datatype-GetMemberType">H5Tget_member_type</a>
    <li><a href="#Datatype-Insert">H5Tinsert</a>
    <li><a href="#Datatype-Pack">H5Tpack</a>
<br><br>
<i>Array Datatypes</i>
    <li><a href="#Datatype-ArrayCreate">H5Tarray_create</a>
    <li><a href="#Datatype-GetArrayNdims">H5Tget_array_ndims</a>
    <li><a href="#Datatype-GetArrayDims">H5Tget_array_dims</a>
<br><br>
<i>Variable-length Datatypes</i>
    <li><a href="#Datatype-VLCreate">H5Tvlen_create</a>
    <li><a href="#Datatype-IsVariableString">H5Tis_variable_str</a>
<br><br>
<i>Opaque Datatypes</i>
    <li><a href="#Datatype-SetTag">H5Tset_tag</a>
    <li><a href="#Datatype-GetTag">H5Tget_tag</a>
</td></tr>
</table>

<br>

<!-- NEW PAGE -->
<i>Alphabetical Listing</i>
<table border="0" width=100%>
  <tr>
    <td valign="top" width=30%>
      <li><a href="#Datatype-ArrayCreate">H5Tarray_create</a>
      <li><a href="#Datatype-Close">H5Tclose</a>
      <li><a href="#Datatype-Commit">H5Tcommit</a>
      <li><a href="#Datatype-Committed">H5Tcommitted</a>
      <li><a href="#Datatype-Convert">H5Tconvert</a>
      <li><a href="#Datatype-Copy">H5Tcopy</a>
      <li><a href="#Datatype-Create">H5Tcreate</a>
      <li><a href="#Datatype-DetectClass">H5Tdetect_class</a>
      <li><a href="#Datatype-EnumCreate">H5Tenum_create</a>
      <li><a href="#Datatype-EnumInsert">H5Tenum_insert</a>
      <li><a href="#Datatype-EnumNameOf">H5Tenum_nameof</a>
      <li><a href="#Datatype-EnumValueOf">H5Tenum_valueof</a>
      <li><a href="#Datatype-Equal">H5Tequal</a>
      <li><a href="#Datatype-Find">H5Tfind</a>
      <li><a href="#Datatype-GetArrayDims">H5Tget_array_dims</a>
      <li><a href="#Datatype-GetArrayNdims">H5Tget_array_ndims</a>
      <li><a href="#Datatype-GetClass">H5Tget_class</a>
      <li><a href="#Datatype-GetCset">H5Tget_cset</a>
      <li><a href="#Datatype-GetEbias">H5Tget_ebias</a>
      <li><a href="#Datatype-GetFields">H5Tget_fields</a>
      <li><a href="#Datatype-GetInpad">H5Tget_inpad</a>    
    </td>
    
    <td width=3%>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
    
    <td valign="top" width=30%>      
      <li><a href="#Datatype-GetMemberClass">H5Tget_member_class</a>
      <li><a href="#Datatype-GetMemberIndex">H5Tget_member_index</a>
      <li><a href="#Datatype-GetMemberName">H5Tget_member_name</a>
      <li><a href="#Datatype-GetMemberOffset">H5Tget_member_offset</a>
      <li><a href="#Datatype-GetMemberType">H5Tget_member_type</a>
      <li><a href="#Datatype-GetMemberValue">H5Tget_member_value</a>
      <li><a href="#Datatype-GetNativeType">H5Tget_native_type</a>
      <li><a href="#Datatype-GetNmembers">H5Tget_nmembers</a>
      <li><a href="#Datatype-GetNorm">H5Tget_norm</a>
      <li><a href="#Datatype-GetOffset">H5Tget_offset</a>
      <li><a href="#Datatype-GetOrder">H5Tget_order</a>
      <li><a href="#Datatype-GetOverflow">H5Tget_overflow</a>
      <li><a href="#Datatype-GetPad">H5Tget_pad</a>
      <li><a href="#Datatype-GetPrecision">H5Tget_precision</a>
      <li><a href="#Datatype-GetSign">H5Tget_sign</a>
      <li><a href="#Datatype-GetSize">H5Tget_size</a>
      <li><a href="#Datatype-GetStrpad">H5Tget_strpad</a>
      <li><a href="#Datatype-GetSuper">H5Tget_super</a>
      <li><a href="#Datatype-GetTag">H5Tget_tag</a>
      <li><a href="#Datatype-Insert">H5Tinsert</a>
      <li><a href="#Datatype-IsVariableString">H5Tis_variable_str</a>
    </td>
    
    <td width=3%>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
    
    <td valign="top">      
      <li><a href="#Datatype-Lock">H5Tlock</a>
      <li><a href="#Datatype-Open">H5Topen</a>
      <li><a href="#Datatype-Pack">H5Tpack</a>
      <li><a href="#Datatype-Register">H5Tregister</a>
      <li><a href="#Datatype-SetCset">H5Tset_cset</a>
      <li><a href="#Datatype-SetEbias">H5Tset_ebias</a>
      <li><a href="#Datatype-SetFields">H5Tset_fields</a>
      <li><a href="#Datatype-SetInpad">H5Tset_inpad</a>
      <li><a href="#Datatype-SetNorm">H5Tset_norm</a>
      <li><a href="#Datatype-SetOffset">H5Tset_offset</a>
      <li><a href="#Datatype-SetOrder">H5Tset_order</a>
      <li><a href="#Datatype-SetOverflow">H5Tset_overflow</a>
      <li><a href="#Datatype-SetPad">H5Tset_pad</a>
      <li><a href="#Datatype-SetPrecision">H5Tset_precision</a>
      <li><a href="#Datatype-SetSign">H5Tset_sign</a>
      <li><a href="#Datatype-SetSize">H5Tset_size</a>
      <li><a href="#Datatype-SetStrpad">H5Tset_strpad</a>
      <li><a href="#Datatype-SetTag">H5Tset_tag</a>
      <li><a href="#Datatype-Unregister">H5Tunregister</a>
      <li><a href="#Datatype-VLCreate">H5Tvlen_create</a>
    </td>
  </tr>
</table>

<br>
<strong>The FORTRAN90 Interfaces:</strong>
<br>
In general, each FORTRAN90 subroutine performs exactly the same task 
as the corresponding C function.  
<br>

<table border=0>
<tr><td valign=top width=32%>
<i>General Datatype Operations</i>
    <li><a href="#Datatype-Create">h5tcreate_f</a>
    <li><a href="#Datatype-Open">h5topen_f</a>
    <li><a href="#Datatype-Commit">h5tcommit_f</a>
    <li><a href="#Datatype-Committed">h5tcommitted_f</a>
    <li><a href="#Datatype-Copy">h5tcopy_f</a>
    <li><a href="#Datatype-Equal">h5tequal_f</a>
<!--<li><a href="#Datatype-Lock">h5tlock_f</a>                          -->
    <li><a href="#Datatype-GetClass">h5tget_class_f</a>
    <li><a href="#Datatype-GetSize">h5tget_size_f</a>
    <li><a href="#Datatype-GetSuper">h5tget_super_f</a>
<!--<li><a href="#Datatype-GetNativeType">h5tget_native_type_f</a>      -->
<!--<li><a href="#Datatype-DetectClass">h5tdetect_class_f</a>             -->
    <li><a href="#Datatype-Close">h5tclose_f</a>
<!--<p>                                                                     -->
<!--<i>Conversion Functions</i>                                             -->
<!--<li><a href="#Datatype-Convert">h5tconvert_f</a>                    -->
<!--<li><a href="#Datatype-Find">h5tfind_f</a>                          -->
<!--<li><a href="#Datatype-SetOverflow">h5tset_overflow_f</a>           -->
<!--<li><a href="#Datatype-GetOverflow">h5tget_overflow_f</a>           -->
<!--<li><a href="#Datatype-Register">h5tregister_f</a>                  -->
<!--<li><a href="#Datatype-Unregister">h5tunregister_f</a>              -->
    <br><br>
    <i>Enumeration Datatypes</i>
    <li><a href="#Datatype-EnumCreate">h5tenum_create_f</a>
    <li><a href="#Datatype-EnumInsert">h5tenum_insert_f</a>
    <li><a href="#Datatype-EnumNameOf">h5tenum_nameof_f</a>
    <li><a href="#Datatype-EnumValueOf">h5tenum_valueof_f</a>
    <li><a href="#Datatype-GetMemberValue">h5tget_member_value_f</a>
    <li><a href="#Datatype-GetNmembers">h5tget_nmembers_f</a>
    <li><a href="#Datatype-GetMemberName">h5tget_member_name_f</a>
    <li><a href="#Datatype-GetMemberIndex">h5tget_member_index_f</a>
</td><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td><td valign=top width=32%>
<i>Atomic Datatype Properties</i>
    <li><a href="#Datatype-SetSize">h5tset_size_f</a>
    <li><a href="#Datatype-GetOrder">h5tget_order_f</a>
    <li><a href="#Datatype-SetOrder">h5tset_order_f</a>
    <li><a href="#Datatype-GetPrecision">h5tget_precision_f</a>
    <li><a href="#Datatype-SetPrecision">h5tset_precision_f</a>
    <li><a href="#Datatype-GetOffset">h5tget_offset_f</a>
    <li><a href="#Datatype-SetOffset">h5tset_offset_f</a>
<!--  <table><tr><td valign=top>                                            -->
    <li><a href="#Datatype-GetPad">h5tget_pad_f</a>
    <li><a href="#Datatype-SetPad">h5tset_pad_f</a>
    <li><a href="#Datatype-GetSign">h5tget_sign_f</a>
    <li><a href="#Datatype-SetSign">h5tset_sign_f</a>
    <li><a href="#Datatype-GetFields">h5tget_fields_f</a>
    <li><a href="#Datatype-SetFields">h5tset_fields_f</a>
    <li><a href="#Datatype-GetEbias">h5tget_ebiass_f</a>
    <li><a href="#Datatype-SetEbias">h5tset_ebiass_f</a>
<!--  </td><td valign=top>                                                  -->
    <li><a href="#Datatype-GetNorm">h5tget_norm_f</a>
    <li><a href="#Datatype-SetNorm">h5tset_norm_f</a>
    <li><a href="#Datatype-GetInpad">h5tget_inpad_f</a>
    <li><a href="#Datatype-SetInpad">h5tset_inpad_f</a>
    <li><a href="#Datatype-GetCset">h5tget_cset_f</a>
    <li><a href="#Datatype-SetCset">h5tset_cset_f</a>
    <li><a href="#Datatype-GetStrpad">h5tget_strpad_f</a>
    <li><a href="#Datatype-SetStrpad">h5tset_strpad_f</a>
<!--  </td></tr></table>                                                    -->
<!--<p>                                                                     -->
<!--<i>Variable-length Datatypes</i>                                        -->
<!--<li><a href="#Datatype-VLCreate">h5tvlen_create_f</a>               -->
    </td><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td><td valign=top width=32%>
    <i>Array Datatypes</i>
    <li><a href="#Datatype-ArrayCreate">h5tarray_create_f</a>   
    <li><a href="#Datatype-GetArrayNdims">h5tget_array_ndims_f</a>  
    <li><a href="#Datatype-GetArrayDims">h5tget_array_dims_f</a>  
    <br><br>     
    <i>Compound Datatype Properties</i>
    <li><a href="#Datatype-GetNmembers">h5tget_nmembers_f</a>
    <li><a href="#Datatype-GetMemberClass">h5tget_member_class_f</a>
    <li><a href="#Datatype-GetMemberName">h5tget_member_name_f</a>
    <li><a href="#Datatype-GetMemberIndex">h5tget_member_index_f</a>
    <li><a href="#Datatype-GetMemberOffset">h5tget_member_offset_f</a>
<!--<li><a href="#Datatype-GetMemberDims">h5tget_member_dims_f</a>          -->
    <li><a href="#Datatype-GetMemberType">h5tget_member_type_f</a>
    <li><a href="#Datatype-Insert">h5tinsert_f</a>
    <li><a href="#Datatype-Pack">h5tpack_f</a>
<!--<li><a href="#Datatype-InsertArray">h5tinsert_array_f</a>               -->
    <br><br>
    <i>Variable-length Datatypes</i>
    <li><a href="#Datatype-VLCreate">h5tvlen_create_f</a>
    <li><a href="#Datatype-IsVariableString">h5tis_variable_str_f</a>
    <br><br>
    <i>Opaque Datatypes</i>
    <li><a href="#Datatype-SetTag">h5tset_tag_f</a>
    <li><a href="#Datatype-GetTag">h5tget_tag_f</a>
</td></tr>
</table>


<p>
The Datatype interface, H5T, provides a mechanism to describe the
      storage format of individual data points of a data set and is
      hopefully designed in such a way as to allow new features to be
      easily added without disrupting applications that use the data
      type interface.  A dataset (the H5D interface) is composed of a
      collection or raw data points of homogeneous type organized
      according to the data space (the H5S interface).

<p>
A datatype is a collection of datatype properties, all of
      which can be stored on disk, and which when taken as a whole,
      provide complete information for data conversion to or from that
      datatype.  The interface provides functions to set and query
      properties of a datatype.
      
<p>
A <em>data point</em> is an instance of a <em>datatype</em>,
      which is an instance of a <em>type class</em>.  We have defined
      a set of type classes and properties which can be extended at a
      later time.  The atomic type classes are those which describe
      types which cannot be decomposed at the datatype interface
      level; all other classes are compound.

<p>
See <a href="Datatypes.html"><cite>The Datatype Interface (H5T)</cite></a>
in the <cite>HDF5 User's Guide</cite> for further information, including a complete list of all supported datatypes.

<!-- NEW PAGE -->
<!-- HEADER RIGHT " " -->
<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tarray_create" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-ArrayCreate">H5Tarray_create</a>
<dt><strong>Signature:</strong>
    <dd><em>hid_t</em> <code>H5Tarray_create</code>(
                       <em>hid_t</em> <code>base</code>,
                       <em>int</em> <code>rank</code>,
                       <em>const hsize_t</em> <code>dims[/*rank*/]</code>,
                       <em>const int</em> <code>perm[/*rank*/]</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Creates an array datatype object.
<dt><strong>Description:</strong>
    <dd><code>H5Tarray_create</code> creates a new array datatype object.
         <p>
         <code>base</code> is the datatype of every element of the array, 
         i.e., of the number at each position in the array.
         <p>
         <code>rank</code> is the number of dimensions and the 
         size of each dimension is specified in the array <code>dims</code>.
         The value of <code>rank</code> is currently limited to
         <code>H5S_MAX_RANK</code> and must be greater than <code>0</code> 
         (zero).
         All dimension sizes specified in <code>dims</code> must be greater
         than <code>0</code> (zero).
         <p>
         The array <code>perm</code> is designed to contain the dimension 
         permutation, i.e. C versus FORTRAN array order.  
         &nbsp;
         <b><i>(The parameter </i><code>perm</code><i> is currently unused and is not yet implemented.)</i></b>
         
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em> <code>base</code></td>
            <td valign="top">IN: Datatype identifier for the array base datatype.</td></tr>
        <tr>
		    <td valign="top"><em>int</em> <code>rank</code></td>
            <td valign="top">IN: Rank of the array.</td></tr>
        <tr>
		    <td valign="top"><em>const&nbsp;hsize_t</em>&nbsp;<code>dims[/*rank*/]&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">IN: Size of each array dimension.</td></tr>
        <tr>
		    <td valign="top"><em>const int</em> <code>perm[/*rank*/]</code></td>
            <td valign="top">IN: Dimension permutation.  
                &nbsp;
                <b><i>(Currently not implemented.)</i></b></td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns a non-negative value if successful;
        otherwise returns a negative value.
<dt><strong>Fortran90 Interface:</strong> h5tarray_create_f
    <dd>
	<pre>
SUBROUTINE h5tarray_create_f(base_id, rank, dims, type_id, hdferr)
  IMPLICIT NONE
  INTEGER(HID_T), INTENT(IN) :: base_id   ! Identifier of array base datatype
  INTEGER, INTENT(IN)        ::  rank     ! Rank of the array
  INTEGER(HSIZE_T), DIMENSION(*), INTENT(IN) :: dims 
                                          ! Sizes of each array dimension
  INTEGER(HID_T), INTENT(OUT) :: type_id  ! Identifier of the array datatype
  INTEGER, INTENT(OUT)        :: hdferr   ! Error code
END SUBROUTINE h5tarray_create_f
	</pre>		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
  <dt><strong>History:</strong>
	<ul><table width="90%">
        <tr>
		  <td valign="top" align="left" width="10%">
		    <strong>Release</strong>&nbsp;&nbsp;&nbsp;&nbsp;</td>
          <td valign="top" align="left">
		    <strong>C</strong></td></tr>
        <tr>
		  <td valign="top">1.4.0</td>
          <td valign="top">
		    Function introduced in this release.</td></tr>
    </table></ul>
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tclose" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-Close">H5Tclose</a>
<dt><strong>Signature:</strong>
    <dd><em>herr_t </em><code>H5Tclose</code>(<em>hid_t </em><code>type_id</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Releases a datatype.  
<dt><strong>Description:</strong>
    <dd><code>H5Tclose</code> releases a datatype.  Further access 
        through the datatype identifier is illegal.  Failure to release 
        a datatype with this call will result in resource leaks.
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		  <td valign="top"><em>hid_t</em>&nbsp;<code>type_id&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
          <td valign="top">Identifier of datatype to release.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns a non-negative value if successful;
        otherwise returns a negative value.
<dt><strong>Fortran90 Interface:</strong> h5tclose_f
    <dd>
	<pre>
SUBROUTINE h5tclose_f(type_id, hdferr) 
  IMPLICIT NONE
  INTEGER(HID_T), INTENT(IN) :: type_id ! Datatype identifier 
  INTEGER, INTENT(OUT) :: hdferr        ! Error code
                                        ! 0 on success and -1 on failure
END SUBROUTINE h5tclose_f
	</pre>		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tcommit" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-Commit">H5Tcommit</a>
<dt><strong>Signature:</strong>
    <dd><em>herr_t</em><code>H5Tcommit</code>(<em>hid_t</em> <code>loc_id</code>,
        <em>const char *</em> <code>name</code>,
        <em>hid_t</em> <code>type</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Commits a transient datatype to a file, creating a new named datatype.
<dt><strong>Description:</strong>
    <dd><code>H5Tcommit</code> commits a transient datatype 
        (not immutable) to a file, turned it into a named datatype.  
        The <code>loc_id</code> is either a file or group identifier  
        which, when combined with <code>name</code>, refers to a new 
        named datatype.
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		  <td valign="top"><em>hid_t</em> <code>loc_id</code></td>
          <td valign="top">IN: A file or group identifier.</td></tr>
        <tr>
		  <td valign="top"><em>const&nbsp;char&nbsp;*</em>&nbsp;<code>name&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
          <td valign="top">IN: A datatype name.</td></tr>
        <tr>
		  <td valign="top"><em>hid_t</em> <code>type</code></td>
          <td valign="top">IN: A datatype identifier.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns a non-negative value if successful;
        otherwise returns a negative value.
<dt><strong>Fortran90 Interface:</strong> h5tcommit_f
    <dd>
	<pre>
SUBROUTINE h5tcommit_f(loc_id, name, type_id, hdferr) 
  IMPLICIT NONE
  INTEGER(HID_T), INTENT(IN) :: loc_id  ! File or group identifier 
  CHARACTER(LEN=*), INTENT(IN) :: name  ! Datatype name within file or group
  INTEGER(HID_T), INTENT(IN) :: type_id ! Datatype identifier 
  INTEGER, INTENT(OUT) :: hdferr        ! Error code
                                        ! 0 on success and -1 on failure
END SUBROUTINE h5tcommit_f
	</pre>		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tcommitted" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-Committed">H5Tcommitted</a>
<dt><strong>Signature:</strong>
    <dd><em>htri_t</em><code>H5Tcommitted</code>(<em>hid_t</em> <code>type</code>)
<dt><strong>Purpose:</strong>
    <dd>Determines whether a datatype is a named type or a transient type.  
<dt><strong>Description:</strong>
    <dd><code>H5Tcommitted</code> queries a type to determine whether 
        the type specified by the <code>type</code> identifier 
        is a named type or a transient type.  If this function returns 
        a positive value, then the type is named (that is, it has been 
        committed, perhaps by some other application).  Datasets which
        return committed datatypes with <code>H5Dget_type()</code> are 
        able to share the datatype with other datasets in the same file.
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em>&nbsp;<code>type&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">IN: Datatype identifier.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>When successful, returns a positive value, for <code>TRUE</code>, 
        if the datatype has been committed, or <code>0</code> (zero), 
        for <code>FALSE</code>, if the datatype has not been committed.
        Otherwise returns a negative value.
<dt><strong>Fortran90 Interface:</strong> h5tcommitted_f
    <dd>
	<pre>
SUBROUTINE h5tcommitted_f(type_id, hdferr) 
  IMPLICIT NONE
  INTEGER(HID_T), INTENT(IN) :: type_id ! Datatype identifier 
  INTEGER, INTENT(OUT) :: hdferr        ! Error code
END SUBROUTINE h5tcommitted_f
	</pre>		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tconvert" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-Convert">H5Tconvert</a>
<dt><strong>Signature:</strong>
    <dd><em>herr_t</em> <code>H5Tconvert</code>(<em>hid_t</em> <code>src_id</code>,
        <em>hid_t</em> <code>dst_id</code>,
        <em>size_t</em> <code>nelmts</code>,
        <em>void *</em><code>buf</code>,
        <em>void *</em><code>background</code>,
        <em>hid_t</em> <code>plist_id</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Converts data from between specified datatypes.
<dt><strong>Description:</strong>
    <dd><code>H5Tconvert</code> converts <code>nelmts</code> elements 
        from the type specified by the <code>src_id</code> identifier 
        to type <code>dst_id</code>.  
        The source elements are packed in <code>buf</code> and on return 
        the destination will be packed in <code>buf</code>.  
        That is, the conversion is performed in place.  
        The optional background buffer is an array of <code>nelmts</code> 
        values of destination type which are merged with the converted 
        values to fill in cracks (for instance, <code>background</code> 
        might be an array of structs with the <code>a</code> and 
        <code>b</code> fields already initialized and the conversion  
        of <code>buf</code> supplies the <code>c</code> and <code>d</code> 
        field values).
        <p>
        The parameter <code>plist_id</code> contains the dataset transfer 
        property list identifier which is passed to the conversion functions.  
        As of Release 1.2, this parameter is only used to pass along the 
        variable-length datatype custom allocation information.
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em> <code>src_id</code></td>
            <td valign="top">Identifier for the source datatype.</td></tr>
        <tr>
		    <td valign="top"><em>hid_t</em> <code>dst_id</code></td>
            <td valign="top">Identifier for the destination datatype.</td></tr>
        <tr>
		    <td valign="top"><em>size_t</em> <code>nelmts</code></td>
            <td valign="top">Size of array <code>buf</code>.</td></tr>
        <tr>
		    <td valign="top"><em>void *</em><code>buf</code></td>
            <td valign="top">Array containing pre- and post-conversion values.</td></tr>
        <tr>
		    <td valign="top"><em>void&nbsp;*</em><code>background&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">Optional background buffer.</td></tr>
        <tr>
		    <td valign="top"><em>hid_t</em> <code>plist_id</code></td>
            <td valign="top">Dataset transfer property list identifier.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns a non-negative value if successful;
        otherwise returns a negative value.
<dt><strong>Fortran90 Interface:</strong>
    <dd>None.
<!--
	<pre>
SUBROUTINE
	</pre>
-->		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
<dt><strong>History:</strong>
    <ul><table width="90%">
        <tr>
		  <td valign="top" align="left" width="10%">
		    <strong>Release</strong>&nbsp;&nbsp;&nbsp;&nbsp;</td>
          <td valign="top" align="left">
		    <strong>C</strong></td></tr>
        <tr>
		  <td valign="top">1.6.3</td>
          <td valign="top">
			<code>nelmts</code> parameter type changed to 
			<em>size_t</em>.</td></tr>
        <tr>
		  <td valign="top">1.4.0</td>
          <td valign="top">
			<code>nelmts</code> parameter type changed to 
			<em>hsize_t</em>.</td></tr>
    </table></ul>
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tcopy" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-Copy">H5Tcopy</a>
<dt><strong>Signature:</strong>
    <dd><em>hid_t </em><code>H5Tcopy</code>(<em>hid_t </em><code>type_id</code>)
<dt><strong>Purpose:</strong>
    <dd>Copies an existing datatype.  
<dt><strong>Description:</strong>
    <dd><code>H5Tcopy</code> copies an existing datatype.  
        The returned type is always transient and unlocked.  
        <p>
        The <code>type_id</code> argument can be either a datatype
        identifier, a predefined datatype (defined in 
        <code>H5Tpublic.h</code>), or a dataset identifier.
        If <code>type_id</code> is a dataset identifier instead of a 
        datatype identifier, then this function returns a transient, 
        modifiable datatype which is a copy of the dataset's datatype.
        <p>
        The datatype identifier returned should be released with 
        <code>H5Tclose</code> or resource leaks will occur.  
<!--
        <p>
        Native datatypes supported by the library are:
        <ul> <dl>
            <dt>H5T_NATIVE_CHAR
                <dd> Native character type, declare dataset array as 'char'
            <dt>H5T_NATIVE_UCHAR
                <dd> Native unsigned character type, declare dataset array as 'unsigned char'
            <dt>H5T_NATIVE_SHORT
                <dd> Native short type, declare dataset array as 'short'
            <dt>H5T_NATIVE_USHORT
                <dd> Native unsigned short type, declare dataset array as 'unsigned short'
            <dt>H5T_NATIVE_INT
                <dd> Native int type, declare dataset array as 'int'
            <dt>H5T_NATIVE_UINT
                <dd> Native unsigned int type, declare dataset array as 'unsigned int'
            <dt>H5T_NATIVE_LONG
                <dd> Native long type, declare dataset array as 'unsigned long'
            <dt>H5T_NATIVE_ULONG
                <dd> Native unsigned long type, declare dataset array as 'unsigned long'
            <dt>H5T_NATIVE_LLONG
                <dd> Native long long type, declare dataset array as 'unsigned long long'
            <dt>H5T_NATIVE_ULLONG
                <dd> Native unsigned long long type, declare dataset array as 'unsigned long long'
            <dt>H5T_NATIVE_INT8
                <dd> Native signed 8-bit type, declare dataset array as 'int8'
            <dt>H5T_NATIVE_UINT8
                <dd> Native unsigned 8-bit type, declare dataset array as 'uint8'
            <dt>H5T_NATIVE_INT16
                <dd> Native signed 16-bit type, declare dataset array as 'int16'
            <dt>H5T_NATIVE_UINT16
                <dd> Native unsigned 16-bit type, declare dataset array as 'uint16'
            <dt>H5T_NATIVE_INT32
                <dd> Native signed 32-bit type, declare dataset array as 'int32'
            <dt>H5T_NATIVE_UINT32
                <dd> Native unsigned 32-bit type, declare dataset array as 'uint32'
            <dt>H5T_NATIVE_INT64
                <dd> Native signed 64-bit type, declare dataset array as 'uint64'
            <dt>H5T_NATIVE_UINT64
                <dd> Native unsigned 64-bit type, declare dataset array as 'uint64'
            <dt>H5T_NATIVE_FLOAT
                <dd> Native single-precision float type, declare dataset array as 'float'
            <dt>H5T_NATIVE_DOUBLE
                <dd> Native double-precision float type, declare dataset array as 'double'
            <dt>H5T_NATIVE_HSIZE
                <dd> Native size_t type, declare dataset array as 'hsize_t'
            <dt>H5T_NATIVE_HSSIZE
                <dd> Native signed size_t type, declare dataset array as 'hssize_t'
            <dt>H5T_NATIVE_HERR
                <dd> Native error type, declare dataset array as 'herr_t'
            <dt>H5T_NATIVE_HBOOL
                <dd> Native boolean type, declare dataset array as 'hbool_t'
        </dl> </ul>
-->
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em>&nbsp;<code>type_id&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">Identifier of datatype to copy.  Can be a datatype
                identifier, a predefined datatype (defined in 
                <code>H5Tpublic.h</code>), or a dataset identifier.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns a datatype identifier if successful;
        otherwise returns a negative value
<dt><strong>Fortran90 Interface:</strong> h5tcopy_f
    <dd>
	<pre>
SUBROUTINE h5tcopy_f(type_id, new_type_id, hdferr) 
  IMPLICIT NONE
  INTEGER(HID_T), INTENT(IN) :: type_id      ! Datatype identifier 
  INTEGER(HID_T), INTENT(OUT) :: new_type_id ! Identifier of datatype's copy 
  INTEGER, INTENT(OUT) :: hdferr             ! Error code
                                             ! 0 on success and -1 on failure
END SUBROUTINE h5tcopy_f
	</pre>		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tcreate" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-Create">H5Tcreate</a>
<dt><strong>Signature:</strong>
    <dd><em>hid_t </em><code>H5Tcreate</code>(<em>H5T_class_t </em><code>class</code>,
        <em>size_t</em><code>size</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Creates a new datatype.
<dt><strong>Description:</strong>
    <dd><code>H5Tcreate</code> creates a new datatype of the specified 
        class with the specified number of bytes.  
        <p>
        The following datatype classes are supported with this function:
        <ul>
            <li><code>H5T_COMPOUND</code> 
            <li><code>H5T_OPAQUE</code> 
            <li><code>H5T_ENUM</code> 
        </ul>
        <p>
        Use <code>H5Tcopy</code> to create integer or floating-point datatypes. 
        <p>
        The datatype identifier returned from this function should be 
        released with <code>H5Tclose</code> or resource leaks will result.
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>H5T_class_t</em>&nbsp;<code>class&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">Class of datatype to create.</td></tr>
        <tr>
		    <td valign="top"><em>size_t</em> <code>size</code></td>
            <td valign="top">The number of bytes in the datatype to create.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns datatype identifier if successful;
        otherwise returns a negative value.
<dt><strong>Fortran90 Interface:</strong> h5tcreate_f
    <dd>
	<pre>
SUBROUTINE h5tcreate_f(class, size, type_id, hdferr) 
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: class             ! Datatype class can be one of
                                           !    H5T_COMPOUND_F (6)
                                           !    H5T_ENUM_F     (8)
                                           !    H5T_OPAQUE_F   (9)
  INTEGER(SIZE_T), INTENT(IN) :: size      ! Size of the datatype
  INTEGER(HID_T), INTENT(OUT) :: type_id   ! Datatype identifier
  INTEGER, INTENT(OUT) :: hdferr           ! Error code
END SUBROUTINE h5tcreate_f
	</pre>		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tdetect_class" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-DetectClass">H5Tdetect_class</a>
<dt><strong>Signature:</strong>
    <dd><em>htri_t </em><code>H5Tdetect_class</code>(<em>hid_t</em> <code>dtype_id</code>,
        <em>H5T_class_t</em><code>dtype_class</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Determines whether a datatype contains any datatypes of the 
        given datatype class.
<dt><strong>Description:</strong>
    <dd><code>H5Tdetect_class</code> determines whether the datatype 
        specified in <code>dtype_id</code> contains any datatypes of the 
        datatype class specified in <code>dtype_class</code>.
        <p>
        This function is useful primarily in recursively examining 
        all the fields and/or base types 
        of compound, array, and variable-length datatypes.
        <p>
        Valid class identifiers are as defined in 
	<a href="#Datatype-GetClass"><code>H5Tget_class</code></a>.
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em> <code>dtype_id</code></td>
            <td valign="top">Datatype identifier.</td></tr>
        <tr>
		    <td valign="top"><em>H5T_class_t</em>&nbsp;<code>dtype_class&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">Datatype class.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns <code>TRUE</code> or <code>FALSE</code> if successful;
        otherwise returns a negative value.
<dt><strong>Fortran90 Interface:</strong>
    <dd>None.
<!--

	<pre>
SUBROUTINE
	</pre>
-->		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
<dt><strong>History:</strong>
    <ul><table width="90%">
        <tr>
		  <td valign="top" align="left" width="10%">
		    <strong>Release</strong>&nbsp;&nbsp;&nbsp;&nbsp;</td>
          <td valign="top" align="left">
		    <strong>C</strong></td></tr>
        <tr>
		  <td valign="top">1.6.0</td>
          <td valign="top">
		    Function introduced in this release.</td></tr>
    </table></ul>
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tenum_create" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-EnumCreate">H5Tenum_create</a>
<dt><strong>Signature:</strong>
    <dd><em>hid_t</em> <code>H5Tenum_create</code>(<em>hid_t</em> <code>parent_id</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Creates a new enumeration datatype.
<dt><strong>Description:</strong>
    <dd><code>H5Tenum_create</code> creates a new enumeration datatype 
        based on the specified base datatype, <code>parent_id</code>, 
        which must be an integer type.
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em>&nbsp;<code>parent_id&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">IN: Datatype identifier for the base datatype.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns the datatype identifier for the new enumeration datatype if successful;
        otherwise returns a negative value.
<dt><strong>Fortran90 Interface:</strong> h5tenum_create_f
    <dd>
	<pre>
SUBROUTINE h5tenum_create_f(parent_id, new_type_id, hdferr) 
  IMPLICIT NONE
  INTEGER(HID_T), INTENT(IN) :: parent_id     ! Datatype identifier for
                                              ! the  base datatype
  INTEGER(HID_T), INTENT(OUT) :: new_type_id  ! Datatype identifier for the
                                              ! new enumeration datatype    
  INTEGER, INTENT(OUT) :: hdferr              ! Error code
END SUBROUTINE h5tenum_create_f
	</pre>		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tenum_insert" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-EnumInsert">H5Tenum_insert</a>
<dt><strong>Signature:</strong>
    <dd><em>herr_t</em> <code>H5Tenum_insert</code>(<em>hid_t</em> <code>type</code>,
        <em>const char</em> *<code>name</code>,
        <em>void</em> *<code>value</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Inserts a new enumeration datatype member.
<dt><strong>Description:</strong>
    <dd><code>H5Tenum_insert</code> inserts a 
        new enumeration datatype member into an enumeration datatype. 
        <p>
        <code>type</code> is the enumeration datatype, 
        <code>name</code> is the name of the new member, and 
        <code>value</code> points to the value of the new member.
        <p>
        <code>name</code> and <code>value</code> must both 
        be unique within <code>type</code>. 
        <p>
        <code>value</code> points to data which is of the 
        datatype defined when the enumeration datatype was created.
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em> <code>type</code></td>
            <td valign="top">IN: Datatype identifier for the enumeration datatype.</td></tr>
        <tr>
		    <td valign="top"><em>const&nbsp;char</em>&nbsp;*<code>name&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">IN: Name of the new member.</td></tr>
        <tr>
		    <td valign="top"><em>void</em> *<code>value</code></td>
            <td valign="top">IN: Pointer to the value of the new member.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns a non-negative value if successful;
        otherwise returns a negative value.
<dt><strong>Fortran90 Interface:</strong> h5tenum_insert_f
    <dd>
	<pre>
SUBROUTINE h5tenum_insert_f(type_id,  name, value, hdferr) 
  IMPLICIT NONE
  INTEGER(HID_T), INTENT(IN) :: type_id ! Datatype identifier 
  CHARACTER(LEN=*), INTENT(IN) :: name  ! Name of the new member
  INTEGER, INTENT(IN) :: value          ! Value of the new member
  INTEGER, INTENT(OUT) :: hdferr        ! Error code
END SUBROUTINE h5tenum_insert_f
	</pre>		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tenum_nameof" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-EnumNameOf">H5Tenum_nameof</a>
<dt><strong>Signature:</strong>
    <dd><em>herr_t</em> <code>H5Tenum_nameof</code>(<em>hid_t</em> <code>type</code>
        <em>void</em> *<code>value</code>,
        <em>char</em> *<code>name</code>,
        <em>size_t</em> <code>size</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Returns the symbol name corresponding to a specified member of an enumeration datatype.
<dt><strong>Description:</strong>
    <dd><code>H5Tenum_nameof</code> finds the symbol name that 
        corresponds to the specified <code>value</code>
        of the enumeration datatype <code>type</code>. 
        <p>
        At most <code>size</code> characters of the symbol 
        name are copied into the <code>name</code> buffer. 
        If the entire symbol name and null terminator 
        do not fit in the <code>name</code> buffer, then as 
        many characters as possible are copied 
        (not null terminated) and the function fails.
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em> <code>type</code></td>
            <td valign="top">IN: Enumeration datatype identifier.</td></tr>
        <tr>
		    <td valign="top"><em>void</em>&nbsp;*<code>value,&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">IN: Value of the enumeration datatype.</td></tr>
        <tr>
		    <td valign="top"><em>char</em> *<code>name</code>,</td>
            <td valign="top">OUT: Buffer for output of the symbol name.</td></tr>
        <tr>
		    <td valign="top"><em>size_t</em> <code>size</code></td>
            <td valign="top">IN: Anticipated size of the symbol name, in bytes (characters).</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns a non-negative value if successful.
        Otherwise returns a negative value 
        and, if <code>size</code> allows it, 
        the first character of <code>name</code> is 
        set to <code>NULL</code>.
<dt><strong>Fortran90 Interface:</strong> h5tenum_nameof_f
    <dd>
	<pre>
SUBROUTINE h5tenum_nameof_f(type_id,  name, namelen, value, hdferr) 
  IMPLICIT NONE
  INTEGER(HID_T), INTENT(IN) :: type_id  ! Datatype identifier 
  CHARACTER(LEN=*), INTENT(OUT) :: name  ! Name of the  enumeration datatype
  INTEGER(SIZE_T), INTENT(IN) :: namelen ! Length of the name
  INTEGER, INTENT(IN) :: value           ! Value of the  enumeration datatype
  INTEGER, INTENT(OUT) :: hdferr         ! Error code
END SUBROUTINE h5tenum_nameof_f
	</pre>		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tenum_valueof" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-EnumValueOf">H5Tenum_valueof</a>
<dt><strong>Signature:</strong>
    <dd><em>herr_t</em> <code>H5Tenum_valueof</code>(<em>hid_t</em> <code>type</code>
        <em>char</em> *<code>name</code>,
        <em>void</em> *<code>value</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Returns the value corresponding to a specified member of an enumeration datatype.
<dt><strong>Description:</strong>
    <dd><code>H5Tenum_valueof</code> finds the value that
        corresponds to the specified <code>name</code>
        of the enumeration datatype <code>type</code>. 
        <p>
        The <code>value</code> argument should be at least
        as large as the value of <code>H5Tget_size(type)</code>
        in order to hold the result.
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em> <code>type</code></td>
            <td valign="top">IN: Enumeration datatype identifier.</td></tr>
        <tr>
		    <td valign="top"><em>const&nbsp;char</em>&nbsp;*<code>name,&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">IN: Symbol name of the enumeration datatype.</td></tr>
        <tr>
		    <td valign="top"><em>void</em> *<code>value</code>,</td>
            <td valign="top">OUT: Buffer for output of the value of the enumeration datatype.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns a non-negative value if successful;
        otherwise returns a negative value.
<dt><strong>Fortran90 Interface:</strong> h5tenum_valueof_f
    <dd>
	<pre>
SUBROUTINE h5tenum_valueof_f(type_id,  name, value, hdferr) 
  IMPLICIT NONE
  INTEGER(HID_T), INTENT(IN) :: type_id ! Datatype identifier 
  CHARACTER(LEN=*), INTENT(IN) :: name  ! Name of the enumeration datatype
  INTEGER, INTENT(OUT) :: value         ! Value of the enumeration datatype
  INTEGER, INTENT(OUT) :: hdferr        ! Error code
END SUBROUTINE h5tenum_valueof_f
	</pre>		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tequal" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-Equal">H5Tequal</a>
<dt><strong>Signature:</strong>
    <dd><em>htri_t </em><code>H5Tequal</code>(<em>hid_t </em><code>type_id1</code>,
        <em>hid_t</em><code>type_id2</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Determines whether two datatype identifiers refer to the same datatype.
<dt><strong>Description:</strong>
    <dd><code>H5Tequal</code> determines whether two datatype identifiers 
        refer to the same datatype.
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em>&nbsp;<code>type_id1&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">Identifier of datatype to compare.</td></tr>
        <tr>
		    <td valign="top"><em>hid_t</em> <code>type_id2</code></td>
            <td valign="top">Identifier of datatype to compare.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>When successful, returns a positive value, for <code>TRUE</code>, 
        if the datatype identifiers refer to the same datatype, 
        or <code>0</code> (zero), for <code>FALSE</code>.
        Otherwise returns a negative value.
<dt><strong>Fortran90 Interface:</strong> h5tequal_f
    <dd>
	<pre>
SUBROUTINE h5tequal_f(type1_id, type2_id, flag, hdferr)
  IMPLICIT NONE
  INTEGER(HID_T), INTENT(IN) :: type1_id ! Datatype identifier 
  INTEGER(HID_T), INTENT(IN) :: type2_id ! Datatype identifier 
  LOGICAL, INTENT(OUT) :: flag           ! TRUE/FALSE flag to indicate 
                                         ! if two datatypes are equal
  INTEGER, INTENT(OUT) :: hdferr         ! Error code
END SUBROUTINE h5tequal_f
	</pre>		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tfind" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-Find">H5Tfind</a>
<dt><strong>Signature:</strong>
    <dd><em>H5T_conv_t</em> <code>H5Tfind</code>(<em>hid_t</em> <code>src_id</code>,
        <em>hid_t</em> <code>dst_id</code>,
        <em>H5T_cdata_t **</em><code>pcdata</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Finds a conversion function.
<dt><strong>Description:</strong>
    <dd><code>H5Tfind</code> finds a conversion function that can 
        handle a conversion from type <code>src_id</code> to type 
        <code>dst_id</code>.
        The <code>pcdata</code> argument is a pointer to a pointer 
        to type conversion data which was created and initialized 
        by the soft type conversion function of this path when the 
        conversion function was installed on the path.
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em> <code>src_id</code></td>
            <td valign="top">IN: Identifier for the source datatype.</td></tr>
        <tr>
		    <td valign="top"><em>hid_t</em> <code>dst_id</code></td>
            <td valign="top">IN: Identifier for the destination datatype.</td></tr>
        <tr>
		    <td valign="top"><em>H5T_cdata_t&nbsp;**</em><code>pcdata&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">OUT: Pointer to type conversion data.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns a pointer to a suitable conversion function if successful.
        Otherwise returns NULL.
<dt><strong>Fortran90 Interface:</strong>
    <dd>None.
<!--
	<pre>
SUBROUTINE
	</pre>		
-->
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tget_array_dims" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-GetArrayDims">H5Tget_array_dims</a>
<dt><strong>Signature:</strong>
    <dd><em>int</em> <code>H5Tget_array_dims</code>(
                       <em>hid_t</em> <code>adtype_id</code>,
                       <em>hsize_t *</em><code>dims[]</code>,
                       <em>int *</em><code>perm[]</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Retrieves sizes of array dimensions and dimension permutations.
<dt><strong>Description:</strong>
    <dd><code>H5Tget_array_dims</code> returns the sizes of the dimensions
        and the dimension permutations of the specified array datatype object.
        <p>
        The sizes of the dimensions are returned in the array <code>dims</code>.
        The dimension permutations, i.e., C versus FORTRAN array order,
        are returned in the array <code>perm</code>.
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em>&nbsp;<code>adtype_id&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">IN: Datatype identifier of array object.</td></tr>
        <tr>
		    <td valign="top"><em>hsize_t *</em><code>dims[]</code></td>
            <td valign="top">OUT: Sizes of array dimensions.</td></tr>
        <tr>
		    <td valign="top"><em>int *</em><code>perm[]</code></td>
            <td valign="top">OUT: Dimension permutations.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns the non-negative number of dimensions of the array type if successful;
        otherwise returns a negative value.
<dt><strong>Fortran90 Interface:</strong> h5tget_array_dims_f
    <dd>
	<pre>
SUBROUTINE h5tget_array_dims_f(type_id, dims, hdferr) 
  IMPLICIT NONE
  INTEGER(HID_T), INTENT(IN) :: type_id      ! Identifier of the array datatype
  INTEGER(HSIZE_T), DIMENSION(*), INTENT(OUT) ::  dims 
                                             ! Buffer to store array datatype
  INTEGER, INTENT(OUT)  :: hdferr            ! Error code
END SUBROUTINE h5tget_array_dims_f
	</pre>		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
  <dt><strong>History:</strong>
	<ul><table width="90%">
        <tr>
		  <td valign="top" align="left" width="10%">
		    <strong>Release</strong>&nbsp;&nbsp;&nbsp;&nbsp;</td>
          <td valign="top" align="left">
		    <strong>C</strong></td></tr>
        <tr>
		  <td valign="top">1.4.0</td>
          <td valign="top">
		    Function introduced in this release.</td></tr>
    </table></ul>
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tget_array_ndims" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-GetArrayNdims">H5Tget_array_ndims</a>
<dt><strong>Signature:</strong>
    <dd><em>int</em> <code>H5Tget_array_ndims</code>(
                       <em>hid_t</em> <code>adtype_id</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Returns the rank of an array datatype.
<dt><strong>Description:</strong>
    <dd><code>H5Tget_array_ndims</code> returns the rank, 
        the number of dimensions, of an array datatype object.
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em>&nbsp;<code>adtype_id&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">IN: Datatype identifier of array object.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns the rank of the array if successful;
        otherwise returns a negative value.
<dt><strong>Fortran90 Interface:</strong> h5tget_array_ndims_f
    <dd>
	<pre>
SUBROUTINE h5tget_array_ndims_f(type_id, ndims, hdferr) 
  IMPLICIT NONE
  INTEGER(HID_T), INTENT(IN) :: type_id  ! Identifier of the array datatype
  INTEGER, INTENT(OUT)       ::  ndims   ! Number of array dimensions
  INTEGER, INTENT(OUT)       :: hdferr   ! Error code
END SUBROUTINE h5tget_array_ndims_f
	</pre>		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
  <dt><strong>History:</strong>
	<ul><table width="90%">
        <tr>
		  <td valign="top" align="left" width="10%">
		    <strong>Release</strong>&nbsp;&nbsp;&nbsp;&nbsp;</td>
          <td valign="top" align="left">
		    <strong>C</strong></td></tr>
        <tr>
		  <td valign="top">1.4.0</td>
          <td valign="top">
		    Function introduced in this release.</td></tr>
    </table></ul>
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tget_class" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-GetClass">H5Tget_class</a>
<dt><strong>Signature:</strong>
    <dd><em>H5T_class_t </em><code>H5Tget_class</code>(<em>hid_t </em><code>type_id</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Returns the datatype class identifier.
<dt><strong>Description:</strong>
    <dd><code>H5Tget_class</code> returns the datatype class identifier.
        <p>
        Valid class identifiers, as defined in <code>H5Tpublic.h</code>, are:
        <ul><li><code>H5T_INTEGER</code>
            <li><code>H5T_FLOAT</code>
            <li><code>H5T_TIME</code>
            <li><code>H5T_STRING</code>
            <li><code>H5T_BITFIELD</code>
            <li><code>H5T_OPAQUE</code>
            <li><code>H5T_COMPOUND</code>
            <li><code>H5T_REFERENCE</code>
            <li><code>H5T_ENUM</code>
            <li><code>H5T_VLEN</code>
            <li><code>H5T_ARRAY</code>
        </ul>
        <p>
        Note that the library returns <code>H5T_STRING</code> for 
        both fixed-length and variable-length strings.
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
            <td valign="top"><em>hid_t</em>&nbsp;<code>type_id&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">Identifier of datatype to query.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns datatype class identifier if successful;
        otherwise <code>H5T_NO_CLASS</code> (-1).
<dt><strong>Fortran90 Interface:</strong> h5tget_class_f
    <dd>
	<pre>
SUBROUTINE h5tget_class_f(type_id, class, hdferr) 
  IMPLICIT NONE
  INTEGER(HID_T), INTENT(IN) :: type_id  ! Datatype identifier 
  INTEGER, INTENT(OUT) :: class          ! Datatype class, possible values are:
                                         !    H5T_NO_CLASS_F 
                                         !    H5T_INTEGER_F 
                                         !    H5T_FLOAT_F
                                         !    H5T_TIME_F
                                         !    H5T_STRING_F
                                         !    H5T_BITFIELD_F
                                         !    H5T_OPAQUE_F
                                         !    H5T_COMPOUND_F
                                         !    H5T_REFERENCE_F
                                         !    H5T_ENUM_F
  INTEGER, INTENT(OUT) :: hdferr         ! Error code
                                         ! 0 on success and -1 on failure
END SUBROUTINE h5tget_class_f
	</pre>		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tget_cset" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-GetCset">H5Tget_cset</a>
<dt><strong>Signature:</strong>
    <dd><em>H5T_cset_t </em><code>H5Tget_cset</code>(<em>hid_t </em><code>type_id</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Retrieves the character set type of a string datatype.
<dt><strong>Description:</strong>
    <dd><code>H5Tget_cset</code> retrieves the character set type 
        of a string datatype.  Valid character set types are:
        <dl><ul>
            <dt>H5T_CSET_ASCII (<code>0</code>)
               <dd>Character set is US ASCII
        </ul></dl>
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em>&nbsp;<code>type_id&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">Identifier of datatype to query.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns a valid character set type if successful;
        otherwise <code>H5T_CSET_ERROR</code> (-1).
<dt><strong>Fortran90 Interface:</strong> h5tget_cset_f
    <dd>
	<pre>
SUBROUTINE h5tget_cset_f(type_id, cset, hdferr) 
  IMPLICIT NONE
  INTEGER(HID_T), INTENT(IN) :: type_id ! Datatype identifier 
  INTEGER, INTENT(OUT) :: cset          ! Character set type of a string 
                                        ! datatype 
                                        ! Possible values of padding type are:
                                        !    H5T_CSET_ASCII_F = 0
  INTEGER, INTENT(OUT) :: hdferr        ! Error code
END SUBROUTINE h5tget_cset_f
	</pre>		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tget_ebias" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-GetEbias">H5Tget_ebias</a>
<dt><strong>Signature:</strong>
    <dd><em>size_t </em><code>H5Tget_ebias</code>(<em>hid_t </em><code>type_id</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Retrieves the exponent bias of a floating-point type.
<dt><strong>Description:</strong>
    <dd><code>H5Tget_ebias</code> retrieves the exponent bias of a floating-point type.
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em>&nbsp;<code>type_id&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">Identifier of datatype to query.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns the bias if successful;
        otherwise 0.
<dt><strong>Fortran90 Interface:</strong> h5tget_ebias_f
    <dd>
	<pre>
SUBROUTINE h5tget_ebias_f(type_id, ebias, hdferr) 
  IMPLICIT NONE
  INTEGER(HID_T), INTENT(IN) :: type_id ! Datatype identifier 
  INTEGER, INTENT(OUT) :: ebias         ! Datatype exponent bias 
                                        ! of a floating-point type
  INTEGER, INTENT(OUT) :: hdferr        ! Error code
END SUBROUTINE h5tget_ebias_f
	</pre>		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tget_fields" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-GetFields">H5Tget_fields</a>
<dt><strong>Signature:</strong>
    <dd><em>herr_t </em><code>H5Tget_fields</code>(<em>hid_t </em><code>type_id</code>,
        <em>size_t *</em><code>spos</code>,
        <em>size_t *</em><code>epos</code>,
        <em>size_t *</em><code>esize</code>,
        <em>size_t *</em><code>mpos</code>,
        <em>size_t *</em><code>msize</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Retrieves floating point datatype bit field information.
<dt><strong>Description:</strong>
    <dd><code>H5Tget_fields</code> retrieves information about the locations of the various
        bit fields of a floating point datatype.  The field positions are bit
        positions in the significant region of the datatype.  Bits are
        numbered with the least significant bit number zero.
        Any (or even all) of the arguments can be null pointers.
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em>&nbsp;<code>type_id&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">IN: Identifier of datatype to query.</td></tr>
        <tr>
		    <td valign="top"><em>size_t *</em><code>spos</code></td>
            <td valign="top">OUT: Pointer to location to return floating-point sign bit.</td></tr>
        <tr>
		    <td valign="top"><em>size_t *</em><code>epos</code></td>
            <td valign="top">OUT: Pointer to location to return exponent bit-position.</td></tr>
        <tr>
		    <td valign="top"><em>size_t *</em><code>esize</code></td>
            <td valign="top">OUT: Pointer to location to return size of exponent in bits.</td></tr>
        <tr>
		    <td valign="top"><em>size_t *</em><code>mpos</code></td>
            <td valign="top">OUT: Pointer to location to return mantissa bit-position.</td></tr>
        <tr>
		    <td valign="top"><em>size_t *</em><code>msize</code></td>
            <td valign="top">OUT: Pointer to location to return size of mantissa in bits.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns a non-negative value if successful;
        otherwise returns a negative value.
<dt><strong>Fortran90 Interface:</strong> h5tget_fields_f
    <dd>
	<pre>
SUBROUTINE h5tget_fields_f(type_id, epos, esize, mpos, msize, hdferr) 
  IMPLICIT NONE
  INTEGER(HID_T), INTENT(IN) :: type_id ! Datatype identifier 
  INTEGER, INTENT(OUT) :: epos          ! Exponent bit-position 
  INTEGER, INTENT(OUT) :: esize         ! Size of exponent in bits
  INTEGER, INTENT(OUT) :: mpos          ! Mantissa bit-position 
  INTEGER, INTENT(OUT) :: msize         ! Size of mantissa in bits
  INTEGER, INTENT(OUT) :: hdferr        ! Error code
END SUBROUTINE h5tget_fields_f
	</pre>		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tget_inpad" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-GetInpad">H5Tget_inpad</a>
<dt><strong>Signature:</strong>
    <dd><em>H5T_pad_t </em><code>H5Tget_inpad</code>(<em>hid_t </em><code>type_id</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Retrieves the internal padding type for unused bits in floating-point datatypes.
<dt><strong>Description:</strong>
    <dd><code>H5Tget_inpad</code> retrieves the internal padding type for 
        unused bits in floating-point datatypes.
        Valid padding types are:
        <ul> <dl>
            <dt>H5T_PAD_ZERO (<code>0</code>)
               <dd>Set background to zeros.
            <dt>H5T_PAD_ONE (<code>1</code>)
               <dd>Set background to ones.
            <dt>H5T_PAD_BACKGROUND (<code>2</code>)
               <dd>Leave background alone.
        </dl> </ul>
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em>&nbsp;<code>type_id&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">Identifier of datatype to query.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns a valid padding type if successful;
        otherwise <code>H5T_PAD_ERROR</code> (-1).
<dt><strong>Fortran90 Interface:</strong> h5tget_inpad_f
    <dd>
	<pre>
SUBROUTINE h5tget_inpad_f(type_id, padtype, hdferr) 
  IMPLICIT NONE
  INTEGER(HID_T), INTENT(IN) :: type_id ! Datatype identifier 
  INTEGER, INTENT(OUT) :: padtype       ! Padding type for unused bits 
                                        ! in floating-point datatypes
                                        ! Possible values of padding type are:
                                        !     H5T_PAD_ZERO_F = 0
                                        !     H5T_PAD_ONE_F = 1
                                        !     H5T_PAD_BACKGROUND_F = 2
  INTEGER, INTENT(OUT) :: hdferr        ! Error code
END SUBROUTINE h5tget_inpad_f
	</pre>		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tget_member_class" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-GetMemberClass">H5Tget_member_class</a>
<dt><strong>Signature:</strong>
    <dd><em>H5T_class_t</em> <code>H5Tget_member_class</code>(
                       <em>hid_t</em> <code>cdtype_id</code>,
                       <em>unsigned </em><code>member_no</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Returns datatype class of compound datatype member.
<dt><strong>Description:</strong>
    <dd>Given a compound datatype, <code>cdtype_id</code>, the function 
        <code>H5Tget_member_class</code> returns the datatype class of 
        the compound datatype member specified by <code>member_no</code>.
        <p>
        Valid class identifiers are as defined in 
	<a href="#Datatype-GetClass"><code>H5Tget_class</code></a>.
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em>&nbsp;<code>cdtype_id&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">IN: Datatype identifier of compound object.</td></tr>
        <tr>
		    <td valign="top"><em>unsigned</em> <code>member_no</code></td>
            <td valign="top">IN: Compound object member number.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns the datatype class, a non-negative value, if successful;
        otherwise returns a negative value.
<dt><strong>Fortran90 Interface:</strong> h5tget_member_class_f
    <dd>
        <pre>
SUBROUTINE h5tget_member_class_f(type_id, member_no, class, hdferr) 
  INTEGER(HID_T), INTENT(IN) :: type_id       ! Datatype identifier 
  INTEGER, INTENT(IN) :: member_no            ! Member number
  INTEGER, INTENT(OUT) :: class               ! Member class
  INTEGER, INTENT(OUT) :: hdferr              ! Error code
END SUBROUTINE h5tget_member_class_f
        </pre>		
        <!--
        <dt><strong>Non-C API(s):</strong>
        <dd>
 
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
<dt><strong>History</strong>:</strong>
    <ul><table width="90%">
        <tr>
		  <td valign="top" align="left" width="10%">
		    <strong>Release</strong>&nbsp;&nbsp;&nbsp;&nbsp;</td>
          <td valign="top" align="left">
		    <strong>C</strong></td></tr>
        <tr>
		  <td valign="top">1.6.4</td>
          <td valign="top">
		    <code>membno</code> parameter type changed to 
			<em>unsigned</em>.</td></tr>
    </table></ul>
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tget_member_index" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-GetMemberIndex">H5Tget_member_index</a>
<dt><strong>Signature:</strong>
    <dd><em>int</em> <code>H5Tget_member_index</code>(<em>hid_t </em><code>type_id</code>,
        <em>const char *</em> <code>field_name</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Retrieves the index of a compound or enumeration datatype member.
<dt><strong>Description:</strong>
    <dd><code>H5Tget_member_index</code> retrieves the index of a field 
        of a compound datatype or an element of an enumeration datatype.  
        <p>
        The name of the target field or element is specified in
        <code>field_name</code>.
        <p>
        Fields are stored in no particular order 
        with index values of 0 through <em>N</em>-1, where <em>N</em> is 
        the value returned by <code>H5Tget_nmembers</code>.  
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em> <code>type_id</code></td>
            <td valign="top">Identifier of datatype to query.</td></tr>
        <tr>
		    <td valign="top"><em>const&nbsp;char&nbsp;*</em>&nbsp;<code>field_name&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">Name of the field or member whose index is to be retrieved.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns a valid field or member index if successful;
        otherwise returns a negative value.
<dt><strong>Fortran90 Interface:</strong> h5tget_member_index_f
    <dd>
        <pre>
SUBROUTINE h5tget_member_index_f(type_id, name, index, hdferr) 
  INTEGER(HID_T), INTENT(IN) :: type_id  ! Datatype identifier 
  CHARACTER(LEN=*), INTENT(IN) :: name   ! Member name
  INTEGER, INTENT(OUT) :: index          ! Member index
  INTEGER, INTENT(OUT) :: hdferr         ! Error code
END SUBROUTINE h5tget_member_index_f
	</pre>		
        <!--
        <dt><strong>Non-C API(s):</strong>
        <dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
  <dt><strong>History</strong>:</strong>
    <ul><table width="90%">
        <tr>
		  <td valign="top" align="left" width="10%">
		    <strong>Release</strong>&nbsp;&nbsp;&nbsp;&nbsp;</td>
          <td valign="top" align="left">
		    <strong>C</strong></td>
		  <td valign="top" align="left">&nbsp;&nbsp;&nbsp;&nbsp;</td>
		  <td valign="top" align="left">
		    <strong>Fortran90</strong></td></tr>
		<tr>
		  <td valign="top">1.4.5</td>
		  <td valign="top">&nbsp;</td>
		  <td valign="top">&nbsp;</td>
		  <td valign="top" align="left">
		    Function introduced in this release.</td></tr>
		<tr>
		  <td valign="top">1.4.4</td>
          <td valign="top">
		    Function introduced in this release.</td>
		  <td valign="top">&nbsp;</td>
		  <td valign="top">&nbsp;</td></tr>
    </table></ul>
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tget_member_name" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-GetMemberName">H5Tget_member_name</a>
<dt><strong>Signature:</strong>
    <dd><em>char *</em> <code>H5Tget_member_name</code>(<em>hid_t </em><code>type_id</code>,
        <em>unsigned</em> <code>field_idx</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Retrieves the name of a compound or enumeration datatype member.
<dt><strong>Description:</strong>
    <dd><code>H5Tget_member_name</code> retrieves the name of a field 
        of a compound datatype or an element of an enumeration datatype.  
        <p>
        The index of the target field or element is specified in
        <code>field_idx</code>.
        Compound datatype fields and enumeration datatype elements 
        are stored in no particular order
        with index values of 0 through <em>N</em>-1, where <em>N</em> 
        is the value returned by <code>H5Tget_nmembers</code>.  
        <p>
        A buffer to receive the name of the field is 
        allocated with <code>malloc()</code> and the caller is responsible 
        for freeing the memory used.
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em>&nbsp;<code>type_id&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">Identifier of datatype to query.</td></tr>
        <tr>
		    <td valign="top"><em>unsigned</em> <code>field_idx</code></td>
            <td valign="top">Zero-based index of the field or element whose name
                is to be retrieved.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns a valid pointer to a string allocated with 
        <code>malloc()</code> if successful; 
        otherwise returns NULL.
<dt><strong>Fortran90 Interface:</strong> h5tget_member_name_f
    <dd>
	<pre>
SUBROUTINE h5tget_member_name_f(type_id,index, member_name,  namelen, hdferr) 
  IMPLICIT NONE
  INTEGER(HID_T), INTENT(IN) :: type_id        ! Datatype identifier 
  INTEGER, INTENT(IN) :: index                 ! Field index (0-based) of 
                                               ! the field name to retrieve 
  CHARACTER(LEN=*), INTENT(OUT) :: member_name ! Name of a field of
                                               ! a compound datatype 
  INTEGER, INTENT(OUT) :: namelen              ! Length of the name 
  INTEGER, INTENT(OUT) :: hdferr               ! Error code
END SUBROUTINE h5tget_member_name_f
	</pre>		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
<dt><strong>History</strong>:</strong>
    <ul><table width="90%">
        <tr>
		  <td valign="top" align="left" width="10%">
		    <strong>Release</strong>&nbsp;&nbsp;&nbsp;&nbsp;</td>
          <td valign="top" align="left">
		    <strong>C</strong></td></tr>
        <tr>
		  <td valign="top">1.6.4</td>
          <td valign="top">
		    <code>membno</code> parameter type changed to 
			<em>unsigned</em>.</td></tr>
    </table></ul>
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tget_member_offset" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-GetMemberOffset">H5Tget_member_offset</a>
<dt><strong>Signature:</strong>
    <dd><em>size_t</em> <code>H5Tget_member_offset</code>(<em>hid_t </em><code>type_id</code>,
        <em>unsigned</em> <code>memb_no</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Retrieves the offset of a field of a compound datatype.
<dt><strong>Description:</strong>
    <dd><code>H5Tget_member_offset</code> retrieves the 
        byte offset of the beginning of a field within a 
        compound datatype with respect to the beginning 
        of the compound data type datum. 
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em>&nbsp;<code>type_id&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">Identifier of datatype to query.</td></tr>
        <tr>
		    <td valign="top"><em>unsigned</em> <code>memb_no</code></td>
            <td valign="top">Number of the field whose offset is requested.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns the byte offset of the field if successful;
        otherwise returns <code>0</code> (zero).
        Note that zero is a valid offset and that this function 
        will fail only if a call to <code>H5Tget_member_class()</code> 
        fails with the same arguments.
<dt><strong>Fortran90 Interface:</strong> h5tget_member_offset_f
    <dd>
	<pre>
SUBROUTINE h5tget_member_offset_f(type_id, member_no, offset, hdferr) 
  IMPLICIT NONE
  INTEGER(HID_T), INTENT(IN) :: type_id    ! Datatype identifier 
  INTEGER, INTENT(IN) :: member_no         ! Number of the field  
                                           ! whose offset is requested
  INTEGER(SIZE_T), INTENT(OUT) :: offset   ! Byte offset of the the 
                                           ! beginning of the field
  INTEGER, INTENT(OUT) :: hdferr           ! Error code
END SUBROUTINE h5tget_member_offset_f
	</pre>		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
<dt><strong>History</strong>:</strong>
    <ul><table width="90%">
        <tr>
		  <td valign="top" align="left" width="10%">
		    <strong>Release</strong>&nbsp;&nbsp;&nbsp;&nbsp;</td>
          <td valign="top" align="left">
		    <strong>C</strong></td></tr>
        <tr>
		  <td valign="top">1.6.4</td>
          <td valign="top">
		    <code>membno</code> parameter type changed to 
			<em>unsigned</em>.</td></tr>
    </table></ul>
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tget_member_type" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-GetMemberType">H5Tget_member_type</a>
<dt><strong>Signature:</strong>
    <dd><em>hid_t</em> <code>H5Tget_member_type</code>(<em>hid_t </em><code>type_id</code>,
        <em>unsigned</em> <code>field_idx</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Returns the datatype of the specified member.
<dt><strong>Description:</strong>
    <dd><code>H5Tget_member_type</code> returns the datatype of the specified member.  The caller
        should invoke H5Tclose() to release resources associated with the type.
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em>&nbsp;<code>type_id&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">Identifier of datatype to query.</td></tr>
        <tr>
		    <td valign="top"><em>unsigned</em> <code>field_idx</code></td>
            <td valign="top">Field index (0-based) of the field type to retrieve.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns the identifier of a copy of the datatype of the field
        if successful;
        otherwise returns a negative value.
<dt><strong>Fortran90 Interface:</strong> h5tget_member_type_f
    <dd>
	<pre>
SUBROUTINE h5tget_member_type_f(type_id,  field_idx, datatype, hdferr) 
  IMPLICIT NONE
  INTEGER(HID_T), INTENT(IN) :: type_id   ! Datatype identifier 
  INTEGER, INTENT(IN) :: field_idx        ! Field index (0-based) of the 
                                          ! field type to retrieve
  INTEGER(HID_T), INTENT(OUT) :: datatype ! Identifier of a copy of 
                                          ! the datatype of the field 
  INTEGER, INTENT(OUT) :: hdferr          ! Error code
END SUBROUTINE h5tget_member_type_f
	</pre>		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
<dt><strong>History</strong>:</strong>
    <ul><table width="90%">
        <tr>
		  <td valign="top" align="left" width="10%">
		    <strong>Release</strong>&nbsp;&nbsp;&nbsp;&nbsp;</td>
          <td valign="top" align="left">
		    <strong>C</strong></td></tr>
        <tr>
		  <td valign="top">1.6.4</td>
          <td valign="top">
		    <code>membno</code> parameter type changed to 
			<em>unsigned</em>.</td></tr>
    </table></ul>
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tget_member_value" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-GetMemberValue">H5Tget_member_value</a>
<dt><strong>Signature:</strong>
    <dd><em>herr_t</em> <code>H5Tget_member_value</code>(<em>hid_t</em> <code>type</code>
        <em>unsigned</em> <code>memb_no</code>,
        <em>void</em> *<code>value</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Returns the value of an enumeration datatype member.
<dt><strong>Description:</strong>
    <dd><code>H5Tget_member_value</code> returns the value of 
        the enumeration datatype member <code>memb_no</code>.
        <p>
        The member value is returned in a user-supplied buffer 
        pointed to by <code>value</code>.
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em> <code>type</code></td>
            <td valign="top">IN: Datatype identifier for the enumeration datatype.</td></tr>
        <tr>
		    <td valign="top"><em>unsigned</em> <code>memb_no</code>,</td>
            <td valign="top">IN: Number of the enumeration datatype member.</td></tr>
        <tr>
		    <td valign="top"><em>void</em>&nbsp;*<code>value&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">OUT: Pointer to a buffer for output of the 
                value of the enumeration datatype member.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns a non-negative value if successful;
        otherwise returns a negative value.
<dt><strong>Fortran90 Interface:</strong> h5tget_member_value_f
    <dd>
	<pre>
SUBROUTINE h5tget_member_value_f(type_id,  member_no, value, hdferr) 
  IMPLICIT NONE
  INTEGER(HID_T), INTENT(IN) :: type_id ! Datatype identifier 
  INTEGER, INTENT(IN) :: member_no      ! Number of the enumeration 
                                        ! datatype member
  INTEGER, INTENT(OUT) :: value         ! Value of the enumeration datatype
  INTEGER, INTENT(OUT) :: hdferr        ! Error code
END SUBROUTINE h5tget_member_value_f
	</pre>		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
<dt><strong>History</strong>:</strong>
    <ul><table width="90%">
        <tr>
		  <td valign="top" align="left" width="10%">
		    <strong>Release</strong>&nbsp;&nbsp;&nbsp;&nbsp;</td>
          <td valign="top" align="left">
		    <strong>C</strong></td></tr>
        <tr>
		  <td valign="top">1.6.4</td>
          <td valign="top">
		    <code>membno</code> parameter type changed to 
			<em>unsigned</em>.</td></tr>
    </table></ul>
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tget_native_type" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-GetNativeType">H5Tget_native_type</a>
<dt><strong>Signature:</strong>
    <dd><em>hid_t</em> <code>H5Tget_native_type</code>(<em>hid_t</em> <code>type_id</code>,
        <em>H5T_direction_t</em> <code>direction</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Returns the native datatype of a specified datatype.
<dt><strong>Description:</strong>
    <dd><code>H5Tget_native_type</code> returns the equivalent native datatype  
        for the datatype specified in <code>type_id</code>.  
        <p>
        <code>H5Tget_native_type</code> is a high-level function designed
	primarily to facilitate use of the <code>H5Dread</code> function,
	for which users otherwise must undertake a multi-step process to 
	determine the native datatype of a dataset prior to reading it 
	into memory.     
        It can be used not only to determine 
	the native datatype for atomic datatypes, 
	but also to determine the native datatypes of the individual components of 
	a compound datatype, an enumerated datatype, an array datatype, or 
        a variable-length datatype.
        <p>
	<code>H5Tget_native_type</code> selects the matching native datatype 
	from the following list:
        <pre>        H5T_NATIVE_CHAR         
        H5T_NATIVE_SHORT        
        H5T_NATIVE_INT          
        H5T_NATIVE_LONG         
        H5T_NATIVE_LLONG        

        H5T_NATIVE_UCHAR
        H5T_NATIVE_USHORT
        H5T_NATIVE_UINT
        H5T_NATIVE_ULONG
        H5T_NATIVE_ULLONG

        H5T_NATIVE_FLOAT
        H5T_NATIVE_DOUBLE
        H5T_NATIVE_LDOUBLE</pre>
        <p>
        The <code>direction</code> parameter indicates the order 
	in which the library searches for a native datatype match.
	Valid values for <code>direction</code> are as follows:
	<table border=0>
	<tr valign=top><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td>
	    <code>H5T_DIR_ASCEND</code></td><td>
	    Searches the above list in ascending size of the datatype,<br>
	    i.e., from top to bottom.  (Default)
	    </td></tr>
	<tr valign=top><td>&nbsp;</td><td>
	    <code>H5T_DIR_DESCEND</code>&nbsp;&nbsp;</td><td>
	    Searches the above list in descending size of the datatype,<br>
	    i.e., from bottom to top.
	    </td></tr>
	</table>
        <p>
	<code>H5Tget_native_type</code> is designed primarily for
	use with intenger and floating point datatypes.
	Time, bifield, opaque, and reference datatypes are returned
	as a copy of <code>type_id</code>.
        <p>
        The identifier returned by <code>H5Tget_native_type</code> 
        should eventually be closed by calling <code>H5Tclose</code> 
        to release resources.    
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em> <code>type_id</code></td>
            <td valign="top">Datatype identifier for the dataset datatype.</td></tr>
        <tr>
		    <td valign="top"><em>H5T_direction_t</em>&nbsp;<code>direction&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">Direction of search.</td></tr>
    </table></ul>
<!-- NEW PAGE -->
<dt><strong>Returns:</strong>
    <dd>Returns the native datatype identifier for the  
        specified dataset datatype if successful;
        otherwise returns a negative value.
<dt><strong>Fortran90 Interface:</strong>
    <dd>None.
<!--
	<pre>
SUBROUTINE
	</pre>
-->		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
<dt><strong>History:</strong>
    <ul><table width="90%">
        <tr>
		  <td valign="top" align="left" width="10%">
		    <strong>Release</strong>&nbsp;&nbsp;&nbsp;&nbsp;</td>
          <td valign="top" align="left">
		    <strong>C</strong></td></tr>
        <tr>
		  <td valign="top">1.6.0</td>
          <td valign="top">
		    Function introduced in this release.</td></tr>
    </table></ul>
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tget_nmembers" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-GetNmembers">H5Tget_nmembers</a>
<dt><strong>Signature:</strong>
    <dd><em>int </em><code>H5Tget_nmembers</code>(<em>hid_t </em><code>type_id</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Retrieves the number of elements in a compound or enumeration datatype.
<dt><strong>Description:</strong>
    <dd><code>H5Tget_nmembers</code> retrieves 
        the number of fields in a compound datatype or 
        the number of members of an enumeration datatype.
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em>&nbsp;<code>type_id&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">Identifier of datatype to query.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns the number of elements if successful;
        otherwise returns a negative value.
<dt><strong>Fortran90 Interface:</strong> h5tget_nmembers_f
    <dd>
	<pre>
SUBROUTINE h5tget_nmembers_f(type_id, num_members, hdferr) 
  IMPLICIT NONE
  INTEGER(HID_T), INTENT(IN) :: type_id ! Datatype identifier 
  INTEGER, INTENT(OUT) :: num_members   ! Number of fields in a 
                                        ! compound datatype 
  INTEGER, INTENT(OUT) :: hdferr        ! Error code
END SUBROUTINE h5tget_nmembers_f
	</pre>		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tget_norm" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-GetNorm">H5Tget_norm</a>
<dt><strong>Signature:</strong>
    <dd><em>H5T_norm_t </em><code>H5Tget_norm</code>(<em>hid_t </em><code>type_id</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Retrieves mantissa normalization of a floating-point datatype.  
<dt><strong>Description:</strong>
    <dd><code>H5Tget_norm</code> retrieves the mantissa normalization of 
        a floating-point datatype.  Valid normalization types are:
        <ul> <dl>
            <dt>H5T_NORM_IMPLIED (<code>0</code>)
                <dd>MSB of mantissa is not stored, always 1
            <dt>H5T_NORM_MSBSET (<code>1</code>)
                <dd>MSB of mantissa is always 1
            <dt>H5T_NORM_NONE (<code>2</code>)
                <dd>Mantissa is not normalized
        </dl> </ul>
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em>&nbsp;<code>type_id&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">Identifier of datatype to query.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns a valid normalization type if successful;
        otherwise <code>H5T_NORM_ERROR</code> (-1).
<dt><strong>Fortran90 Interface:</strong> h5tget_norm_f
    <dd>
	<pre>
SUBROUTINE h5tget_norm_f(type_id, norm, hdferr) 
  IMPLICIT NONE
  INTEGER(HID_T), INTENT(IN) :: type_id  
                                 ! Datatype identifier 
  INTEGER, INTENT(OUT) :: norm   ! Mantissa normalization of a 
                                 ! floating-point datatype
                                 ! Valid normalization types are:
                                 !    H5T_NORM_IMPLIED_F(0) 
                                 !        MSB of mantissa is not 
                                 !        stored, always 1
                                 !    H5T_NORM_MSBSET_F(1) 
                                 !        MSB of mantissa is always 1 
                                 !    H5T_NORM_NONE_F(2) 
                                 !        Mantissa is not normalized
  INTEGER, INTENT(OUT) :: hdferr ! Error code
END SUBROUTINE h5tget_norm_f
	</pre>		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tget_offset" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-GetOffset">H5Tget_offset</a>
<dt><strong>Signature:</strong>
    <dd><em>int </em><code>H5Tget_offset</code>(<em>hid_t </em><code>type_id</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Retrieves the bit offset of the first significant bit.
<dt><strong>Description:</strong>
    <dd><code>H5Tget_offset</code> retrieves the bit offset of the first significant bit.
        The significant bits of an atomic datum can be offset from the beginning
        of the memory for that datum by an amount of padding. The `offset'
        property specifies the number of bits of padding that appear to the
        "right of" the value.  That is, if we have a 32-bit datum with 16-bits
        of precision having the value 0x1122 then it will be laid out in
        memory as (from small byte address toward larger byte addresses):
        <br>
        <br>

      <table border align=center cellpadding=4 width="80%">
        <tr align=center>
          <th width="20%">Byte Position</th>
          <th width="20%">Big-Endian Offset=0</th>
          <th width="20%">Big-Endian Offset=16</th>
          <th width="20%">Little-Endian Offset=0</th>
          <th width="20%">Little-Endian Offset=16</th>
        </tr>  
        <tr align=center>
          <td>0:</td>
          <td>[ pad]</td>
          <td>[0x11]</td>
          <td>[0x22]</td>
          <td>[ pad]</td>
        </tr>
        <tr align=center>
          <td>1:</td>
          <td>[ pad]</td>
          <td>[0x22]</td>
          <td>[0x11]</td>
          <td>[ pad]</td>
        </tr>
        <tr align=center>
          <td>2:</td>
          <td>[0x11]</td>
          <td>[ pad]</td>
          <td>[ pad]</td>
          <td>[0x22]</td>
        </tr>
        <tr align=center>
          <td>3:</td>
          <td>[0x22]</td>
          <td>[ pad]</td>
          <td>[ pad]</td>
          <td>[0x11]</td>
        </tr>
      </table>
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em>&nbsp;<code>type_id&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">Identifier of datatype to query.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns an offset value if successful;
        otherwise returns a negative value.
<dt><strong>Fortran90 Interface:</strong> h5tget_offset_f
    <dd>
	<pre>
SUBROUTINE h5tget_offset_f(type_id, offset, hdferr) 
  IMPLICIT NONE
  INTEGER(HID_T), INTENT(IN) :: type_id ! Datatype identifier 
  INTEGER, INTENT(OUT) :: offset        ! Datatype bit offset of the
                                        ! first significant bit
  INTEGER, INTENT(OUT) :: hdferr        ! Error code
END SUBROUTINE h5tget_offset_f
	</pre>		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tget_order" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-GetOrder">H5Tget_order</a>
<dt><strong>Signature:</strong>
    <dd><em>H5T_order_t </em><code>H5Tget_order</code>(<em>hid_t </em><code>type_id</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Returns the byte order of an atomic datatype.
<dt><strong>Description:</strong>
    <dd><code>H5Tget_order</code> returns the byte order of an 
        atomic datatype.
        <p>
        Possible return values are:
        <ul><dl>
            <dt><code>H5T_ORDER_LE</code> (<code>0</code>)
                <dd>Little endian byte ordering (default).
            <dt><code>H5T_ORDER_BE</code> (<code>1</code>)
                <dd>Big endian byte ordering.
            <dt><code>H5T_ORDER_VAX</code> (<code>2</code>)
                <dd>VAX mixed byte ordering (not currently supported).
        </dl></ul>
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em>&nbsp;<code>type_id&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">Identifier of datatype to query.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns a byte order constant if successful;
        otherwise <code>H5T_ORDER_ERROR</code> (-1).
<dt><strong>Fortran90 Interface:</strong> h5tget_order_f
    <dd>
	<pre>
SUBROUTINE h5tget_order_f(type_id, order, hdferr) 
  IMPLICIT NONE
  INTEGER(HID_T), INTENT(IN) :: type_id ! Datatype identifier 
  INTEGER, INTENT(OUT) :: order         ! Datatype byte order 
                                        ! Possible values are:
                                        !    H5T_ORDER_LE_F 
                                        !    H5T_ORDER_BE_F 
                                        !    H5T_ORDER_VAX_F  
  INTEGER, INTENT(OUT) :: hdferr        ! Error code
                                        ! 0 on success and -1 on failure
END SUBROUTINE h5tget_order_f
	</pre>		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tget_overflow" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-GetOverflow">H5Tget_overflow</a>
<dt><strong>Signature:</strong>


H5Tget_overflow ()
    <dd><em>H5T_overflow_t</em> <code>H5Tget_overflow</code>(<code>void</code>)
<dt><strong>Purpose:</strong>
    <dd>Returns a pointer to the current global overflow function.
<dt><strong>Description:</strong>
    <dd><code>H5Tset_overflow</code> returns a pointer 
        to the current global overflow function.
        This is an application-defined function that is called whenever a 
        datatype conversion causes an overflow. 
<dt><strong>Parameters:</strong>
    <dl>
        <dt>None.
    </dl>
<dt><strong>Returns:</strong>
    <dd>Returns a pointer to an application-defined function if successful.
        Otherwise returns NULL; this can happen if no overflow handling
        function is registered.  
<dt><strong>Fortran90 Interface:</strong>
    <dd>None.
<!--
	<pre>
SUBROUTINE
	</pre>
-->		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tget_pad" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-GetPad">H5Tget_pad</a>
<dt><strong>Signature:</strong>
    <dd><em>herr_t </em><code>H5Tget_pad</code>(<em>hid_t </em><code>type_id</code>,
        <em>H5T_pad_t *</em> <code>lsb</code>,
        <em>H5T_pad_t *</em> <code>msb</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Retrieves the padding type of the least and most-significant bit padding.  
<dt><strong>Description:</strong>
    <dd><code>H5Tget_pad</code> retrieves the padding type of the least and most-significant
        bit padding.  Valid types are:
        <ul> <dl>
            <dt>H5T_PAD_ZERO (<code>0</code>)
               <dd>Set background to zeros.
            <dt>H5T_PAD_ONE (<code>1</code>)
               <dd>Set background to ones.
            <dt>H5T_PAD_BACKGROUND (<code>2</code>)
               <dd>Leave background alone.
        </dl> </ul>
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em> <code>type_id</code></td>
            <td valign="top">IN: Identifier of datatype to query.</td></tr>
        <tr>
		    <td valign="top"><em>H5T_pad_t&nbsp;*</em>&nbsp;<code>lsb&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">OUT: Pointer to location to return least-significant 
                bit padding type.</td></tr>
        <tr>
		    <td valign="top"><em>H5T_pad_t *</em> <code>msb</code></td>
            <td valign="top">OUT: Pointer to location to return most-significant 
                bit padding type.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns a non-negative value if successful;
        otherwise returns a negative value.
<dt><strong>Fortran90 Interface:</strong> h5tget_pad_f
    <dd>
	<pre>
SUBROUTINE h5tget_pad_f(type_id, lsbpad, msbpad, hdferr) 
  IMPLICIT NONE
  INTEGER(HID_T), INTENT(IN) :: type_id ! Datatype identifier 
  INTEGER, INTENT(OUT) :: lsbpad        ! Padding type of the  
                                        ! least significant bit
  INTEGER, INTENT(OUT) :: msbpad        ! Padding type of the 
                                        ! most significant bit
                                        ! Possible values of 
                                        ! padding type are:
                                        !    H5T_PAD_ZERO_F = 0
                                        !    H5T_PAD_ONE_F = 1
                                        !    H5T_PAD_BACKGROUND_F = 2
                                        !    H5T_PAD_ERROR_F = -1
                                        !    H5T_PAD_NPAD_F = 3
  INTEGER, INTENT(OUT) :: hdferr        ! Error code
END SUBROUTINE h5tget_pad_f
	</pre>		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tget_precision" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-GetPrecision">H5Tget_precision</a>
<dt><strong>Signature:</strong>
    <dd><em>size_t </em><code>H5Tget_precision</code>(<em>hid_t </em><code>type_id</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Returns the precision of an atomic datatype.
<dt><strong>Description:</strong>
    <dd><code>H5Tget_precision</code> returns the precision of an atomic datatype.  The
        precision is the number of significant bits which, unless padding is
        present, is 8 times larger than the value returned by H5Tget_size().
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em>&nbsp;<code>type_id&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">Identifier of datatype to query.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns the number of significant bits if successful;
        otherwise 0.
<dt><strong>Fortran90 Interface:</strong> h5tget_precision_f
    <dd>
	<pre>
SUBROUTINE h5tget_precision_f(type_id, precision, hdferr) 
  IMPLICIT NONE
  INTEGER(HID_T), INTENT(IN) :: type_id ! Datatype identifier 
  INTEGER, INTENT(OUT) :: precision     ! Datatype precision
  INTEGER, INTENT(OUT) :: hdferr        ! Error code
END SUBROUTINE h5tget_precision_f
	</pre>		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tget_sign" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-GetSign">H5Tget_sign</a>
<dt><strong>Signature:</strong>
    <dd><em>H5T_sign_t </em><code>H5Tget_sign</code>(<em>hid_t </em><code>type_id</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Retrieves the sign type for an integer type.
<dt><strong>Description:</strong>
    <dd><code>H5Tget_sign</code> retrieves the sign type for an integer type.
        Valid types are:
        <ul> <dl>
            <dt>H5T_SGN_NONE (<code>0</code>)
               <dd>Unsigned integer type.
            <dt>H5T_SGN_2 (<code>1</code>)
               <dd>Two's complement signed integer type.
        </dl> </ul>
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em>&nbsp;<code>type_id&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">Identifier of datatype to query.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns a valid sign type if successful;
        otherwise <code>H5T_SGN_ERROR</code> (-1).
<dt><strong>Fortran90 Interface:</strong> h5tget_sign_f
    <dd>
	<pre>
SUBROUTINE h5tget_sign_f(type_id, sign, hdferr) 
  IMPLICIT NONE
  INTEGER(HID_T), INTENT(IN) :: type_id  ! Datatype identifier 
  INTEGER, INTENT(OUT) :: sign           ! Sign type for an integer type
                                         ! Possible values are:
                                         !    Unsigned integer type 
                                         !        H5T_SGN_NONE_F = 0
                                         !    Two's complement signed 
                                         !        integer type
                                         !        H5T_SGN_2_F = 1
                                         !    or error value
                                         !         H5T_SGN_ERROR_F = -1 
  INTEGER, INTENT(OUT) :: hdferr         ! Error code
END SUBROUTINE h5tget_sign_f
	</pre>		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tget_size" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-GetSize">H5Tget_size</a>
<dt><strong>Signature:</strong>
    <dd><em>size_t </em><code>H5Tget_size</code>(<em>hid_t </em><code>type_id</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Returns the size of a datatype.
<dt><strong>Description:</strong>
    <dd><code>H5Tget_size</code> returns the size of a datatype in bytes.
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em>&nbsp;<code>type_id&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">Identifier of datatype to query.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns the size of the datatype in bytes if successful;
        otherwise 0.
<dt><strong>Fortran90 Interface:</strong> h5tget_size_f
    <dd>
	<pre>
SUBROUTINE h5tget_size_f(type_id, size, hdferr) 
  IMPLICIT NONE
  INTEGER(HID_T), INTENT(IN) :: type_id ! Datatype identifier 
  INTEGER(SIZE_T), INTENT(OUT) :: size  ! Datatype size
  INTEGER, INTENT(OUT) :: hdferr        ! Error code
                                        ! 0 on success and -1 on failure
END SUBROUTINE h5tget_size_f
	</pre>		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tget_strpad" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-GetStrpad">H5Tget_strpad</a>
<dt><strong>Signature:</strong>
    <dd><em>H5T_str_t </em><code>H5Tget_strpad</code>(<em>hid_t </em><code>type_id</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Retrieves the storage mechanism for a string datatype.
<dt><strong>Description:</strong>
    <dd><code>H5Tget_strpad</code> retrieves the storage mechanism
        for a string datatype, as defined in 
        <a href="#Datatype-SetStrpad"><code>H5Tset_strpad</code></a>.
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em>&nbsp;<code>type_id&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">Identifier of datatype to query.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns a valid string storage mechanism if successful;
        otherwise <code>H5T_STR_ERROR</code> (-1).
<dt><strong>Fortran90 Interface:</strong> h5tget_strpad_f
    <dd>
	<pre>
SUBROUTINE h5tget_strpad_f(type_id, strpad, hdferr) 
  IMPLICIT NONE
  INTEGER(HID_T), INTENT(IN) :: type_id    
                                  ! Datatype identifier 
  INTEGER, INTENT(OUT) :: strpad  ! String padding method for a string datatype 
                                  ! Possible values of padding type are:
                                  !    Pad with zeros (as C does): 
                                  !        H5T_STR_NULLPAD_F(0) 
                                  !    Pad with spaces (as FORTRAN does): 
                                  !        H5T_STR_SPACEPAD_F(1)
  INTEGER, INTENT(OUT) :: hdferr  ! Error code
END SUBROUTINE h5tget_strpad_f
	</pre>		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tget_super" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-GetSuper">H5Tget_super</a>
<dt><strong>Signature:</strong>
    <dd><em>hid_t</em> <code>H5Tget_super</code>(<em>hid_t</em> <code>type</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Returns the base datatype from which a datatype is derived.
<dt><strong>Description:</strong>
    <dd><code>H5Tget_super</code> returns the base datatype from which the 
        datatype <code>type</code> is derived.  
        <P>
        In the case of an enumeration type, the return value is an integer type.
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em>&nbsp;<code>type&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">Datatype identifier for the derived datatype.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns the datatype identifier for the base datatype if successful;
        otherwise returns a negative value.
<dt><strong>Fortran90 Interface:</strong> h5tget_super_f
    <dd>
	<pre>
SUBROUTINE h5tget_super_f(type_id, base_type_id, hdferr) 
  IMPLICIT NONE
  INTEGER(HID_T), INTENT(IN) :: type_id  ! Datatype identifier 
  INTEGER(HID_T), INTENT(OUT) :: type_id ! Base datatype identifier 
  INTEGER, INTENT(OUT) :: hdferr         ! Error code
END SUBROUTINE h5tget_super_f
	</pre>		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tget_tag" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-GetTag">H5Tget_tag</a>
<dt><strong>Signature:</strong>
    <dd><em>char</em> *<code>H5Tget_tag</code>(<em>hid_t</em> <code>type_id</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Gets the tag associated with an opaque datatype.
<dt><strong>Description:</strong>
    <dd><code>H5Tget_tag</code> returns the tag associated with 
        the opaque datatype <code>type_id</code>.
        <P>
        The tag is returned via a pointer to an 
        allocated string, which the caller must free.
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em>&nbsp;<code>type_id&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">Datatype identifier for the opaque datatype.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns a pointer to an allocated string if successful;
        otherwise returns <code>NULL</code>.
<dt><strong>Fortran90 Interface:</strong> h5tget_tag_f
    <dd>
	<pre>
SUBROUTINE h5tget_tag_f(type_id, tag,taglen, hdferr) 
  IMPLICIT NONE
  INTEGER(HID_T), INTENT(IN) :: type_id  ! Datatype identifier 
  CHARACTER(LEN=*), INTENT(OUT) :: tag   ! Unique ASCII string with which the
                                         ! opaque datatype is to be tagged
  INTEGER, INTENT(OUT) :: taglen         ! Length of tag 
  INTEGER, INTENT(OUT) :: hdferr         ! Error code
END SUBROUTINE h5tget_tag_f
	</pre>		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tinsert" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-Insert">H5Tinsert</a>
<dt><strong>Signature:</strong>
    <dd><em>herr_t</em> <code>H5Tinsert</code>(<em>hid_t </em><code>type_id</code>,
        <em>const char *</em> <code>name</code>,
        <em>size_t</em> <code>offset</code>,
        <em>hid_t</em> <code>field_id</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Adds a new member to a compound datatype.
<dt><strong>Description:</strong>
    <dd><code>H5Tinsert</code> adds another member to the compound datatype
        <code>type_id</code>.  The new member has a <code>name</code> which
        must be unique within the compound datatype. 
        The <code>offset</code> argument defines the start of the member 
        in an instance of the compound datatype, and <code>field_id</code> 
        is the datatype identifier of the new member.
        <P>
        Note: Members of a compound datatype do not have to be atomic datatypes; 
        a compound datatype can have a member which is a compound datatype.
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em> <code>type_id</code></td>
            <td valign="top">Identifier of compound datatype to modify.</td></tr>
        <tr>
		    <td valign="top"><em>const&nbsp;char&nbsp;*</em>&nbsp;<code>name&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">Name of the field to insert.</td></tr>
        <tr>
		    <td valign="top"><em>size_t</em> <code>offset</code></td>
            <td valign="top">Offset in memory structure of the field to insert.</td></tr>
        <tr>
		    <td valign="top"><em>hid_t</em> <code>field_id</code></td>
            <td valign="top">Datatype identifier of the field to insert.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns a non-negative value if successful;
        otherwise returns a negative value.
<dt><strong>Fortran90 Interface:</strong> h5tinsert_f
    <dd>
	<pre>
SUBROUTINE h5tinsert_f(type_id,  name, offset, field_id, hdferr) 
  IMPLICIT NONE
  INTEGER(HID_T), INTENT(IN) :: type_id  ! Datatype identifier 
  CHARACTER(LEN=*), INTENT(IN) :: name   ! Name of the field to insert
  INTEGER(SIZE_T), INTENT(IN) :: offset  ! Offset in memory structure 
                                         ! of the field to insert
  INTEGER(HID_T), INTENT(IN) :: field_id ! Datatype identifier of the 
                                         ! new member
  INTEGER, INTENT(OUT) :: hdferr         ! Error code
END SUBROUTINE h5tinsert_f
	</pre>		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tis_variable_str" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-IsVariableString">H5Tis_variable_str</a>
<dt><strong>Signature:</strong>
    <dd><em>htri_t </em><code>H5Tis_variable_str</code>(<em>hid_t </em><code>dtype_id</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Determines whether datatype is a variable-length string.  
<dt><strong>Description:</strong>
    <dd><code>H5Tvlen_create</code> determines whether the datatype 
        identified in <code>dtype_id</code> is a variable-length string.
        <p>
        This function can be used to distinguish between 
        fixed and variable-length string datatypes.
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em>&nbsp;<code>dtype_id&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">Datatype identifier.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns <code>TRUE</code> or <code>FALSE</code> if successful;
        otherwise returns a negative value.
<dt><strong>Fortran90 Interface:</strong> h5tis_variable_str_f
    <dd>
	<pre>
SUBROUTINE h5tis_variable_str_f(type_id, status, hdferr) 
  IMPLICIT NONE
  INTEGER(HID_T), INTENT(IN) :: type_id   ! Datatype identifier 
  LOGICAL, INTENT(OUT)       :: status    ! Logical flag:
                                          !    .TRUE. if datatype is a 
                                          !         varibale string
                                          !    .FALSE. otherwise 
  INTEGER, INTENT(OUT) :: hdferr          ! Error code
END SUBROUTINE h5tis_variable_str_f
	</pre>		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
<dt><strong>History:</strong>
    <ul><table width="90%">
        <tr>
		  <td valign="top" align="left" width="10%">
		    <strong>Release</strong>&nbsp;&nbsp;&nbsp;&nbsp;</td>
          <td valign="top" align="left">
		    <strong>C</strong></td></tr>
        <tr>
		  <td valign="top">1.6.0</td>
          <td valign="top">
		    Function introduced in this release.</td></tr>
    </table></ul>
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tlock" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-Lock">H5Tlock</a>
<dt><strong>Signature:</strong>
    <dd><em>herr_t </em><code>H5Tlock</code>(<em>hid_t </em><code>type_id</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Locks a datatype.
<dt><strong>Description:</strong>
    <dd><code>H5Tlock</code> locks the datatype specified by the 
        <code>type_id</code> identifier, making it read-only and 
        non-destructible.  This is normally done by the library for 
        predefined datatypes so the application does not 
        inadvertently change or delete a predefined type.  
        Once a datatype is locked it can never be unlocked.
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em>&nbsp;<code>type_id&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">Identifier of datatype to lock.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns a non-negative value if successful;
        otherwise returns a negative value.
<dt><strong>Fortran90 Interface:</strong>
    <dd>None.
<!--
	<pre>
SUBROUTINE
	</pre>		
-->
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Topen" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-Open">H5Topen</a>
<dt><strong>Signature:</strong>
    <dd><em>hid_t</em><code>H5Topen</code>(<em>hid_t</em> <code>loc_id</code>,
        <em>const char *</em> <code>name</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Opens a named datatype.
<dt><strong>Description:</strong>
    <dd><code>H5Topen</code> opens a named datatype at the location
        specified by <code>loc_id</code> and returns an identifier 
        for the datatype.  <code>loc_id</code> is either a file or 
        group identifier.  The identifier should eventually be closed 
        by calling <code>H5Tclose</code> to release resources.    
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em> <code>loc_id</code></td>
            <td valign="top">IN: A file or group identifier.</td></tr>
        <tr>
		    <td valign="top"><em>const&nbsp;char&nbsp;*</em>&nbsp;<code>name&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">IN: A datatype name, defined within the file 
			  or group identified by <code>loc_id</code>.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns a named datatype identifier if successful;
        otherwise returns a negative value.
<dt><strong>Fortran90 Interface:</strong> h5topen_f
    <dd>
	<pre>
SUBROUTINE h5topen_f(loc_id, name, type_id, hdferr) 
  IMPLICIT NONE
  INTEGER(HID_T), INTENT(IN) :: loc_id    ! File or group identifier 
  CHARACTER(LEN=*), INTENT(IN) :: name    ! Datatype name within file or
                                          ! group
  INTEGER(HID_T), INTENT(out) :: type_id  ! Datatype identifier 
  INTEGER, INTENT(OUT) :: hdferr          ! Error code
                                          ! 0 on success and -1 on failure
END SUBROUTINE h5topen_f
	</pre>		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tpack" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-Pack">H5Tpack</a>
<dt><strong>Signature:</strong>
    <dd><em>herr_t</em> <code>H5Tpack</code>(<em>hid_t </em><code>type_id</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Recursively removes padding from within a compound datatype.
<dt><strong>Description:</strong>
    <dd><code>H5Tpack</code> recursively removes padding from within a compound
        datatype to make it more efficient (space-wise) to store that data.
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em>&nbsp;<code>type_id&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">Identifier of datatype to modify.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns a non-negative value if successful;
        otherwise returns a negative value.
<dt><strong>Fortran90 Interface:</strong> h5tpack_f
    <dd>
	<pre>
SUBROUTINE h5tpack_f(type_id, hdferr) 
  IMPLICIT NONE
  INTEGER(HID_T), INTENT(IN) :: type_id ! Datatype identifier
  INTEGER, INTENT(OUT) :: hdferr        ! Error code
END SUBROUTINE h5tpack_f
	</pre>		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tregister" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-Register">H5Tregister</a>
<dt><strong>Signature:</strong>
    <dd><em>herr_t</em> <code>H5Tregister</code>(<em>H5T_pers_t</em> <code>pers</code>, 
        <em>const char *</em> <code>name</code>, 
        <em>hid_t </em><code>src_id</code>,
        <em>hid_t</em> <code>dst_id</code>,
        <em>H5T_conv_t</em> <code>func</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Registers a conversion function.
<dt><strong>Description:</strong>
    <dd><code>H5Tregister</code> registers a hard or soft conversion function 
        for a datatype conversion path.  
        <p>
        The parameter <code>pers</code> indicates whether a conversion function 
        is <em>hard</em> (<code>H5T_PERS_HARD</code>) 
        or <em>soft</em> (<code>H5T_PERS_SOFT</code>).
        <p>
        A conversion path can have only one hard function.
        When <code>pers</code> is <code>H5T_PERS_HARD</code>, 
        <code>func</code> replaces any previous hard function.
        If  <code>pers</code> is <code>H5T_PERS_HARD</code> and 
        <code>func</code> is the null pointer, then any hard function 
        registered for this path is removed.  
        <p>
        When <code>pers</code> is <code>H5T_PERS_SOFT</code>, 
        <code>H5Tregister</code> 
        adds the function to the end of the master soft list and replaces 
        the soft function in all applicable existing conversion paths. 
        Soft functions are used when determining which conversion function 
        is appropriate for this path.  
        <p>
        The <code>name</code> is used only for debugging and should be a 
        short identifier for the function.  
        <p>
        The path is specified by the source and destination datatypes 
        <code>src_id</code> and <code>dst_id</code>.  
        For soft conversion functions, only the class of these types is important.
        <p>
        The type of the conversion function pointer is declared as:
        <dir>
<pre><code>typedef</code> <em>herr_t </em>(<code>*H5T_conv_t</code>) (<em>hid_t </em><code>src_id</code>, 
                              <em>hid_t </em><code>dst_id</code>, 
                              <em>H5T_cdata_t *</em><code>cdata</code>,
                              <em>size_t </em><code>nelmts</code>, 
                              <em>size_t </em><code>buf_stride</code>, 
                              <em>size_t </em><code>bkg_stride</code>, 
                              <em>void *</em><code>buf</code>, 
                              <em>void *</em><code>bkg</code>,
                              <em>hid_t </em><code>dset_xfer_plist</code>)</pre>
        </dir>
        <p>
        The <code>H5T_cdata_t</code> struct is declared as:
        <dir>
<pre><code>typedef</code> <em>struct </em><code>*H5T_cdata_t</code> (<em>H5T_cmd_t </em><code>command</code>, 
                             <em>H5T_bkg_t </em><code>need_bkg</code>, 
                             <em>hbool_t *</em><code>recalc</code>,
                             <em>void *</em><code>priv</code>)</pre>
        </dir>
        <p>
        The <code>H5T_conv_t</code> parameters and 
        the elements of the <code>H5T_cdata_t</code> struct
        are described more fully in the 
        &ldquo;<a href="Datatypes.html#Datatypes-DataConversion" 
        target="WinUG">Data Conversion</a>&rdquo; 
        section of&nbsp; &ldquo;The Datatype Interface (H5T)&rdquo; 
        in the <cite>HDF5 User's Guide</cite>.
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>H5T_pers_t</em> <code>pers</code></td>
            <td valign="top"><code>H5T_PERS_HARD</code> for hard conversion functions;
                <code>H5T_PERS_SOFT</code> for soft conversion functions.</td></tr>
        <tr>
		    <td valign="top"><em>const char *</em> <code>name</code></td>
            <td valign="top">Name displayed in diagnostic output.</td></tr>
        <tr>
		    <td valign="top"><em>hid_t</em> <code>src_id</code></td>
            <td valign="top">Identifier of source datatype.</td></tr>
        <tr>
		    <td valign="top"><em>hid_t</em> <code>dst_id</code></td>
            <td valign="top">Identifier of destination datatype.</td></tr>
        <tr>
		    <td valign="top"><em>H5T_conv_t</em>&nbsp;<code>func&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">Function to convert between source and destination datatypes.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns a non-negative value if successful;
        otherwise returns a negative value.
<dt><strong>Fortran90 Interface:</strong>
    <dd>None.
<!--
	<pre>
SUBROUTINE
	</pre>		
-->
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
<dt><strong>History:</strong>
    <ul><table width="90%">
        <tr>
		  <td valign="top" align="left" width="10%">
		    <strong>Release</strong>&nbsp;&nbsp;&nbsp;&nbsp;</td>
          <td valign="top" align="left">
		    <strong>C</strong></td></tr>
        <tr>
		  <td valign="top">1.6.3</td>
          <td valign="top">
			The following change occurred in the 
			<code>H5Tconv_t</code> function:<br>
                        &nbsp;&nbsp;
			<code>nelmts</code> parameter type changed to 
			<em>size_t</em>.</td></tr>
    </table></ul>
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tset_cset" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-SetCset">H5Tset_cset</a>
<dt><strong>Signature:</strong>
    <dd><em>herr_t </em><code>H5Tset_cset</code>(<em>hid_t </em><code>type_id</code>,
        <em>H5T_cset_t</em> <code>cset</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Sets character set to be used.
<dt><strong>Description:</strong>
    <dd><code>H5Tset_cset</code> the character set to be used.
        <p>
        HDF5 is able to distinguish between character sets of different
        nationalities and to convert between them to the extent possible.
        Valid character set types are:
        <ul> <dl>
            <dt>H5T_CSET_ASCII (<code>0</code>)
               <dd>Character set is US ASCII.
        </dl> </ul>
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em> <code>type_id</code></td>
            <td valign="top">Identifier of datatype to modify.</td></tr>
        <tr>
		    <td valign="top"><em>H5T_cset_t</em>&nbsp;<code>cset&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">Character set type.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns a non-negative value if successful;
        otherwise returns a negative value.
<dt><strong>Fortran90 Interface:</strong> h5tset_cset_f
    <dd>
	<pre>
SUBROUTINE h5tset_cset_f(type_id, cset, hdferr) 
  IMPLICIT NONE
  INTEGER(HID_T), INTENT(IN) :: type_id 
                                  ! Datatype identifier 
  INTEGER, INTENT(IN) :: cset     ! Character set type of a string datatype  
                                  ! Possible values of padding type are:
                                  !    H5T_CSET_ASCII_F = 0
  INTEGER, INTENT(OUT) :: hdferr  ! Error code
END SUBROUTINE h5tset_cset_f
	</pre>		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tset_ebias" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-SetEbias">H5Tset_ebias</a>
<dt><strong>Signature:</strong>
    <dd><em>herr_t </em><code>H5Tset_ebias</code>(<em>hid_t </em><code>type_id</code>,
        <em>size_t</em> <code>ebias</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Sets the exponent bias of a floating-point type.
<dt><strong>Description:</strong>
    <dd><code>H5Tset_ebias</code> sets the exponent bias of a floating-point type.
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em>&nbsp;<code>type_id&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">Identifier of datatype to set.</td></tr>
        <tr>
		    <td valign="top"><em>size_t</em> <code>ebias</code></td>
            <td valign="top">Exponent bias value.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns a non-negative value if successful;
        otherwise returns a negative value.
<dt><strong>Fortran90 Interface:</strong> h5tset_ebias_f
    <dd>
	<pre>
SUBROUTINE h5tset_ebias_f(type_id, ebias, hdferr) 
  IMPLICIT NONE
  INTEGER(HID_T), INTENT(IN) :: type_id ! Datatype identifier 
  INTEGER, INTENT(IN) :: ebias          ! Datatype exponent bias 
                                        ! of a floating-point type, 
                                        ! which cannot be 0
  INTEGER, INTENT(OUT) :: hdferr        ! Error code
END SUBROUTINE h5tset_ebias_f
	</pre>		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tset_fields" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-SetFields">H5Tset_fields</a>
<dt><strong>Signature:</strong>
    <dd><em>herr_t </em><code>H5Tset_fields</code>(<em>hid_t </em><code>type_id</code>,
        <em>size_t</em> <code>spos</code>,
        <em>size_t</em> <code>epos</code>,
        <em>size_t</em> <code>esize</code>,
        <em>size_t</em> <code>mpos</code>,
        <em>size_t</em> <code>msize</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Sets locations and sizes of floating point bit fields.  
<dt><strong>Description:</strong>
    <dd><code>H5Tset_fields</code> sets the locations and sizes of the various
        floating-point bit fields.  The field positions are bit positions in the
        significant region of the datatype.  Bits are numbered with the least
        significant bit number zero.
    
        <P>Fields are not allowed to extend beyond the number of bits of
        precision, nor are they allowed to overlap with one another.
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em>&nbsp;<code>type_id&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">Identifier of datatype to set.</td></tr>
        <tr>
		    <td valign="top"><em>size_t</em> <code>spos</code></td>
            <td valign="top">Sign position, i.e., the bit offset of the floating-point 
                sign bit.</td></tr>
        <tr>
		    <td valign="top"><em>size_t</em> <code>epos</code></td>
            <td valign="top">Exponent bit position.</td></tr>
        <tr>
		    <td valign="top"><em>size_t</em> <code>esize</code></td>
            <td valign="top">Size of exponent in bits.</td></tr>
        <tr>
		    <td valign="top"><em>size_t</em> <code>mpos</code></td>
            <td valign="top">Mantissa bit position.</td></tr>
        <tr>
		    <td valign="top"><em>size_t</em> <code>msize</code></td>
            <td valign="top">Size of mantissa in bits.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns a non-negative value if successful;
        otherwise returns a negative value.
<dt><strong>Fortran90 Interface:</strong> h5tset_fields_f
    <dd>
	<pre>
SUBROUTINE h5tset_fields_f(type_id, epos, esize, mpos, msize, hdferr) 
  IMPLICIT NONE
  INTEGER(HID_T), INTENT(IN) :: type_id ! Datatype identifier
  INTEGER, INTENT(IN) :: epos           ! Exponent bit-position 
  INTEGER, INTENT(IN) :: esize          ! Size of exponent in bits
  INTEGER, INTENT(IN) :: mpos           ! Mantissa bit-position 
  INTEGER, INTENT(IN) :: msize          ! Size of mantissa in bits
  INTEGER, INTENT(OUT) :: hdferr        ! Error code
END SUBROUTINE h5tset_fields_f
	</pre>		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tset_inpad" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-SetInpad">H5Tset_inpad</a>
<dt><strong>Signature:</strong>
    <dd><em>herr_t </em><code>H5Tset_inpad</code>(<em>hid_t </em><code>type_id</code>,
        <em>H5T_pad_t</em> <code>inpad</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Fills unused internal floating point bits.
<dt><strong>Description:</strong>
    <dd>If any internal bits of a floating point type are unused
        (that is, those significant bits which are not part of the
        sign, exponent, or mantissa), then <code>H5Tset_inpad</code> will be filled
        according to the value of the padding value property <code>inpad</code>.
        Valid padding types are:
        <ul> <dl>
            <dt>H5T_PAD_ZERO (<code>0</code>)
               <dd>Set background to zeros.
            <dt>H5T_PAD_ONE (<code>1</code>)
               <dd>Set background to ones.
            <dt>H5T_PAD_BACKGROUND (<code>2</code>)
               <dd>Leave background alone.
        </dl> </ul>
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em> <code>type_id</code></td>
            <td valign="top">Identifier of datatype to modify.</td></tr>
        <tr>
		    <td valign="top"><em>H5T_pad_t</em>&nbsp;<code>pad&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">Padding type.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns a non-negative value if successful;
        otherwise returns a negative value.
<dt><strong>Fortran90 Interface:</strong> h5tset_inpad_f
    <dd>
	<pre>
SUBROUTINE h5tset_inpad_f(type_id, padtype, hdferr)
  IMPLICIT NONE
  INTEGER(HID_T), INTENT(IN) :: type_id 
                                  ! Datatype identifier 
  INTEGER, INTENT(IN) :: padtype  ! Padding type for unused bits 
                                  ! in floating-point datatypes.
                                  ! Possible values of padding type are:
                                  !    H5T_PAD_ZERO_F = 0
                                  !    H5T_PAD_ONE_F = 1
                                  !    H5T_PAD_BACKGROUND_F = 2
  INTEGER, INTENT(OUT) :: hdferr  ! Error code
END SUBROUTINE h5tset_inpad_f
	</pre>		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tset_norm" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-SetNorm">H5Tset_norm</a>
<dt><strong>Signature:</strong>
    <dd><em>herr_t </em><code>H5Tset_norm</code>(<em>hid_t </em><code>type_id</code>,
        <em>H5T_norm_t</em> <code>norm</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Sets the mantissa normalization of a floating-point datatype.  
<dt><strong>Description:</strong>
    <dd><code>H5Tset_norm</code> sets the mantissa normalization of 
        a floating-point datatype.  Valid normalization types are:
        <ul> <dl>
            <dt>H5T_NORM_IMPLIED (<code>0</code>)
                <dd>MSB of mantissa is not stored, always 1
            <dt>H5T_NORM_MSBSET (<code>1</code>)
                <dd>MSB of mantissa is always 1
            <dt>H5T_NORM_NONE (<code>2</code>)
                <dd>Mantissa is not normalized
        </dl> </ul>
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em> <code>type_id</code></td>
            <td valign="top">Identifier of datatype to set.</td></tr>
        <tr>
		    <td valign="top"><em>H5T_norm_t</em>&nbsp;<code>norm&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">Mantissa normalization type.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns a non-negative value if successful;
        otherwise returns a negative value.
<dt><strong>Fortran90 Interface:</strong> h5tset_norm_f
    <dd>
	<pre>
SUBROUTINE h5tset_norm_f(type_id, norm, hdferr) 
  IMPLICIT NONE
  INTEGER(HID_T), INTENT(IN) :: type_id  
                                  ! Datatype identifier 
  INTEGER, INTENT(IN) :: norm     ! Mantissa normalization of a 
                                  ! floating-point datatype
                                  ! Valid normalization types are:
                                  !    H5T_NORM_IMPLIED_F(0)
                                  !       MSB of mantissa is not stored,
                                  !       always 1 
                                  !    H5T_NORM_MSBSET_F(1) 
                                  !       MSB of mantissa is always 1 
                                  !    H5T_NORM_NONE_F(2)
                                  !       Mantissa is not normalized
  INTEGER, INTENT(OUT) :: hdferr  ! Error code
END SUBROUTINE h5tset_norm_f
	</pre>		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tset_offset" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-SetOffset">H5Tset_offset</a>
<dt><strong>Signature:</strong>
    <dd><em>herr_t </em><code>H5Tset_offset</code>(<em>hid_t </em><code>type_id</code>,
        <em>size_t</em> <code>offset</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Sets the bit offset of the first significant bit.
<dt><strong>Description:</strong>
    <dd><code>H5Tset_offset</code> sets the bit offset of the first significant bit.  The
        significant bits of an atomic datum can be offset from the beginning of
        the memory for that datum by an amount of padding. The `offset'
        property specifies the number of bits of padding that appear to the
        "right of" the value.  That is, if we have a 32-bit datum with 16-bits
        of precision having the value 0x1122 then it will be laid out in
        memory as (from small byte address toward larger byte addresses):
        <br>
        <br>

      <table border align=center cellpadding=4 width="80%">
        <tr align=center>
          <th width="20%">Byte Position</th>
          <th width="20%">Big-Endian Offset=0</th>
          <th width="20%">Big-Endian Offset=16</th>
          <th width="20%">Little-Endian Offset=0</th>
          <th width="20%">Little-Endian Offset=16</th>
        </tr>  
        <tr align=center>
          <td>0:</td>
          <td>[ pad]</td>
          <td>[0x11]</td>
          <td>[0x22]</td>
          <td>[ pad]</td>
        </tr>
        <tr align=center>
          <td>1:</td>
          <td>[ pad]</td>
          <td>[0x22]</td>
          <td>[0x11]</td>
          <td>[ pad]</td>
        </tr>
        <tr align=center>
          <td>2:</td>
          <td>[0x11]</td>
          <td>[ pad]</td>
          <td>[ pad]</td>
          <td>[0x22]</td>
        </tr>
        <tr align=center>
          <td>3:</td>
          <td>[0x22]</td>
          <td>[ pad]</td>
          <td>[ pad]</td>
          <td>[0x11]</td>
        </tr>
      </table>

<P>If the offset is incremented then the total size is
incremented also if necessary to prevent significant bits of
the value from hanging over the edge of the datatype.

<P>The offset of an H5T_STRING cannot be set to anything but
zero.
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em>&nbsp;<code>type_id&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">Identifier of datatype to set.</td></tr>
        <tr>
		    <td valign="top"><em>size_t</em> <code>offset</code></td>
            <td valign="top">Offset of first significant bit.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns a non-negative value if successful;
        otherwise returns a negative value.
<dt><strong>Fortran90 Interface:</strong> h5tset_offset_f
    <dd>
	<pre>
SUBROUTINE h5tset_offset_f(type_id, offset, hdferr) 
  IMPLICIT NONE
  INTEGER(HID_T), INTENT(IN) :: type_id ! Datatype identifier 
  INTEGER, INTENT(IN) :: offset         ! Datatype bit offset of 
                                        ! the first significant bit
  INTEGER, INTENT(OUT) :: hdferr        ! Error code
END SUBROUTINE h5tset_offset_f
	</pre>		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tset_order" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-SetOrder">H5Tset_order</a>
<dt><strong>Signature:</strong>
    <dd><em>herr_t </em><code>H5Tset_order</code>(<em>hid_t </em><code>type_id</code>,
        <em>H5T_order_t</em><code>order</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Sets the byte ordering of an atomic datatype.
<dt><strong>Description:</strong>
    <dd><code>H5Tset_order</code> sets the byte ordering of an atomic datatype.
        Byte orderings currently supported are:
        <ul> <dl>
            <dt>H5T_ORDER_LE (<code>0</code>)
                <dd> Little-endian byte ordering (default).
            <dt>H5T_ORDER_BE (<code>1</code>)
                <dd> Big-endian byte ordering.
            <dt>H5T_ORDER_VAX (<code>2</code>)
                <dd>VAX mixed byte ordering (not currently supported).
        </dl> </ul>
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em> <code>type_id</code></td>
            <td valign="top">Identifier of datatype to set.</td></tr>
        <tr>
		    <td valign="top"><em>H5T_order_t</em>&nbsp;<code>order&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">Byte ordering constant.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns a non-negative value if successful;
        otherwise returns a negative value.
<dt><strong>Fortran90 Interface:</strong> h5tset_order_f
    <dd>
	<pre>
SUBROUTINE h5tset_order_f(type_id, order, hdferr) 
  IMPLICIT NONE
  INTEGER(HID_T), INTENT(IN) :: type_id   ! Datatype identifier 
  INTEGER, INTENT(IN) :: order            ! Datatype byte order 
                                          ! Possible values are:
                                          !    H5T_ORDER_LE_F 
                                          !    H5T_ORDER_BE_F 
                                          !    H5T_ORDER_VAX_F  
  INTEGER, INTENT(OUT) :: hdferr          ! Error code
                                          ! 0 on success and -1 on failure
END SUBROUTINE h5tset_order_f
	</pre>		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tset_overflow" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-SetOverflow">H5Tset_overflow</a>
<dt><strong>Signature:</strong>
    <dd><em>herr_t</em> <code>H5Tset_overflow</code>(<em>H5T_overflow_t</em> <code>func</code>)
<dt><strong>Purpose:</strong>
    <dd>Sets the overflow handler to a specified function. 
<dt><strong>Description:</strong>
    <dd><code>H5Tset_overflow</code> sets the overflow handler 
        to be the function specified by <code>func</code>.
        <code>func</code> will be called for all datatype conversions that 
        result in an overflow.  
        <p>
        See the definition of <code>H5T_overflow_t</code> in 
        <code>H5Tpublic.h</code> for documentation  
        of arguments and return values.  
        The prototype for <code>H5T_overflow_t</code> is as follows:<br>
              <code>herr_t (*H5T_overflow_t)(hid_t src_id, hid_t dst_id,
                                 void *src_buf, void *dst_buf);
              </code>
        <p>
        The NULL pointer may be passed to remove the overflow handler.
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>H5T_overflow_t</em>&nbsp;<code>func&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">Overflow function.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns a non-negative value if successful;
        otherwise returns a negative value.
<dt><strong>Fortran90 Interface:</strong>
    <dd>None.
<!--
	<pre>
SUBROUTINE
	</pre>		
-->
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tset_pad" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-SetPad">H5Tset_pad</a>
<dt><strong>Signature:</strong>
    <dd><em>herr_t </em><code>H5Tset_pad</code>(<em>hid_t </em><code>type_id</code>,
        <em>H5T_pad_t</em> <code>lsb</code>,
        <em>H5T_pad_t</em> <code>msb</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Sets the least and most-significant bits padding types.
<dt><strong>Description:</strong>
    <dd><code>H5Tset_pad</code> sets the least and most-significant bits padding types.
        <dl> <ul>
            <dt>H5T_PAD_ZERO (<code>0</code>)
               <dd>Set background to zeros.
            <dt>H5T_PAD_ONE (<code>1</code>)
               <dd>Set background to ones.
            <dt>H5T_PAD_BACKGROUND (<code>2</code>)
               <dd>Leave background alone.
        </ul> </dl>
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em> <code>type_id</code></td>
            <td valign="top">Identifier of datatype to set.</td></tr>
        <tr>
		    <td valign="top"><em>H5T_pad_t</em>&nbsp;<code>lsb&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">Padding type for least-significant bits.</td></tr>
        <tr>
		    <td valign="top"><em>H5T_pad_t</em> <code>msb</code></td>
            <td valign="top">Padding type for most-significant bits.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns a non-negative value if successful;
        otherwise returns a negative value.
<dt><strong>Fortran90 Interface:</strong> h5tset_pad_f
    <dd>
	<pre>
SUBROUTINE h5tset_pad_f(type_id, lsbpad, msbpad, hdferr) 
  IMPLICIT NONE
  INTEGER(HID_T), INTENT(IN) :: type_id ! Datatype identifier 
  INTEGER, INTENT(IN) :: lsbpad         ! Padding type of the 
                                        ! least significant bit
  INTEGER, INTENT(IN) :: msbpad         ! Padding type of the 
                                        ! most significant bit
                                        ! Possible values of padding 
                                        ! type are:
                                        !    H5T_PAD_ZERO_F = 0
                                        !    H5T_PAD_ONE_F = 1
                                        !    H5T_PAD_BACKGROUND_F = 2
                                        !    H5T_PAD_ERROR_F = -1
                                        !    H5T_PAD_NPAD_F = 3
  INTEGER, INTENT(OUT) :: hdferr        ! Error code
END SUBROUTINE h5tset_pad_f
	</pre>		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tset_precision" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-SetPrecision">H5Tset_precision</a>
<dt><strong>Signature:</strong>
    <dd><em>herr_t </em><code>H5Tset_precision</code>(<em>hid_t </em><code>type_id</code>,
        <em>size_t</em><code>precision</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Sets the precision of an atomic datatype.  
<dt><strong>Description:</strong>
    <dd><code>H5Tset_precision</code> sets the precision of an atomic datatype.  
        The precision is the number of significant bits which, unless padding 
        is present, is 8 times larger than the value returned by H5Tget_size().
        <P>If the precision is increased then the offset is decreased and then
            the size is increased to insure that significant bits do not "hang
            over" the edge of the datatype.
        <P>Changing the precision of an H5T_STRING automatically changes the
            size as well.  The precision must be a multiple of 8.
        <P>When decreasing the precision of a floating point type, set the
            locations and sizes of the sign, mantissa, and exponent fields
            first.
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em> <code>type_id</code></td>
            <td valign="top">Identifier of datatype to set.</td></tr>
        <tr>
		    <td valign="top"><em>size_t</em>&nbsp;<code>precision&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">Number of bits of precision for datatype.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns a non-negative value if successful;
        otherwise returns a negative value.
<dt><strong>Fortran90 Interface:</strong> h5tset_precision_f
    <dd>
	<pre>
SUBROUTINE h5tset_precision_f(type_id, precision, hdferr) 
  IMPLICIT NONE
  INTEGER(HID_T), INTENT(IN) :: type_id ! Datatype identifier 
  INTEGER, INTENT(IN) :: precision      ! Datatype precision
  INTEGER, INTENT(OUT) :: hdferr        ! Error code
END SUBROUTINE h5tset_precision_f
	</pre>		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tset_sign" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-SetSign">H5Tset_sign</a>
<dt><strong>Signature:</strong>
    <dd><em>herr_t </em><code>H5Tset_sign</code>(<em>hid_t </em><code>type_id</code>,
        <em>H5T_sign_t</em> <code>sign</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Sets the sign property for an integer type.
<dt><strong>Description:</strong>
    <dd><code>H5Tset_sign</code> sets the sign property for an integer type.
        <dl> 
          <dt>H5T_SGN_NONE (<code>0</code>)
            <dd>Unsigned integer type.
          <dt>H5T_SGN_2 (<code>1</code>)
            <dd>Two's complement signed integer type.
         </dl>
<dt><strong>Parameters:</strong>
    <ul><table>
		<tr>
		    <td valign="top"><em>hid_t</em> <code>type_id</code></td>
            <td valign="top">Identifier of datatype to set.</td></tr>
        <tr>
		    <td valign="top"><em>H5T_sign_t</em>&nbsp;<code>sign&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">Sign type.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns a non-negative value if successful;
        otherwise returns a negative value.
<dt><strong>Fortran90 Interface:</strong> h5tset_sign_f
    <dd>
	<pre>
SUBROUTINE h5tset_sign_f(type_id, sign, hdferr) 
  IMPLICIT NONE
  INTEGER(HID_T), INTENT(IN) :: type_id  
                                  ! Datatype identifier 
  INTEGER, INTENT(IN) :: sign     ! Sign type for an integer type 
                                  ! Possible values are:
                                  !    Unsigned integer type 
                                  !       H5T_SGN_NONE_F = 0
                                  !    Two's complement signed integer type
                                  !       H5T_SGN_2_F = 1
                                  !    or error value 
                                  !       H5T_SGN_ERROR_F=-1 
  INTEGER, INTENT(OUT) :: hdferr  ! Error code
END SUBROUTINE h5tset_sign_f
	</pre>		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tset_size" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-SetSize">H5Tset_size</a>
<dt><strong>Signature:</strong>
    <dd><em>herr_t </em><code>H5Tset_size</code>(<em>hid_t </em><code>type_id</code>,
        <em>size_t</em><code>size</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Sets the total size for an atomic datatype.
<dt><strong>Description:</strong>
    <dd><code>H5Tset_size</code> sets the total size in bytes, 
        <code>size</code>, for a datatype.  If the datatype is atomic and size
         is decreased so that the significant bits of the datatype extend beyond
         the edge of the new size, then the `offset' property is decreased
         toward zero.  If the `offset' becomes zero and the significant
         bits of the datatype still hang over the edge of the new size, then
         the number of significant bits is decreased.
         The size set for a string should include space for the null-terminator
         character, otherwise it will not be stored on (or retrieved from) disk.
         Adjusting the size of a string automatically sets the precision
         to 8*<code>size</code>.  A compound datatype may increase in size, 
         but may not shrink.  All datatypes must have a positive size.
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em>&nbsp;<code>type_id&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">Identifier of datatype to change size.</td></tr>
        <tr>
		    <td valign="top"><em>size_t</em> <code>size</code></td>
            <td valign="top">Size in bytes to modify datatype.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns a non-negative value if successful;
        otherwise returns a negative value.
<dt><strong>Fortran90 Interface:</strong> h5tset_size_f
    <dd>
	<pre>
SUBROUTINE h5tset_size_f(type_id, size, hdferr) 
  IMPLICIT NONE
  INTEGER(HID_T), INTENT(IN) :: type_id  ! Datatype identifier 
  INTEGER(SIZE_T), INTENT(IN) :: size    ! Datatype size
  INTEGER, INTENT(OUT) :: hdferr         ! Error code
                                         ! 0 on success and -1 on failure
END SUBROUTINE h5tset_size_f
	</pre>		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tset_strpad" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-SetStrpad">H5Tset_strpad</a>
<dt><strong>Signature:</strong>
    <dd><em>herr_t </em><code>H5Tset_strpad</code>(<em>hid_t </em><code>type_id</code>,
        <em>H5T_str_t</em> <code>strpad</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Defines the storage mechanism for character strings.
<dt><strong>Description:</strong>
    <dd><code>H5Tset_strpad</code> defines the storage mechanism for the string.
        <p>
        The method used to store character strings differs with the 
        programming language: 
        <ul>
            <li>C usually null terminates strings while 
            <li>Fortran left-justifies and space-pads strings.
        </ul>
        Valid string padding values, as passed in the parameter 
        <code>strpad</code>, are as follows:
        <ul> <dl>
            <dt>H5T_STR_NULLTERM (<code>0</code>)
               <dd>Null terminate (as C does)
            <dt>H5T_STR_NULLPAD (<code>1</code>)
               <dd>Pad with zeros 
            <dt>H5T_STR_SPACEPAD (<code>2</code>)
               <dd>Pad with spaces (as FORTRAN does)
        </dl> </ul>
        <p>
        When converting from a longer string to a shorter string,
        the behavior is as follows.
        If the short string is <code>H5T_STR_NULLPAD</code> or 
        <code>H5T_STR_SPACEPAD</code>, then the string is simply truncated. 
        If the short string is <code>H5T_STR_NULLTERM</code>, it is
        truncated and a null terminator is appended.  
        <p>
        When converting from a shorter string to a longer string,
        the long string is padded on the end by appending nulls or spaces.


<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em> <code>type_id</code></td>
            <td valign="top">Identifier of datatype to modify.</td></tr>
        <tr>
		    <td valign="top"><em>H5T_str_t</em>&nbsp;<code>strpad&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">String padding type.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns a non-negative value if successful;
        otherwise returns a negative value.
<dt><strong>Fortran90 Interface:</strong> h5tset_strpad_f
    <dd>
	<pre>
SUBROUTINE h5tset_strpad_f(type_id, strpad, hdferr) 
  IMPLICIT NONE
  INTEGER(HID_T), INTENT(IN) :: type_id 
                                 ! Datatype identifier 
  INTEGER, INTENT(IN) :: strpad  ! String padding method for a string datatype 
                                 ! Possible values of padding type are:
                                 !    Pad with zeros (as C does): 
                                 !       H5T_STR_NULLPAD_F(0)
                                 !    Pad with spaces (as FORTRAN does): 
                                 !       H5T_STR_SPACEPAD_F(1)
  INTEGER, INTENT(OUT) :: hdferr ! Error code
END SUBROUTINE h5tset_strpad_f
	</pre>		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tset_tag" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-SetTag">H5Tset_tag</a>
<dt><strong>Signature:</strong>
    <dd><em>herr_t</em> <code>H5Tset_tag</code>(<em>hid_t</em> <code>type_id</code>
        <em>const char</em> *<code>tag</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Tags an opaque datatype.
<dt><strong>Description:</strong>
    <dd><code>H5Tset_tag</code> tags an opaque datatype <code>type_id</code>
        with a descriptive ASCII identifier,<code> tag</code>.
        <p>     
        <code>tag</code> is intended to provide a concise description;
        the maximum size is hard-coded in the HDF5 Library as 256 bytes 
        (<code>H5T_OPAQUE_TAG_MAX</code>).
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em> <code>type_id</code></td>
            <td valign="top">IN: Datatype identifier for the opaque datatype to be tagged.</td></tr>
        <tr>
		    <td valign="top"><em>const&nbsp;char</em>&nbsp;*<code>tag&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">IN: Descriptive ASCII string with which the 
                opaque datatype is to be tagged.</td></tr>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns a non-negative value if successful;
        otherwise returns a negative value.
<dt><strong>Fortran90 Interface:</strong> h5tset_tag_f
    <dd>
	<pre>
SUBROUTINE h5tset_tag_f(type_id, tag, hdferr) 
  IMPLICIT NONE
  INTEGER(HID_T), INTENT(IN) :: type_id ! Datatype identifier 
  CHARACTER(LEN=*), INTENT(IN) :: tag   ! Unique ASCII string with which the
                                        ! opaque datatype is to be tagged 
  INTEGER, INTENT(OUT) :: hdferr        ! Error code
END SUBROUTINE h5tset_tag_f
	</pre>
	
<dt><strong>History:</strong>
	<ul><table width="90%">
        <tr>
		  <td valign="top" align="left" width="10%">
		    <strong>Release</strong>&nbsp;&nbsp;&nbsp;&nbsp;</td>
          <td valign="top" align="left">
		    <strong>C</strong></td></tr>
        <tr>
		  <td valign="top">1.6.5</td>
          <td valign="top">
		    The <code>H5T_OPAQUE_TAG_MAX</code> macro constant, 
			specifying the maximum size of an opaque datatype tag, 
			was added in <code>H5Tpublic.h</code>.</td></tr>
    </table></ul>		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tunregister" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-Unregister">H5Tunregister</a>
<dt><strong>Signature:</strong>
    <dd><em>herr_t</em> <code>H5Tunregister</code>(<em>H5T_conv_t</em> <code>func</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Removes a conversion function from all conversion paths.
<dt><strong>Description:</strong>
    <dd><code>H5Tunregister</code> removes a conversion function from all conversion paths.
        <P>
        The conversion function pointer type declaration is described in 
        <a href="#Datatype-Register">H5Tregister</a>.
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>H5T_conv_t</em>&nbsp;<code>func&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">Function to remove from conversion paths.</td>
    </table></ul>
<dt><strong>Returns:</strong>
    <dd>Returns a non-negative value if successful;
        otherwise returns a negative value.
<dt><strong>Fortran90 Interface:</strong>
    <dd>None.
<!--
	<pre>
SUBROUTINE
	</pre>		
-->
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
<dt><strong>History:</strong>
    <ul><table width="90%">
        <tr>
		  <td valign="top" align="left" width="10%">
		    <strong>Release</strong>&nbsp;&nbsp;&nbsp;&nbsp;</td>
          <td valign="top" align="left">
		    <strong>C</strong></td></tr>
        <tr>
		  <td valign="top">1.6.3</td>
          <td valign="top">
			The following change occurred in the 
			<code>H5Tconv_t</code> function:<br>
                        &nbsp;&nbsp;
			<code>nelmts</code> parameter type changed to 
			<em>size_t</em>.</td></tr>
    </table></ul>
</dl>

<!-- NEW PAGE -->
<!-- HEADER RIGHT "H5Tvlen_create" -->
<hr>
<dl>
<dt><strong>Name:</strong> <a name="Datatype-VLCreate">H5Tvlen_create</a>
<dt><strong>Signature:</strong>
    <dd><em>hid_t </em><code>H5Tvlen_create</code>(<em>hid_t </em><code>base_type_id</code>
    )
<dt><strong>Purpose:</strong>
    <dd>Creates a new variable-length datatype.
<dt><strong>Description:</strong>
    <dd><code>H5Tvlen_create</code> creates a new variable-length (VL) datatype.
        <p>
        The base datatype will be the datatype that the sequence is composed of,
        characters for character strings, vertex coordinates for polygon lists, etc.
        The base type specified for the VL datatype can be of any HDF5 datatype,
        including another VL datatype, a compound datatype or an atomic datatype.
        <p>
        When necessary, use <code>H5Tget_super</code> to determine the base type 
        of the VL datatype.
        <p>
        The datatype identifier returned from this function should be 
        released with <code>H5Tclose</code> or resource leaks will result.
<dt><strong>Parameters:</strong>
    <ul><table>
        <tr>
		    <td valign="top"><em>hid_t</em>&nbsp;<code>base_type_id&nbsp;&nbsp;&nbsp;&nbsp;</code></td>
            <td valign="top">Base type of datatype to create.</td></tr>
    </table></ul>
<dt><strong>See Also:</strong>
    <dd><a href="RM_H5D.html#Dataset-GetVLBuf">H5Dget_vlen_buf_size</a>
    <dd><a href="RM_H5D.html#Dataset-VLReclaim">H5Dvlen_reclaim</a>
<dt><strong>Returns:</strong>
    <dd>Returns datatype identifier if successful;
        otherwise returns a negative value.
<dt><strong>Fortran90 Interface:</strong> h5tvlen_create_f
    <dd>
	<pre>
SUBROUTINE h5tvlen_create_f(type_id, vltype_id, hdferr) 
  IMPLICIT NONE
  INTEGER(HID_T), INTENT(IN) :: type_id    ! Datatype identifier of base type 
                                           ! Base type can only be atomic 
  INTEGER(HID_T), INTENT(OUT) :: vltype_id ! VL datatype identifier 
  INTEGER, INTENT(OUT) :: hdferr           ! Error code
END SUBROUTINE h5tvlen_create_f
	</pre>		
		
		<!--<dt><strong>Non-C API(s):</strong>
    	<dd>
        
        <img src="Graphics/Java.gif"> 
        <img src="Graphics/C++.gif">
        -->
  <dt><strong>History:</strong>
    <ul><table width="90%">
        <tr>
		  <td valign="top" align="left" width="10%">
		    <strong>Release</strong>&nbsp;&nbsp;&nbsp;&nbsp;</td>
          <td valign="top" align="left">
		    <strong>Fortran90</strong></td></tr>
		<tr>
		  <td valign="top">1.4.5</td>
          <td valign="top">
		    Function introduced in this release.</td></tr>
    </table></ul>
</dl>

<!-- #BeginLibraryItem "/ed_libs/NavBar_RM.lbi" -->
<hr>
<center>
<table border=0 width=98%>
<tr><td valign=top align=left>
<a href="index.html">HDF5 documents and links</a>&nbsp;<br>
<a href="H5.intro.html">Introduction to HDF5</a>&nbsp;<br>
<a href="http://hdf.ncsa.uiuc.edu/HDF5/doc/UG/index.html">HDF5 User Guide</a>&nbsp;<br>
<!--
<a href="Glossary.html">Glossary</a><br>
-->
</td>
<td valign=top align=right>
And in this document, the 
<a href="RM_H5Front.html">HDF5 Reference Manual</a>&nbsp;&nbsp;<br>
<a href="RM_H5.html">H5</a>&nbsp;&nbsp;
<a href="RM_H5A.html">H5A</a>&nbsp;&nbsp;
<a href="RM_H5D.html">H5D</a>&nbsp;&nbsp;
<a href="RM_H5E.html">H5E</a>&nbsp;&nbsp;
<a href="RM_H5F.html">H5F</a>&nbsp;&nbsp;
<a href="RM_H5G.html">H5G</a>&nbsp;&nbsp;
<a href="RM_H5I.html">H5I</a>&nbsp;&nbsp;
<a href="RM_H5P.html">H5P</a>&nbsp;&nbsp;<br>
<a href="RM_H5R.html">H5R</a>&nbsp;&nbsp;
<a href="RM_H5S.html">H5S</a>&nbsp;&nbsp;
<a href="RM_H5T.html">H5T</a>&nbsp;&nbsp;
<a href="RM_H5Z.html">H5Z</a>&nbsp;&nbsp;
<a href="Tools.html">Tools</a>&nbsp;&nbsp;
<a href="PredefDTypes.html">Datatypes</a>&nbsp;&nbsp;
</td></tr>
<tr><td colspan="2" align="right">
<i><small>(<a href="http://hdf.ncsa.uiuc.edu/HDF5/doc/PSandPDF/">PDF</a>
of complete manual formatted as print volume)&nbsp;&nbsp;&nbsp;</small></i>
</td></tr>
</table>
</center>
<hr>
<!-- #EndLibraryItem --><!-- #BeginLibraryItem "/ed_libs/Footer.lbi" -->
<address>
<a href="mailto:hdfhelp@ncsa.uiuc.edu">HDF Help Desk</a> 
<br>
Describes HDF5 Release 1.6.5, November 2005
</address>
<!-- #EndLibraryItem --><SCRIPT LANGUAGE="JAVASCRIPT">
<!--
document.writeln("Last modified: 7 November 2005");
-->
</SCRIPT>
 
</body>
</html>
